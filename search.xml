<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JQ源码解析--从放弃到入门]]></title>
    <url>%2F2017%2F11%2F07%2FJQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BB%8E%E6%94%BE%E5%BC%83%E5%88%B0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[仔细想想 用了那么多年JQ却从来没仔细研究过他的源码😨😨😨😨😨😨😨 知道前两天被小伙伴质疑，突然觉得 真心应该花点时间仔细研究一下!要不都对不起这么多年写过的BUG。。。。 BUT 每次一看源码总是头大。。。。。。 所以 浏览了一些大神的博客 从中找了一些经典的整理总结一下 嘿嘿 So如有雷同 嫑介意哈 🙂 JQ整体架构 -&gt; { 1、变量，常规正则初始化 2、工具方法 3、$.ready() 4、复杂选择器 5、回调对象：$.callback() 6、延迟对象：对异步的统一管理 $.deferred() 7、浏览器功能检测$.support 8、数据存储$.data 9、队列方法：执行顺序的管理 10、对元素属性的操作 11、事件操作的各种方法 12、DOM操作 13、样式操作 14、AJAX() 15、动画 16、位置和尺寸 17、模块化 18、jQuery } JQ的整体结构看上去还是划分的蛮清晰的，BUT以上每个代码模块其实真心难看难懂😢😢😢😢，9000多行代码怎么看，真心想哭 所以 小仙女 就在这以自己觉得 还算是比较容易理解的角度给大家说一说吧 再说之前，推荐个工具 👇 JQ源码查看工具 http://www.css88.com/tool/jQuerySourceViewer 真心好用 可以已选择您想查看的JQ的版本，并筛选里面想要查看的方法源码 首先 JQ有一个规则 就是可能出现在任意模块的公共变量，方法，正则等全部定义在脚本的最上方，然后每个模块自己会用到的公 共变量，方法，正则等会定义到这个模块的上方 MAYBE 看的时候 可能会出现要前后代码来回跳跃，SO 我们最好先不要在意这些细节，因为你现在看见的变量也许在脚本结尾才会 被调用。。。 1、jQuery 闭包结构 // 用一个函数域包起来，就是所谓的沙箱 // 在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局 // 把当前沙箱需要的外部变量通过函数参数引入进来 // 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 (function(window, undefined) { // jQuery 代码 })(window); 将代码包裹在一个闭包中，既不会污染全局，又方便好用，真是机智啊。。。。在最后暴露出$和JQuery这两个变量出来， 大大降低了冲突的可能性。 // 压缩策略 // w -&gt; windwow , u -&gt; undefined (function(w, u) { })(window); 2、拒绝new 使用JQ的时候我们一般都会使用无new构造 // 无 new 构造 $(‘#test’).text(‘Test’); // 当然也可以使用 new var test = new $(‘#test’); test.text(‘Test’); 其实无NEW构造就相当于new jQuery()，看一下源码是怎么定义的 (function(window, undefined) { var // … jQuery = function(selector, context) { // The jQuery object is actually just the init constructor ‘enhanced’ // 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init return new jQuery.fn.init(selector, context, rootjQuery); }, // jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用 jQuery.fn = jQuery.prototype = { // 实例化化方法，这个方法可以称作 jQuery 对象构造器 init: function(selector, context, rootjQuery) { // ... } } // 这一句很关键，也很绕 // jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数 // 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例 // 且实例还要能正确访问 jQuery 类原型上的属性与方法 // jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype // 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法 jQuery.fn.init.prototype = jQuery.fn; })(window); ① 首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。 ② 将jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。 ③ 也就是实例化方法存在这么一个关系链 👇 jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ; new jQuery.fn.init() 相当于 new jQuery() ; jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。 3、方法的重载 JQ使用了大量的方法重载，绕呀绕呀 就把小可爱们弄蒙啦，小仙女也是看着看着就跑偏了 举个 🌰 // 获取 name 属性的值 $(‘#id’).attr(‘name’); // 设置 name 属性的值 $(‘#id’).attr(‘name’,’jQuery’); // 获取 css 某个属性的值 $(‘#id’).css(‘height’); // 设置 css 某个属性的值 $(‘#id’).css(‘height’,’100px’); 啥是方法重载那？说你白了就是一个方法实现了很多个弄能，虽然读起来不太容易，但还是很好用的。 大多数人使用 jQuery() 构造方法使用的最多的就是直接实例化一个 jQuery 对象，但其实在它的内部实现中，有着 9种不同的方法重载场景：看介里 👇 // 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器 jQuery([selector,[context]]) // 传入单个 DOM jQuery(element) // 传入 DOM 数组 jQuery(elementArray) // 传入 JS 对象 jQuery(object) // 传入 jQuery 对象 jQuery(jQuery object) // 传入原始 HTML 的字符串来创建 DOM 元素 jQuery(html,[ownerDocument]) jQuery(html,[attributes]) // 传入空参数 jQuery() // 绑定一个在 DOM 文档载入完成后执行的函数 jQuery(callback) 📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢 由于篇幅比较长，小仙女是写一下点传一点，所以可能每次进来内容都会增多！！！！！！！]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DomDiff算法理解]]></title>
    <url>%2F2017%2F11%2F06%2FDomDiff%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[按照层级 找到两棵任意的树之间最小的修改是一个复杂度为 O(n^3) 的问题. React 用了一种简单但是强大的技巧, 达到了接近 O(n) 的复杂度. React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 假设我们有个 component, 一个循环渲染了 5 个 component,随后又在列表中间插入一个新的 component. 默认情况下, React 会将前一个列表第一个 component 和后一个第一个关联起来, 后面也是. 你可以写一个 key 属性帮助 React 来处理它们之间的对应关系. 事件代理 React 部署了种流行技术, 叫做”事件代理”. React 走得更远, 重新实现了一遍符合 W3C 规范的事件系统 事件 listener 被绑定到整个文档的根节点上. 当事件被触发, 浏览器会给出一个触发的目标的 DOM 节点. 为了在 DOM 的层级传播事件, React 不会迭代 virtual DOM 的层级. 而是, 我们依靠每个 React component 各自独立的 id 来编码这个层级 我们能通过简单的字符串操作来获取所有父级 component 的父级内容. 渲染 合并操作：调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 这里的”合并操作”是说, 在一个事件循环当中, DOM 只会被更新一次. 子树渲染：调用 setState 方法时, component 会重新构建包括子节点的 virtual DOM. 如果你在根节点调用 setState, 整个 React 的应用都会被重新渲染. 所有的 component, 即便没有更新, 都会调用他们的 render 方法. React 消耗性能的模型很简单, 很好理解: 每次调用 setState 会重新计算整个子树. 如果你想要提高性能, 尽量少调用 setState, 还有用 shouldComponentUpdate 减少大的子树的重新计算.]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part Three 基础篇]]></title>
    <url>%2F2017%2F11%2F06%2F%E9%9D%A2%E8%AF%953%2F</url>
    <content type="text"><![CDATA[咱们书接上回😊 额O__O “…”貌似真的有点久远 20、vue的数据理解 data:是vue绑定数据的数据源 原理:vue会自动将data里面的数据进行递归。抓换成getter和setter computed:计算属性 watch:监听 watch：{ a:function（val，oldval）{} handler:function(){ deep：true } } 21、vue的特点 简洁 轻量 组件化 数据驱动 22、vue的生命周期是什么 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 beforeUpdate: update: beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 23、Vue的自定义指令 vue.directive(‘img’,{ // 当绑定元素插入到 DOM 中。 insert:function(el,binding){ var color = red; el.style.backgroundColor = color var img = new Image(); img.src = binding.value; img.onload = function (){ el.style.backgroundImage = &apos;url()&apos; } } }) bind: 只调用一次，指令第一次绑定到元素时调用， 用这个钩子函数可以定义一个在绑定时执行一次 的初始化动作。 inserted: 被绑定元素插入父节点时调用 （父节点存在即可调用，不必存在于 document 中）。 update: 所在组件的 VNode 更新时调用，但是可 能发生在其孩子的 VNode 更新之前。 指令的值可能发生了改变也可能没有。 但是你可以通过比较更新前后的值来忽略 不必要的模板更新 componentUpdated: 所在组件的 VNode 及其 孩子的 VNode 全部更新时调用 unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数的参数 (包括 el，binding，vnode，oldVnode) el: 指令所绑定的元素，可以用来直接操作 DOM binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 无论值是否改变都可用。 Vue.directive(‘demo’, { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = ‘name: ‘ + s(binding.name) + ‘ ‘ + ‘value: ‘ + s(binding.value) + ‘ ‘ + ‘expression: ‘ + s(binding.expression) + ‘ ‘ + ‘argument: ‘ + s(binding.arg) + ‘ ‘ + ‘modifiers: ‘ + s(binding.modifiers) + ‘ ‘ + ‘vnode keys: ‘ + Object.keys(vnode).join(‘, ‘) } }) new Vue({ el: ‘#hook-arguments-example’, data: { message: ‘hello!’ } }) Vue.directive(‘demo’, function (el, binding) { console.log(binding.value.color) // =&gt; “white” console.log(binding.value.text) // =&gt; “hello!” }) 24、react的生命周期有那些 constructor(props, context) 构造函数，在创建组件的时候调用一次。 void componentWillMount() 在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。 void componentDidMount() 在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。 void componentWillReceiveProps(nextProps) props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。 bool shouldComponentUpdate(nextProps, nextState) 组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 void componentWillUpdate(nextProps, nextState) shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。 void componentDidUpdate() 除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。 ReactElement render() render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。 void componentWillUnmount() 组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。 25、prop和state的区别理解 ① state是react中一个对象，用来存储状态值，一般用setstate(data，callback) ② state存储可能被事件处理器修改的数据 ③ 一般用来传递数据，setprop()]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS的问题一]]></title>
    <url>%2F2017%2F11%2F06%2FNodeJS%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[几个node中需要注意的问题 1、什么是时间循环? Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式） 2、什么是错误优先的回调函数？ 错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。 其余的参数用于传递数据。例如： fs.readFile(filePath, function(err, data) { if (err) { //handle the error } // use the data object }); 3、什么是stub？举个应用场景 Stub是用于模拟一个组件或模块的函数或程序 你可以用Stub去模拟一个方法，从而避免调用真实的方法， 使用Stub你还可以返回虚构的结果 举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时： var fs = require(‘fs’); var readFileStub = sinon.stub(fs, ‘readFile’, function (path, cb) { return cb(null, ‘filecontent’); }); expect(readFileStub).to.be.called; readFileStub.restore(); 4、如何用node监听80端口？ 在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 目前，如果你一定要让你的应用监听80端口的话，你可以有通过在Node应用的前方再增加一层反向代理 （例如nginx）来实现 5、如何避免回调地狱？ 模块化：将回调函数分割为独立的函数 使用Promises 使用yield 来计算生成器或Promise 6、怎么处理异步? 初级方案：通过递归处理异步回调 var fs = require(‘fs’); // 要处理的文件列表 var files = [‘file1’, ‘file2’, ‘file3’]; function parseFile () { if (files.length == 0) { return; } var file = files.shift(); fs.readFile(file, function (err, data) { // 这里处理文件数据 parseFile(); // 处理完毕后，通过递归调用处理下一个文件 }); } // 开始处理 parseFile(); 华丽点：采用Async、Q、Promise等第三方库处理异步回调 优雅点：拥抱ES6，替代回调函数，解决回调地狱问题.使用Generator特性替代回调函数 var fs = require(‘fs’) , co = require(‘co’) , thunkify = require(‘thunkify’); var readFile = thunkify(fs.readFile); co(function *() { var test1 = yield readFile(‘test1.txt’); var test2 = yield readFile(‘test2.txt’); var test = test1.toString() + test2.toString(); console.log(test); })();]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>NODEJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慢谈继承]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%85%A2%E8%B0%88%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[让我们先看几张图 //约定 function Fun(){ //私有属性 var val = 1;// 私有基本属性 var arr = [1]; // 私有引用属性 function f(){} // 私有函数（引用属性） //实例属性 this.val = 1; // 实例基本属性 this.arr = [1];// 实例引用属性 this.f = function(){} // 实例函数（引用属性） } //原型属性 Fun.prototype.val = 1;// 原型基本属性 Function.prototype.arr = [1]; // 原型引用属性 Fun.prototype.f = function(){}; // 原型函数（引用属性） //简单原型链继承 function A(){ this.val = 1; this.arr = [1]; } function B(){} //拿父类实例来充当子类原型对象 B.prototype = new A();//核心 var b1 = new B(); var b2 = new B(); b1.val = 2; b1.arr.push(2); console.log(b1.arr)//2 console.log(b2.arr)//1 //修改b1.arr后b2.arr也变了，因为来自原型对象的引用属性是所有实例共享的。 //创建子类实例时，无法向父类构造函数传参 console.log(b1.arr)//1,2 console.log(b2.arr)//1,2 ##################################################### //构造函数继承 function A(x){ this.x = x; this.arr = [1]; this.f = function(){} } function B(y){ //借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型） A.call(this,y) // 核心 } var b1 = new B(1); var b2 = new B(2); b1.arr.push(2); console.log(b1.x);//1 console.log(b2.x);//2 console.log(b1.arr)//1,2 console.log(b2.arr)//1 //无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。。 console.log(b1.f === b2.f) //false ######################################################## //组合继承 function A(){ this.x = 1; this.arr = [1] } A.prototype.f1 = function(){} A.prototype.f2 = function(){} function B(){ A.call(this); } B.prototype = new A(); //把实例函数都放在原型对象上，以实现函数复用。 //同时还要保留借用构造函数方式的优点，通过Super.call(this); //继承父类的基本属性和引用属性并保留能传参的优点； //通过Sub.prototype = new Super(); //继承父类函数，实现函数复用 var b1 = new B(1); var b2 = new B(2); console.log(b1.f === b2.f)//true //子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次， //生成了两份，而子类实例上的那一份屏蔽了子类原型上的 #################################################### //寄生组合继承 function Bus(obj){ var F = function(){} F.prototype = obj; return new F(); } function A(){ this.x = 1; this.arr = [1]; } A.prototype.f = function(){} function B(){ A.call(this) } //用Bus(A.prototype)切掉了原型对象上多余的那份父类实例属性 var proto = Bus(A.proto); proto.constructor = B; B.prototype = proto; var b1 = new B(); #################################################### //原型继承，Object.create()函数，内部就是原型式继承 function Bus(obj){ var F = function(){}; F.prototype = obj; return new F(); } function A(){ this.x = 1; this.arr = [1]; } var a = new A();; //Bus函数得到得到一个“纯洁”的新对象（“纯洁”是因为没有实例属性），再逐步增强之（填充实例属性） var b = Bus(a); b.z = 2; console.log(b.x)//1; console.log(b.arr)//1; console.log(b.z)//2]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见入门算法]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%B8%B8%E8%A7%81%E5%85%A5%E9%97%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、斐波那契数列 function fibonacci(n){ if(n==1 || n==2) return 1; return fibonacci(n-1)+fibonacci(n-2) } 2、快排 var quickSort = function(arr) { if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).concat([pivot], quickSort(right)); }; 3、数组去重 原始方法 Array.prototype.uniq = function () { var resArr = []; var flag = true; for(var i=0;i&lt;this.length;i++){ if(resArr.indexOf(this[i]) == -1){ if(this[i] != this[i]){ //排除 NaN if(flag){ resArr.push(this[i]); flag = false; } }else{ resArr.push(this[i]); } } } return resArr; } ES6 function Unique(arr){ return Array.from(new Set(arr)) } 4、去掉左右两侧空格 var reg = /^\s |\s$/g; var str = “”; str.replace(reg, “”)]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和数组中的坑]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一说到数组，都是眼泪😢，原生的JS数组包含了太多种方法！！！更别说JQ例了 可以说，一遇到数组这个小婊砸，真是有的玩了。。。 让我们举几个常见的 🌰 吧 1、合并两个数组 function concat(arr1, arr2) { return arr1.concat(arr2) } 2、数组中某个值出现次数 function count(arr, item) { var count = arr.filter(function(a) { return a === item; }); return count.length; } 3、数组中某元素位置 function indexOf(arr,item){ return arr.indexOf(item) } 4、数组中重复数据并排序 function duplicates(arr) { var a=[]; var b=[]; for(var i=0; i&lt;arr.length;i++){ if(a.indexOf(arr[i]) == -1){ a.push(arr[i]); }else if(b.indexOf(arr[i]) == -1){ b.push(arr[i]); } } return b; } 5、数组开头增加元素 function prepend(arr, item) { var newArr = arr.slice(0) newArr.unshift(item) return newArr } 6、数组末尾增加一个元素 function append(arr, item) { var newArr = arr.slice(0) newArr.push(item) return newArr; } 7、数组某个位置插入某个值 function insert(arr, item, index) { var a = arr.slice(0) a.splice(index,0,item) return a } 8、数组求二次方 function square(arr) { return arr.map(function(x){ return x*x; }) } 9、数组求和 (function() { var sum = 0; function getSum(array){ for (var i = 0; i &lt; array.length; i++){ sum += parseInt(array[i]); } return sum; })() 10、移除数组中与X相等的值 function removeWithoutCopy(arr, item) { var index; for(var i= 0; i&lt;arr.length ; i++){ if(arr[i] == item){ arr.splice(i,1) i--; } } return arr; } 11、移除数组最后一位返回新数组 function truncate(arr) { return arr.slice(0,arr.length-1) } 12、移除数组第一位元素 function curtail(arr) { return arr.slice(1) } 13、移除数组返回新数组 function remove(arr, item) { var newArr = []; for(var i=0;i&lt;arr.length;i++){ if(arr[i]!=item){ newArr.push(arr[i]) } } return newArr; } 14、移除数组返回本数组 function removeWithoutCopy(arr, item) { var i = arr.indexOf(item) if(i &gt; -1){ return arr.splice(index,1) } }]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询响应式页面]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[@media（min-width:768px） @media screen and (max-width: 300px) { body { background-color:lightblue; } } 响应式的页面 width/height：浏览器可视宽度(也叫视口)/浏览器可见高度. device-width/device-height：设备屏幕宽度/设备屏幕高度. color:检测颜色的位数。（例如：min-color:32 就是检测设备是否拥有32位颜色 #000000） color-index:检查设备索引颜色表中的颜色(颜色值不能小于0)。 orientation：判断当前设备是横屏还是竖屏. aspect-ratio:检测浏览器可视宽度和高度的比例。(现在宽高比为16:9是最佳的，比如我做的直播窗口，要求宽高比就是16:9) device-aspect-ratio:检测设备的宽度和高度的比例。 resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格设备的还是位图设备。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个很少用得到）]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栅格化布局]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%A0%85%E6%A0%BC%E5%8C%96%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[假设：Flowline的宽度为W，column的宽度为c，Gutter的宽度为g，Margin的宽度为m，栅格列数为N W = c*N + g*(N-1) + 2m；g的宽度通常为m的两倍，所以： W = (c+g) * N；把c+g记为C，得： W = C * N; Bootstrap的栅格系统 BootStrap中合理的使用栅格布局，必须将列放入row中，而row必须放入container中。container类在布局中主要有两个作用： 在不同的宽度区间内（响应式断点）提供宽度限制。当宽度变化时，采用不同的宽度。 提供一个padding，阻止内部内容触碰到浏览器边界。 Row是column的容器，每个row中的column之和必须为12，不过我们可以通过嵌套的方式扩展。Row的左右margin都为-15px， 用来抵消container中的padding，如下图蓝色部分所示： Colomn是栅格系统的主角，每个column左右padding都为15px，上文中row的负margin抵消了container的padding， 所以为每个column设置padding就是为了防止内容直接触碰边界，同时不同的column之间拥有30px的卡槽（Gutter）]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的几种方式]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[没有对象的 看过来 看过来 1、工厂模式 function createPerson(name,age,job){ var obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayHello = function(){ alert(‘hello!’) } return obj } var p1 = createPerson(‘nini’,29,’worker’); var p2 = createPerson(‘cc’,33,’doctor’) 2、构造函数方式 function Person(name,age){ this.name = name; this.age = age; this.say = function(){ alert(‘hello’) } } var p1 = new Person(…); var p2 = new Person(…); 3、原型模式 function Person(){} Person.prototype.name = “nini”; Person.prototype.age = 12; Person.prototype.say = function(){} var p1 = new Person(); p1.say(); p1.name; function Person(){ } Person.prototype={ name:”…”, age:29, job:”…”, sayName:function(){ … } }; Object.defineProperty(Person.prototype,”constructor”,{ enumerable:false, value:Person, }); 4、混合模式 function Person(name,age,job){ this.name = name; this.age = age; this.job = job; } Person.prototype = { constructor:Person, say:function(){ alert(this.name) } } var p1 = new Person(…) 5、动态原型 function Person(name,age,job){ this.name = name; this.age = age; this.job = job if(typeof this.sayName != “function”){ Person.prototype.say = function(){ alert(this.name) } } } 6、对象字面量 var person = { name:’aa’, age:19, say:function(){ } } person.say(); //对象字面量是一个表达式，这个表达式的每次运算都将创建并初始化一个新的对象 //每次计算对象字面量的时候，也都会计算它每个属性的值。 //也就是说，如果在一个重复调用的函数中的循环体内使用了对象字面量， //它将创建很多新对象，并且每次创建的新对象的属性值也有可能不同。 7、object实例 var person = new Object(); person.name = “aa”; person.age = 19; person.say = function(){ } person.name() 8、Object.create（）]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链的理解例子和图片]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[原型链 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个原型对象,每个原型对象都包含一个指向构造函数的指针,而实例则包含一个指向原型对象的指针。 假如让A原型对象等于B构造函数的实例，那么A原型对象就会有一个[[Prototype]]指针指向B原型对象， 同时B原型对象的constructor属性又指向了B构造函数； 假如让B原型对象等于C构造函数的实例，上述关系依然成立； 如此层层递进，从而实现了实例与原型之间的链接；这就是原型链的基本概念。 下面是我画的一张图，方便理解吧 👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 既然如此，Object构造函数是最顶层的构造函数，所有函数的默认原型都是Object的实例， 因此默认原型都会包含一个[[Prototype]]指针，指向Object.prototype； 这也是所有自定义类型都会继承Object类型所拥有的实例和方法的根本原因。 确认原型和实例之间的关系 instanceof操作符；只要是原型链上出现过的构造函数，都会返回true。instanceof操作符的本质在于：左边的操作数的原型链上是否有右边的操作数的prototype属性。 isPrototypeOf()方法，只要是原型链上出现过的原型，都会返回true function A(name){ this.name = name; }; A.prototype.sayName = function(){ alert(this.name); }; function B(age){ this.age = age; }; B.prototype = new A(); B.prototype.sayAge = function(){ alert(this.age); }; var x = new B(); x.name = “CC”; console.log(x.sayName()); //“CC” console.log(x instanceof B); //true console.log(x instanceof A); //true console.log(x instanceof Object); //true console.log(Object.prototype.isPrototypeOf(x)); //true console.log(A.prototype.isPrototypeOf(x)); //true console.log(B.prototype.isPrototypeOf(x)); //true]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象问题]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对象，一直是让小仙女头疼的问题。。。 先说说最基础的属性吧，什么是对象的属性? //数据属性与访问器属性 //数据属性即有值的属性,访问器属性是用来设置getter和setter的,//在属性名前加上”_”（下划线）表示该属性只能通过访问器访问（私有属性) 数据属性具有4个描述其行为的特性： 1、Configurable：能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 默认为true。 2、Enumerable：表示能否通过for-in循环返回属性。默认为true 除了for-in循环之外，ECMAScript5定义了两个用以枚举属性名称的函数 Object.keys()：返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。 Object.getOwnPropertyNames()：返回对象的所有自有属性的名称，而不仅限于可枚举的属性 3、Writable：能否修改属性的值。默认为true。 4、Value： 包含这个属性的数据值；读取属性值的时候，从这个位置读取；写入属性值的时候，把值保存在这里。 特性默认为undefined。 访问器属性 包含一对getter和setter方法。访问器属性有如下4个特性： 1、Configurable 2、Enumerable 3、Get：在读取属性时调用的函数；默认值为undefined。在读取访问器属性时，会调用gette方法，这个函数负责返回有效的值。 4、Set：在写入属性时调用的函数；默认值为undefined。在写入访问器属性时，会调用setter方法并传入新值，这个函数负责决定如何处理数据。 访问器属性不能直接定义，必须使用Object.defineProperties()方法来定义。 属性的特性规则 1、如果对象是不可扩展的，则可以编辑已有的自有属性，但不能添加新属性； 2、如果属性是不可配置的，则不能修改它的可配置性和可枚举性 3、如果访问器属性是不可配置的，则不能修改其getter和setter方法 🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚 通过描述符一次性定义多个属性； 接收两个对象参数：第一个对象是要添加或修改其属性的对象；第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 var person = {} Object.defineProperties(person,{ name:{ value:”cc” }, age:{ value:23, writable:false } }) //要修改数据属性默认的特性，必须使用ECMAScript5中的Object.defineProperty()方法 //三个参数：属性所在的对象、属性的名字、描述符对象 //数据属性描述符对象的属性必须是：configurable、enumerable、writable、value //访问器属性的描述符对象的属性有configurable、enumerable、get、set。 //设置其中的一个或多个值，可以修改对应的特性值。 var person = {}; Object.defineProperty(person,”name”,{ witable:false, value:”CC” //如果不指定，configurable、enumerable、writable特性的值都是false。 }) console.log(person.name);//CC person.name = “VV”; console.log(person.name)//CC //注意：使用Object.defineProperty()方法，要么修改已有属性，要么新建自有属性，不能修改继承属性。 可以取得给定属性的描述符 接收两个参数：属性所在的对象，要读取其描述符的属性名称。 返回值是一个对象 //Object.getOwnPropertyDescriptor()方法，只能用于实例属性 var person = {}; Object.defineProperties(person, { name: { value: “CC”, writable: true }, age: { value: 23, writable: false } }); var descriptor = Object.getOwnPropertyDescriptor(person, “name”); alert(descriptor.value); //“CC” alert(descriptor.writable); //true 使用arguments function useArguments() { var result = Array.prototype.reduce.call(arguments,function(a,b){return a+b;}); return result; } 遍历对象 function iterate(obj) { return Object.getOwnPropertyNames(obj).map(function(key){ return key+”: “+obj[key]; }); }]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等高布局的五种方式]]></title>
    <url>%2F2017%2F11%2F03%2F%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方法一：伪等高 这种方式，并不是真正的实现了元素等高 上代码喽 &lt;style&gt; *{ margin: 0; } .p{ position: relative; } .left{ position: absolute; top:0; left: 0; width:100px; background: green } .right{ position: absolute; top: 0; right: 0; width:200px; background: pink; } .center{ box-sizing:border-box; background-clip: content-box; padding:0 20px; border-left: 100px solid green; border-right: 200px solid pink; background: red; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;jjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;lllll&lt;/p&gt; &lt;p&gt;jkljlkjl&lt;/p&gt; &lt;p&gt;jlskjldjsas&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;;;;;&lt;/p&gt; &lt;p&gt;jjjjj&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 结果： 方法二：伪等高 &lt;style&gt; *{ margin:0; } .par{ overflow: hidden; } .left{ float: left; width: 20%; padding-bottom: 9999px; margin-bottom: -9999px; background: red; } .center{ margin:0 20px; background: pink; } .right{ float: right; width: 20%; padding-bottom: 9999px; margin-bottom: -9999px; background: red; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;jjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;;;;;&lt;/p&gt; &lt;p&gt;jjjjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;lllll&lt;/p&gt; &lt;p&gt;jkljlkjl&lt;/p&gt; &lt;p&gt;jlskjldjsas&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 结果： 方法三：真等高 &lt;style&gt; body,p{margin: 0;} .parent{ display: table; width: 100%; table-layout: fixed; } .left,.centerWrap,.right{ display: table-cell; } .center{ margin: 0 20px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;parent&quot; style=&quot;background-color: lightgrey;&quot;&gt; &lt;div class=&quot;left&quot; style=&quot;background-color: lightblue;&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;centerWrap&quot;&gt; &lt;div class=&quot;center&quot; style=&quot;background-color: pink;&quot;&gt; &lt;p&gt;center&lt;/p&gt; &lt;p&gt;center&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot; style=&quot;background-color: lightgreen;&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 结果： 方法四：真等高 //设置子元素的top:0;bottom:0 body,p{ margin: 0; } .parent{ position: relative; height: 40px; } .left,.center,.right{ position: absolute; top: 0; bottom: 0; } .left{ left: 0; width: 100px; } .center{ left: 120px; right: 120px; } .right{ width: 100px; right: 0; } 方法五：flex &lt;!-- flex中的伸缩项目默认都拉伸为父元素的高度，也实现了等高效果 --&gt; body,p{ margin: 0; } .parent{ display: flex; } .left,.center,.right{ flex: 1; } .center{ margin: 0 20px; }]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字分割线问题解决]]></title>
    <url>%2F2017%2F11%2F03%2F%E6%96%87%E5%AD%97%E5%88%86%E5%89%B2%E7%BA%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前两天在一个项目里，小仙女可是被这个分割线问题气死了 😠😠😠😠😠😠😠 不知道小可爱们会不会遇到下面的问题 看下面 👇👇👇👇👇👇👇👇 &lt;style type=&quot;text/css&quot;&gt; div{ padding: 0 20px 0; margin: 20px 0; line-height: 1px; border-left: 200px solid #ddd; border-right: 200px solid #ddd; text-align: center; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;hkjhjhjhkhkj&lt;/div&gt; &lt;/body&gt; 这样 原本看上去 很美好😊😊😊😊😊😊😊😊 but 当你将屏幕横向拉伸的时候 苦逼的事情就粗线了 😨 看这里 👇👇👇👇 AND 看这里 👇👇👇👇👇 真是要疯掉了，人家想要的是无论什么情况下，都是介个样子滴 👇👇👇👇👇 蓝瘦香菇😭 So 基于上线的小仙女 想了一个办法，总算可以解决这个问题，but 不一定是最好的，但是可以参考一下啦！！！！ 🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉 &lt;style&gt; .flex{ list-style:none; display:-webkit-flex; padding:0; margin:0; color:#fff; } .red{ background-color: red; flex:2; } .blue{ background-color:green; flex:3; text-align: center; } .green{ background-color:red; flex:2; } .three-column { width: 100%; height: 500px; display: box; display: -webkit-box; display: flex; } .two { -webkit-box-flex: 1; flex: 1 } .one, .three { width: 200px; } &lt;/style&gt; &lt;body&gt; &lt;ul class=&quot;flex&quot;&gt; &lt;li class=&quot;red&quot;&gt;11&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;jjjjj&lt;/li&gt; &lt;li class=&quot;green&quot;&gt;33&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于多栏布局以及自适应问题]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[今天我们来谈谈多栏布局吧！Let’s Go 🚄🚄🚄🚄🚄 下面是我日常遇见过得双栏布局和三栏布局，当然还有其他布局模式，BUT今天就先说说这两个吧 ①、关于两栏布局： 两栏布局顾名思义就是主内容分为左右两侧各有一栏。实现两栏布局有很多种办法在这里，我将最常见的几种方法列举出来 方法一：最简单粗暴的方式，百分比这里我就不写出来了，相信大家都会 方法二：BFC方式 &lt;style&gt; #header, #footer{ height: 100px; background: red; } #content .right{ height: 200px; background: green; overflow: auto; } #content .left{ height: 200px; width: 100px; background: blue; float: left; } &lt;/style&gt; right right right right right right 原理：将左侧区域浮动，再讲右侧区域设置auto，形成BFC独立区域，块级上下文 方法三：负边距大法 &lt;style type=&quot;text/css&quot;&gt; html,body{ padding: 0; margin: 0; } #header, #footer{ height: 100px; background: red; overflow: hidden; } #main{ overflow: auto; } #main .center{ height: 200px; width: 100%; float: left; } .center .content{ height: 200px; background: green; margin-right: 100px; } #main .aside{ height: 200px; width: 100px; background: blue; float: left; margin-left: -100px; } &lt;/style&gt; header 我是主区块 我是主区块 main main main footer 当需要自适应的时候 #left { float: left; background-color: red; } #right { overflow: hidden; background-color: blue; } 或者 .left{ position:absolute; // margin-left: -200px; height:400px; width:200px; background-color:blue; } .right{ padding-left:200px; background-color:red; } 再或者 .left-3{ position:relative; padding-right: 200px;//留出右侧内边距 height:300px; background-color:yellow; } .right-3{ position:absolute;//绝对定位到右边 right:0; height:400px; background-color:#808080; } ②、关于三栏布局 三栏布局是在两栏布局的基础上进行的扩展 方法一：绝对定位法 &lt;style type=&quot;text/css&quot;&gt; html，body{ margin:0; height: 100%; } #left，#right{ position: absolute; top: 0; width: 200px; height: 100px; } #left{ left: 0; } #right{ right: 0; } #main{ margin: 0 210px; height: 100%; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt; &lt;/body&gt; ※如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况 方法二：负margin法 &lt;style type=&quot;text/css&quot;&gt; html，body{ margin:0; height: 100%; } #left，#right{ width: 200px; height: 100px; float:left; } #left{ margin-left: -100%; } #right{ margin-right: -200px; } #main,#body{ margin: 0 210px; height:100%; } #main{ width:100%; height: 100%; float:left; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt; &lt;/body&gt; 方法三：浮动 &lt;style type=&quot;text/css&quot;&gt; .left{ float:left; width:100px; height: 30px; background: red; } .right{ float: right; width:150px; height: 30px; background: green; } .center{ background: pink; height: 50px; margin-left: 100px; margin-right: 150px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;left&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;222&lt;/div&gt; &lt;/body&gt;]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见问题]]></title>
    <url>%2F2017%2F11%2F03%2FCSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、清除浮动的几种方式 1、额外标签法 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix{ clear: both; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 2、使用:after 伪元素 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix:after{ /*最简方式*/ content: &apos;&apos;; display: block; clear: both; } /* 新浪使用方式 .clearfix:after{ content: &apos;&apos;; display: block; clear: both; height: 0; visibility: hidden; } */ .clearfix{ /*兼容 IE*/ zoom: 1; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer clearfix&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 3、给父元素定高 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix{ clear: both; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4、利用overflow:hidden;属性 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; overflow: hidden; zoom: 1;/*兼容 IE*/ } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 5、父元素浮动 6、父元素处于绝对定位 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; position: absolute; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 二、小箭头问题 &lt;div id=&quot;demo12&quot;&gt;&lt;/div&gt; &lt;style&gt; #demo12 { border: 10px solid #000; border-left-color: #f00; width: 0; height: 0; } &lt;/style&gt; 即通过调整“边框”厚度可以配置出任意角度 &lt;/div&gt; &lt;style&gt; #demo14 { border: 10px solid transparent; border-left: 20px solid #f00; width: 0; height: 0px; } &lt;/style&gt; 三、rem和em的区别 em是相对于父元素的属性而计算的 Rem是相对于根元素’ ‘ 四、viewport都有什么 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求 五、常见的布局方式有哪些？ 1、零布局 零布局的意思就是几乎完全按照正常文档流的方式来布局，不采用比如float，position，display等css属性。 2、display布局 3、float布局 4、position布局 5、table布局 六、0.5边框问题 1、缩放 .border { position: relative; } .border:after { content: &quot; &quot;; display: block; position: absolute; box-sizing: border-box; left: 0px; top:0px; height: 200%; width: 200%; transform-origin: 0 0; border: 1px solid red; transform: scale(.5); } 2、图片]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常见问题]]></title>
    <url>%2F2017%2F11%2F03%2FHTML%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、行内元素和块级元素的实质上去别 1、行内元素会在一条直线上排列，都是同一行的，水平方向排列 块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。 2、块级元素可以包含行内元素和块级元素。行内元素只能容纳文本或者其他行内元素，除ins和del外，不能包含块状元素。 3、行内元素设置width无效宽度只与内容有关，height无效(可以设置line-height)，margin上下无效，padding上下无效 特别： 1、有几个特殊块级元素只能包含内联元素，不能包含块级元素。这几个特殊标签是 h1~h6、p、dt 2、块级元素与块级元素并列、内联元素与内联元素并列 3、行内替换元素！img、input、textarea、select、object都是替换元素。这些元素往往没有实际的内容，即是一个空元素]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part Two 基础篇]]></title>
    <url>%2F2017%2F11%2F02%2FJS2%2F</url>
    <content type="text"><![CDATA[来来来 看过来。。。。继续挖坑。。。。 16、事件监听 直接上干货 &lt;body&gt; &lt;div id=&quot;clickme&quot;&gt;点我&lt;/div&gt; &lt;div id=&quot;kk&quot; onclick=&quot;handler()&quot;&gt;注册时间&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function handler(){ alert(&apos;aaaa&apos;) } window.onload = function(){ var btn = document.getElementById(&apos;clickme&apos;); btn.addEventListener(&apos;click&apos;,function(){ alert(&quot;dddd&quot;) },false) btn.addEventListener(&apos;click&apos;,function(){ alert(&quot;cccc&quot;) },false) //错误写法，传入的function其实并不是同一个function btn.removeEventListener(&apos;click&apos;,function(){ alert(&apos;nnnn&apos;) }) //改写 function AAA(){ alert(&apos;lllll&apos;) } btn.addEventListener(&apos;click&apos;,AAA,false); btn.removeEventListener(&apos;click&apos;,AAA,false) } &lt;/script&gt; 17、最常见的邮箱正则是什么？ function isAvailableEmail(sEmail) { var reg = /^(\w)+(\.\w+)*@(\w)+((\.\w+))+$/; return reg.test(sEmail); } 18、实现字符串驼峰 function cssStyle2DomStyle(sName) { return sName.replace(/(?!^)\-(\w)(\w+)/g, function(a, b, c){ return b.toUpperCase() + c.toLowerCase(); }).replace(/^\-/, &apos;&apos;); } 19、检查字符串重复数字 function containsRepeatingLetter(str) { return /([a-zA-Z])\1/.test(str); } 当然还有很多很多题目。。。BUT 有些是作为大前端必备的基础 SO 本宝宝会单独列出专题 FOR EXAMPLE 像是继承啦。。。一些基础算法啦。。对象啦等等一系列必备技能 想看的宝宝 阔以去看看专题呦😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part One 基础篇]]></title>
    <url>%2F2017%2F11%2F02%2FJS1%2F</url>
    <content type="text"><![CDATA[啦啦啦啦啦啦。。。。。这可是本仙女呕心沥血总结出的，关于JS面试会问到的一些面试题。。。。。 都是血和泪啊 😢😢😢😢😢😢😢😢😢😢😢😢😢 小伙伴们别在踩坑了 😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭 本章先说一说比较常见的、基础问题问题 🐩 1、什么是事件机制？ 先说说什么是事件流。 事件流：指从页面中接收事件的顺序，有冒泡流和捕获流。 冒泡和捕获 我们点击一个div, 实际上是先点击document，然后点击事件传递到div,而且并不会在这个div就停下， div有子元素就还会向下传递，最后又会冒泡传递回document 为了兼容更多的浏览器，非特殊情况一般我们都是把事件添加到在事件冒泡阶段。 因为冒泡机制，比如既然点击子元素，也会触发父元素的点击事件， 那我们完全可以将子元素的事件要做的事写到父元素的事件里， 也就是将子元素的事件处理程序写到父元素的事件处理程序中，这就是事件委托； 利用事件委托，只指定一个事件处理程序，就可以管理某一个类型的所有事件 2、伪数组转数组 方法一、 声明一个空数组，通过遍历伪数组把它们重新添加到新的数组中，大家都会，这不是面试官要的 var aLi = document.querySelectorAll(‘li’); var arr = []; for (var i = 0; i &lt; aLi.length; i++) { arr[arr.length] = aLi[i] } 方法二、使用数组的slice()方法 它返回的是数组，使用call或者apply指向伪数组 var arr = Array.prototype.slice.call(aLi); 方法3、 ES6中数组的新方法 from() // ES5的写法 var arr1 = [].slice.call(arrayLike) // ES6的写法 let arr2 = Array.from(arrayLike) 3、基本数据类型和引用数据类型区别 基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象 Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的， 因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据：对象类型Object type();Object 、Array 、Function 、Data javascript的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 var obj1 = new Object(); var obj2 = obj1; obj2.name = “我有名字了”; console.log(obj1.name); // 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 Es5的基本数据类型：undefined，null,Object,function,Number,string es6新增的一个数据类型：Symbol 4、实现回文字符串 //判断回文 function isPalindrome(line) { line += “”; return line === line.split(“”).reverse().join(“”); } 这种方法很方便，但效率不高，字符串分割，倒转，聚合都需要很多额外的操作。 function isPalindrome(line) { line += “”; for(var i=0,j=line.length-1;i&lt;j;i++,j–){ if(line.charAt(i) !== line.charAt(j)){ return false; } } return true; } 5、call，apply，bind之间的区别有哪些？ 在说区别之前还是先总结一下三者的相似之处： ① 都是用来改变函数的this对象的指向的。 ② 第一个参数都是this要指向的对象。 ③ 都可以利用后续参数传参。 区别: ① bind不会立即调用，其他两个会立即调用 ② apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）； ③ bind（)也是改变函数体内this的指向; 6、js的节流和去抖 节流：多次反复调用提议行为时 利用settimeout ，在一定时间内 不允许重复执行 消抖：多次反复调用提议行为时 利用settimeout，若在一时间内再次出发相同行为，则将之前行为的定时器去掉 7、settimeout和setInterval javascript都是以单线程的方式运行于浏览器的javascript引擎中的, setTimeout和setInterval的作用只是把你要执行的代码在你设定的一个 时间点插入js引擎维护的一个代码队列中, 插入代码队列并不意味着你的代码就会立马执行的 ① setTimeout function click() { // code block1… setTimeout(function() { // process … }, 200); // code block2 } 假设我们给一个button的onclick事件绑定了此方法, 当我们按下按钮后, 肯定先执行block1的内容, 然后运行到setTimeout的地方, setTimeout会告诉浏览器说, “200ms后我会插一段要执行的代码给你的队列中”, 浏览器当然答应了(注意插入代码并不意味着立马执行), setTimeout代码运行后, 紧跟其后的block2代码开始执行, 这里就开始说明问题了, 如果block2的代码执行时间超过200ms, 那结果会是如何? 或许按照你之前的理解, 会理所当然的认为200ms一到, 你的process代码会立马执行…事实是, 在block2执行过程中(执行了200ms后)process代码被插入代码队列, 但一直要等click方法执行结束, 才会执行process代码段, 从代码队列上看process代码是在click后面的, 再加上js以单线程方式执行, 所以应该不难理解. 如果是另一种情况, block2代码执行的时间&lt;200ms, setTimeout在200ms后将process代码插入到代码队列, 而那时执行线程可能已经处于空闲状态了(idle), 那结果就是200ms后, process代码插入队列就立马执行了, 就让你感觉200ms后, 就执行了. ② setInterval 时间间隔或许会跳过 时间间隔可能&lt;定时调用的代码的执行时间 function click() { // code block1… setInterval(function() { // process … }, 200); // code block2 } 比如onclick要300ms执行完, block1代码执行完, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, click代码顺利结束, process代码开始执行(相当于图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点, 下面问题来, 可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是, 由于代码队列中已经有了一份未执行的process代码, 所以605ms这个插入时间点将会被”无情”的跳过, 因为js引擎只允许有一份未执行的process代码, 说到这里不知道您是不是会豁然开朗呢… 8、解析url中的参数 function getUrlParam(sUrl,sKey){ var result = {}; sUrl.replace(/\??(\w+)=(\w+)&amp;?/g,function(a,k,v){ if(result[k] !== void 0){ var t = result[k]; result[k] = [].concat(t,v); }else{ result[k] = v; } }); if(sKey === void 0){ return result; }else{ return result[sKey] || ‘’; } } 9、JS的组成部分有那些 JavaScript的三大组成部分是: ① ECMAScript：JavaScript的核心，描述了语言的基本语法(var、for、if、array等)和 数据类型(数字、字符串、布尔、函数、对象(obj、[]、{}、null)、未定义)， ECMAScript是一套标准，定义了一种语言（比如JS）是什么样子 ② 文档对象模型（DOM）：DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API），DOM 将把 整个页面规划成由节点层级构成的文档 ③ 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作。 弹出新的浏览器窗口，移动、改变和关闭浏览器窗口， 提供详细的网络浏览器信息（navigator object），详细的页面信 息（location object），详细的用户屏幕分辨率的信息（screen object）， 对cookies的支持等等 10、函数声明方式 //函数声明 function x(){} //函数表达式）： var a = function(){} //构造函数发 var x = new Function(); 函数声明在代码执行以前被加载到作用域中， 函数表达式则是在代码执行到那一行的时候才会有定义 11、Date类型 Date.parse(‘1900-01-19’); // -2207433600000\ // // 创建一个日期对象, var now = new Date(), 新对象自动获得当前时间和对象。 如果想根据指定日期和时间的话，就必须传入该日期的毫秒数(从UTC时间1970年1月1日起)。 Date.parse(‘May 25, 2004’), 转成毫秒数。 (UTC时间) Date.UTC(2005, 4, 5, 17, 55, 55), 转成毫秒数。2005-05-05-17-55-55。(GMT时间) new Date()会模仿上面2种方法，也就是说可以直接向Date()构造函数传入上面两种参数的一种。 但是有一点儿区别，new Date()模仿的时候，都是根据UTC(世界协调时间)时间创建的，而非GMT(格林尼治标准时间)创建。 12、常见状态码的含义 2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 13、http和https ① HTTPS是以安全为目标的HTTP通道，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL ② https具有安全性的ssl加密传输协议需要到ca申请证书，http是超文本传输协议，明文传输 ③ http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443 SSL的位置介于应用层和TCP层之间，应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头 TLS/SSL中使用了非对称加密，对称加密以及HASH算法 14、常见的DOM操作 djsklajldks llllllll //创建节点 var container = document.getElementById("container") var para = document.createElement("p") var text = document.createTextNode("只是创建的节点") var c2 = document.getElementById('child2') para.appendChild(text); container.appendChild(para) //删除 container.removeChild(document.getElementById('child1')) //替换 container.replaceChild(para, c2) //插入 // container.insertBefore(para,c2) //克隆 var x = container.cloneNode() console.log(x) 15、闭包问题 简单来说，就是能访问一个函数内部的函数 上张图片 👇👇👇👇👇 举个🌰 function makeClosures(arr, fn) { var result = []; arr.forEach(function(e){ result.push(function(){ return fn(e) }) }) return result } 再举个🌰 function a() { var arg = []; for(var i = 0;i &lt; 10;i++) { arg[i] = function() { return i; }; } return arg; } a() 1; // 10 啦啦啦啦啦 最近有工作要忙 先到这 BUT 后面还有大批大批的僵尸会袭来呦😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/JS2/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆 觉得小仙女叨叨的还不错的宝宝 可以戳下边打赏哦！☟☟☟☟☟☟☟☟☟☟☟ 么么哒😘]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第三弹]]></title>
    <url>%2F2017%2F11%2F02%2FES6%E7%AC%AC3%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[OK，CONTINUE… 二十一、尾调用 尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function factorial(n, acc = 1) { if (n &lt;= 1) return acc; return factorial(n - 1, n * acc); } console.log(factorial(10)) console.log(factorial(100)) console.log(factorial(1000)) console.log(factorial(10000)) console.log(factorial(100000)) console.log(factorial(1000000)) factorial(10) -&gt; 3628800 factorial(100) -&gt; 9.332621544394418e+157 factorial(1000) -&gt; Infinity factorial(10000) -&gt; Infinity factorial(100000) -&gt; RangeError: Maximum call stack size exceeded factorial(1000000) -&gt; RangeError: Maximum call stack size exceeded 二十二、扩展 ➕ 对象字面量 let {x,y,…z} = {x:1,y:2,a:3,b:4} console.log(x);//1 console.log(y);//2 console.log(z);//{ a: 3, b: 4 } let n = {x,y,…z}; console.log(n)//{ x: 1, y: 2, a: 3, b: 4 } console.log(obj） 二十三、故障弱化解构 var [a] = [] var [b = 1] = [] var c = [] console.log(a) console.log(b) console.log(c) a -&gt; undefined b -&gt; 1 c -&gt; [] function f(x,y=12){ return x + y } console.log(f(3)) console.log(f(3,2)) f(3) -&gt; 15 f(3,2) -&gt; 5 function f(x,y,z){ return x + y + z; } // 传递数组的每个元素作为参数 console.log(f(…[1,2,3])) f(…[1,2,3]) -&gt; 6 function f([x,y,z]){ return x + y + z; } // 传递数组的每个元素作为参数 console.log(f([1,2,3])) f([1,2,3]) -&gt; 6 var parts = [“shoulders”,”knees”]; var lyric = [“head”,…parts,”and”,”toes”]; console.log(lyric) lyrics -&gt; [“head”,”shoulders”,”knees”,”and”,”toes”] 二十四、代理 代理可以用来改变对象的行为。 它们允许我们定义 trap var obj = function ProfanityGenerator(){ return { word:”111111112222” } }() var handler = function CensoringHandler(){ return { get:function(target,key){ return target[key].replace(“11111111”,”3333”) } } }() var proxy = new Proxy(obj, handler); console.log(proxy.words); proxy.words -&gt; 33332222 var handler = { get:…, set:…, has:…, deleteProperty:…, apply:…, construct:…, getOwnPropertyDescriptor:…, defineProperty:…, getPrototypeOf:…, setPrototypeOf:…, enumerate:…, ownKeys:…, preventExtensions:…, isExtensible:… } 二十五、反射 新类型的元编程与新的API现有的还有一些新的方法。 var z = {w: “Super Hello”} var y = {x: “hello”, proto: z}; console.log(Reflect.getOwnPropertyDescriptor(y, “x”)); console.log(Reflect.has(y, “w”)); console.log(Reflect.ownKeys(y, “w”)); console.log(Reflect.has(y, “x”)); console.log(Reflect.deleteProperty(y,”x”)) console.log(Reflect.has(y, “x”)); Reflect.getOwnPropertyDescriptor(y, “x”) -&gt; {“value”:”hello”,”writable”:true,”enumerable”:true,”configurable”:true} Reflect.has(y, “w”) -&gt; true Reflect.ownKeys(y, “w”) -&gt; [“x”] Reflect.has(y, “x”) -&gt; true Reflect.deleteProperty(y,”x”) -&gt; true Reflect.has(y, “x”) -&gt; false 二十六、可继承内置函数 我们现在可以继承原生类。 class CustomArray extends Array{ } var a = new CustomArray(); a[0] = 2 console.log(a[0]) a[0] -&gt; 2 //不能使用数组的代理(Proxy)来覆盖getter函数。 二十七、新类库 console.log(Number.EPSILON) console.log(Number.isInteger(Infinity)) console.log(Number.isNaN(“NaN”)) console.log(Math.acosh(3)) console.log(Math.hypot(3, 4)) console.log(Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2)) console.log(“abcde”.includes(“cd”) ) console.log(“abc”.repeat(3) ) console.log(Array.of(1, 2, 3) ) console.log([0, 0, 0].fill(7, 1) ) console.log([1, 2, 3].find(x =&gt; x == 3) ) console.log([1, 2, 3].findIndex(x =&gt; x == 2)) console.log([1, 2, 3, 4, 5].copyWithin(3, 0)) console.log([“a”, “b”, “c”].entries() ) console.log([“a”, “b”, “c”].keys() ) console.log([“a”, “b”, “c”].values() ) console.log(Object.assign({}, { origin: new Point(0,0) })) Number.EPSILON -&gt; 2.220446049250313e-16 Number.isInteger(Infinity) -&gt; false Number.isNaN(“NaN”) -&gt; false Math.acosh(3) -&gt; 1.7627471740390859 Math.hypot(3, 4) -&gt; 5 Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) -&gt; 2 “abcde”.includes(“cd”) -&gt; true “abc”.repeat(3) -&gt; abcabcabc Array.of(1, 2, 3) -&gt; [1,2,3] [0, 0, 0].fill(7, 1) -&gt; [0,7,7] [1, 2, 3].find(x =&gt; x == 3) -&gt; 3 [1, 2, 3].findIndex(x =&gt; x == 2) -&gt; 1 [1, 2, 3, 4, 5].copyWithin(3, 0) -&gt; [1,2,3,1,2] [“a”, “b”, “c”].entries() -&gt; {} [“a”, “b”, “c”].keys() -&gt; {} [“a”, “b”, “c”].values() -&gt; TypeError: [“a”,”b”,”c”].values is not a function Object.assign({}, { origin: new Point(0,0) }) -&gt; ReferenceError: Point is not define 二十八、Reflect Reflect对象的设计目的有这样几个。 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上 修改某些Object方法的返回结果，让其变得更合理 让Object操作都变成函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法 Reflect对象一共有13个静态方法。 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的 Reflect.get(target, name, receiver) Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, } Reflect.get(myObject, ‘foo’) // 1 Reflect.get(myObject, ‘bar’) // 2 Reflect.get(myObject, ‘baz’) // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, }; var myReceiverObject = { foo: 4, bar: 4, }; Reflect.get(myObject, ‘baz’, myReceiverObject) // 8 如果第一个参数不是对象，Reflect.get方法会报错 Reflect.get(1, ‘foo’) // 报错 Reflect.get(false, ‘foo’) // 报错 Reflect.set(target, name, value, receiver) Reflect.set方法设置target对象的name属性等于value。 var myObject = { foo: 1, set bar(value) { return this.foo = value; }, } myObject.foo // 1 Reflect.set(myObject, ‘foo’, 2); myObject.foo // 2 Reflect.set(myObject, ‘bar’, 3) myObject.foo // 3]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第二弹]]></title>
    <url>%2F2017%2F11%2F02%2FES6%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[吼吼，来吧，小宝贝，废话不多说，咱们书接上回。。。。 十一、Prosmises 异步编程 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 Promise对象有以下两个特点: （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 （2）Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） var promise = new Promise(function(resolve, reject) { // … some code if (/ 异步操作成功 /){ resolve(value); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved） } else { reject(error); reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected } }); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用 第二个回调函数是Promise对象的状态变为rejected时调用。 来个 🌰 吼吼 👇 var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;resolve(“1”),101) }) var p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(“2”), 100) }) Promise.race([p1, p2]).then((res) =&gt; { console.log(res) }) Promise.all([p1, p2]).then((res) =&gt; { console.log(res) }) res -&gt; 2 res -&gt; [“1”,”2”] var p1 = Promise.resolve(“1”) var p2 = Promise.reject(“2”) Promise.race([p1, p2]).then((res) =&gt; { console.log(res) }) ※※※※ ➡️ 如果一个 promise 失败，all和race也将 reject(拒绝)。 让我们举个 🌰 ，come on 👇 var p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(“1”), 1001) }) var p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(“2”), 1) }) Promise.race([p1, p2]).then((res) =&gt; { console.log(“success” + res) }, res =&gt; { console.log(“error “ + res) }) Promise.all([p1, p2]).then((res) =&gt; { console.log(“success” + res) }, res =&gt; { console.log(“error “ + res) }) “error “ + res -&gt; error 2 “error “ + res -&gt; error 2 Promise也有一些缺点。首先，无法取消Promise， Promise 新建后就会立即执行 ###################################################### 十二、Symbol 话不多说，直接上干货 var typeSymbol = Symbol(“type”); var typeSymbol = Symbol(“type”); class Pet{ constructor(type){ this[typeSymbol] = type } getType(){ return this[typeSymbol] } } var a = new Pet(“dog”); console.log(a.getType()); console.log(Object.getOwnPropertyNames(a)) console.log(Symbol(“a”) === Symbol(“a”)) a.getType() -&gt; dog Object.getOwnPropertyNames(a) -&gt; [] Symbol(“a”) === Symbol(“a”) -&gt; false ###################################################### 十三、Unicode var regex = new RegExp(‘\u{61}’,’u’) console.log(regex.unicode) console.log(“\uD842\uDFD7”) console.log(“\uD842\uDFD7”.codePointAt()) ###################################################### 十四、箭头函数 var evens = [2, 4, 6, 8, 10, 12, 14]; var odds = evens.map(v =&gt; v + 1) var nums = events.map((v,i) =&gt; v + i) var pairs = events.map(v =&gt; ({even: v,odd:v + 1})) 0:{even: 2, odd: 3} 1:{even: 4, odd: 5} 2:{even: 6, odd: 7} 3:{even: 8, odd: 9} 4:{even: 10, odd: 11} 5:{even: 12, odd: 13} 6:{even: 14, odd: 15} nums.forEach(v =&gt; { if(v%5 === 0) fives.push(v) }) 啰嗦一句，请注意箭头函数中的this！！！！！！！！神坑啊 嵌套的箭头函数怎么办，箭头函数内部，还可以再使用箭头函数 let insertn = (v) = &gt; ({intro:(arr)=&gt;({obj:(o)=&gt; { arr.splice(array.indexOf(o)+1,0,v); return arr; } })}) //部署管道机制，即前一个函数的输出是后一个函数的输入。 const pip = (…fn) =&gt; val =&gt;fn.reduce((a,b)=&gt;b(a),val); const p1 = a =&gt;a+1 const p2 = a =&gt;a*2 const add = pip(p1,p2) add(5); ###################################################### 十五、解构 var [a,,b] = [1,2,3]; console.log(a); console.log(b); a -&gt; 1 b -&gt; 3 nodes = () =&gt;{ return {op:’a’,lhs:’b’,rhs:’c’} } var { op:a,lhs:b,rhs:c } = nodes() conosle.log(a); console.log(b); console.log(c); a -&gt; a b -&gt; b c -&gt; c nodes = () =&gt; { return {lhs: “a”, op: “b”, rhs: “c”}} // binds op, lhs and rhs in scope var {op, lhs, rhs} = nodes() console.log(op) console.log(lhs) console.log(rhs) op -&gt; b lhs -&gt; a rhs -&gt; c unction g({name:x}){ return x; } function m({name}){ return name } console.log(g({name:5})) console.log(m({name:5})) g({name: 5}) -&gt; 5 m({name: 5}) -&gt; 5 ###################################################### 十六、模块和模块加载器 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 eg: import { stat, exists, readFile } from ‘fs’; 上面代码的实质是从fs模块加载3个方法，其他方法不加载 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 重要的事情说三遍！！！！！！ 严格模式主要有以下限制: 1、变量必须声明后再使用 2、函数的参数不能有同名属性，否则报错 3、不能使用with语句 4、不能对只读属性赋值，否则报错 5、不能使用前缀0表示八进制数，否则报错 6、不能删除不可删除的属性，否则报错 7、不能删除变量delete prop，会报错，只能删除属性delete global[prop] 8、eval不会在它的外层作用域引入变量 9、eval和arguments不能被重新赋值 10、arguments不会自动反映函数参数的变化 11、不能使用arguments.callee 12、不能使用arguments.caller 13、禁止this指向全局对象 14、不能使用fn.caller和fn.arguments获取函数调用的堆栈 15、增加了保留字（比如protected、static和interface） 上个 🌰 import {firstName, lastName, year} from ‘./profile’; //import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略 function setName(element) { element.textContent = firstName + ‘ ‘ + lastName; } 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surname } from ‘./profile’; 警报警报 一大波 僵尸袭来 ~~ import defaultMember from “module-name”; import as name from “module-name”; import { member } from “module-name”; import { member as alias } from “module-name”; import { member1 , member2 } from “module-name”; import { member1 , member2 as alias2 , […] } from “module-name”; import defaultMember, { member [ , […] ] } from “module-name”; import defaultMember, as name from “module-name”; import “module-name”; 再来说说export这个小妖精 export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能 export var firstName = ‘Michael’; export var lastName = ‘Jackson’; export var year = 1958; // profile.js var firstName = ‘Michael’; var lastName = ‘Jackson’; var year = 1958; export {firstName, lastName, year}; 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名 function v1() { … } function v2() { … } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; 重命名后，v2可以用不同的名字输出两次 哇呕 ~~~~有一大波僵尸正在狂奔而来！！！！！ export { name1, name2, …, nameN }; export { variable1 as name1, variable2 as name2, …, nameN }; export let name1, name2, …, nameN; // also var export let name1 = …, name2 = …, …, nameN; // also var, const export expression; export default expression; export default function (…) { … } // also class, function export default function name1(…) { … } // also class, function export { name1 as default, … }; export * from …; export { name1, name2, …, nameN } from …; export { import1 as name1, import2 as name} ###################################################### 十七、生成器 生成器创建迭代器，并且比迭代器更具动态性 先来一堆代码 var initinity = { [Symbol.iterator]:function*(){ var c = 1; for(;;){ yield c++; } } } console.log(“start”) for(var n of infinity){ if(n&gt;10) break; console.log(n) } “start” -&gt; start n -&gt; 1 n -&gt; 2 n -&gt; 3 n -&gt; 4 n -&gt; 5 n -&gt; 6 n -&gt; 7 n -&gt; 8 n -&gt; 9 n -&gt; 10 interface Generator extends Iterator { next(value?: any): IteratorResult; throw(exception: any); } function* anotherGenerator(i) { yield i + 1; yield i + 2; yield i + 3; } function generator(i) { yield i; yield anotherGenerator(i); yield i + 10; } var gen = generator(10); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); gen.next().value -&gt; 10 gen.next().value -&gt; 11 gen.next().value -&gt; 12 gen.next().value -&gt; 13 gen.next().value -&gt; 20 function* list(value) { for (var item of value) { yield item; } } for (var value of list([1, 2, 3])) { console.log(value); } var iterator = list([1, 2, 3]); console.log(typeof iterator.next); // function console.log(typeof iterator[Symbol.iterator]); // function console.log(iterator.next().value); // 1 for (var value of iterator) { console.log(value); // 2, 3 } table[Symbol.iterator] = function* () { var keys = Object.keys(this).sort(); for (var item of keys) { yield item; } } 执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态 形式上，Generator 函数是一个普通函数，但是有两个特征 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式，定义不同的内部状态 function* helloWorldGenerator() { yield ‘hello’; yield ‘world’; return ‘ending’; } 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。 不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果， 而是一个指向内部状态的指针对象 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态 也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行， 直到遇到下一个yield表达式（或return语句）为止 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记， 而next方法可以恢复执行 hw.next() // { value: ‘hello’, done: false } hw.next() // { value: ‘world’, done: false } hw.next() // { value: ‘ending’, done: true } hw.next() // { value: undefined, done: true } yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态， 所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 ###################################################### 十八、迭代器 迭代器是一个比数组更动态的类型 允许我们在语言层面上定义一个（有限或无限的）序列。 对于for-in循环，它有许多的问题。但是最大的问题，便是它不保证迭代的顺序。 但是当我们使用ES6迭代器时，这个问题就迎刃而解了。 let infinite = { Symbol.iterator{ let c = 0; return { next(){ c++; return { done:false,value:c } } } } } console.log(“start”) for(var n of infinite){ if(n &gt; 10) break; console.log(n); } “start” -&gt; start n -&gt; 1 n -&gt; 2 n -&gt; 3 n -&gt; 4 n -&gt; 5 n -&gt; 6 n -&gt; 7 n -&gt; 8 n -&gt; 9 n -&gt; 10 //使用Typescript，我们可以看到它接口的样子 interface IteratorResult { done:boolean; value:any; } interface Iterator{ next():IteratorResult; } interface Iterable{ Symbol.iterator:Iterator } 使用for-of，我们得到的是一个可以保证顺序的迭代。 为了让一个对象可以被迭代器所迭代，对象需要实现一个“迭代协议”，即拥有一个Symbol.iterator属性。 这个属性会被for-of所使用，在我们的例子中，它就是table[Symbol.iterator]。 Symbol.iterator只需认为它是对象的一个特殊属性，并且永远不会和其他普通属性产生冲突 table[Symbol.iterator]的值，必须是一个符合“迭代协议”的函数， 即它需要返回一个类似于{ next: function () {} }的对象。 table[Symbol.iterator] = function () { return { next: function () {} } } 然后，在for-of循环每次调用next()函数时， 它需要返回一个类似于{value: …, done: [true/false]}的对象。 所以，一个迭代器的完整实现类似于如下的例子： table[Symbol.iterator] = function () { var keys = Object.keys(this).sort(); var index = 0; return { next: function () { return { value: keys[index], done: index++ &gt;= keys.length }; } } } 惰性执行 迭代器允许我们在第一次调用next()函数之后，再执行相应的逻辑。 在上面的例子里，当我们调用迭代器的瞬间，我们就立刻执行了排序和取值的工作。 但是，如果next()函数永远不被调用的话，我们就浪费了性能。所以让我们来优化它： table[Symbol.iterator] = function () { var _this = this; var keys = null; var index = 0; return { next: function () { if (keys === null) { keys = Object.keys(_this).sort(); } return { value: keys[index], done: index++ &gt;= keys.length }; } } } String，Array，TypedArray，Map和Set都是内置迭代器，因为它们的原型中都有一个Symbol.iterator方法 只要永远不返回done: true，就实现了一个无限迭代器。当然，需要极力避免出现这种情况。 var ids = { *[Symbol.iterator]: function () { var index = 0; return { next: function () { return { value: &apos;id-&apos; + index++, done: false }; } }; } }; var counter = 0; for (var value of ids) { console.log(value); if (counter++ &gt; 1000) { // let’s make sure we get out! break; } } ###################################################### 十九、增强对象字面量 var theProtoObj = { toString:function(){ return “the ProtoObject to string” } } var handler = () =&gt; “handler” var obj = { proto:theProtoObj, handler, toString(){ return “d “+super.toString(); }, [&quot;prop_&quot; + (() =&gt; 42)()]:42 } console.log(obj.handler) console.log(obj.handler()) console.log(obj.toString()) console.log(obj.prop_42) ###################################################### 二十、字符串插值 var name = “Bob”,time = “today”; var multiLine = `This Line Spans Multiple Line` console.log( Hello ${name},how are you ${time}?); console.log(multiLine) Hello ${name},how are you ${time}? -&gt; Hello Bob,how are you today? multiLine -&gt; This Line Spans Multiple Lines 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/ES6%E7%AC%AC3%E5%BC%B9/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第一弹]]></title>
    <url>%2F2017%2F11%2F01%2FES6%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ps：这是本宝宝搜罗N多个人的博客、资料最后的大汇总，如有雷同也是正常现象 pps：各位大大们请不要在意这些细节喽，宽容点噻。 ppps：由于本仙女实在是太懒了，so，嘿嘿!就只挑重点记录喽，please 不要喷我。。。 一、Let { var globalVar = “from demo1” } { let globalLet = “from demo2” } console.log(globalVar) console.log(globalLet) globalVar -&gt; from demo1 globalLet -&gt; ReferenceError: globalLet is not defined 它不会向window分配任何内容： let me = “go” var i = “able” console.log(window.me) console.log(window.i) window.me -&gt; undefined window.i -&gt; able 不能使用let重新声明一个变量： let me = “foo”; let me = “bar”; console.log(me); SyntaxError: Identifier ‘me’ has already been declared ######################################################## 二、Const 一个不能被更改的值 const a = “b” a = “a” TypeError: Assignment to constant variable. 应该注意，const 对象仍然可以被改变的。 const a = { a: “a” } a.a = “b” console.log(a) a -&gt; {“a”:”b”} ######################################################## 三、Class类 class ColorPoint extends Point { } // 等同于 class ColorPoint extends Point { constructor(…args) { super(…args); } } 举个🌰 吧 class Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 } } let cp = new ColorPoint(25, 8, ‘green’); //上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例 cp instanceof ColorPoint // true cp instanceof Point // true 再举个🌰 class A { static hello() { console.log(‘hello world’); } } class B extends A { } B.hello() // hello world //hello()是A类的静态方法，B继承A，也继承了A的静态方法 还想再来个🌰 class A { constructor() { console.log(new.target.name); //new.target指向当前正在执行的函数 } } class B extends A { constructor() { super(); } } new A() // A new B() // B 小可爱们看过来吖，看过来👀 class Student { // 构造函数 // 只能声明一个，否则会报以下错误(Safari 10.0)： // SyntaxError: Cannot declare multiple constructors in a single class. constructor(name, age) { // 类成员变量不用事先声明 this.name = name; this.age = age; if (age === undefined) { log(&apos;没有传age参数&apos;); } } // 方法 sayHello(message) { // this不能省略 log(&quot;Hello &quot; + this.name + &quot;: &quot; + message); } sayHelloEx(message) { log(&quot;Hello &quot; + this.name + &apos;[&apos; + this.age + &apos;]: &apos; + message); } } class SkinnedMesh extends THREES.Mesh { constructor(geometry,materials){ super(geometry,materials);// 调用父类的constructor //子类必须在constructor方法中调用super方法，否则新建实例时会报错 //这是因为子类没有自己的this对象，而是继承父类的this对象 this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.bonesMatrices = [] //在子类的构造函数中，只有调用super之后，才可以使用this关键字 } //constructor方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 update(camera){ super.update() } get boneCount(){ return this.bones.length } set MatrixType(matrixType){ this.idMatrix = SkinnedMesh matrixType; } static defaultMatrix(){ return new THREES.Matrix4(); } } ######################################################## 四、For…of 迭代器的新类型，可以替代for..in。 它返回的是值而不是keys let list = [4, 5, 6]; console.log(list) for (let i of list) { console.log(i); } list -&gt; [4,5,6] i -&gt; 4 i -&gt; 5 i -&gt; 6 没有对比就没有伤害，看这里👇 for(let i in list){ console.log(i) } list -&gt; [4,5,6] i -&gt; 0 i -&gt; 1 i -&gt; 2 ######################################################## 五、Set Set 为数学对应，其中所有项目都是唯一的 var set = new Set(); set.add(“Potato”).add(“Tomato”).add(“Tomato”) console.log(set.size) console.log(set.has(“Tomato”)) for(var item of set) { console.log(item) } set.size -&gt; 2 set.has(“Tomato”) -&gt; true item -&gt; Potato item -&gt; Tomato ######################################################## 六、Rest 我们可以使用 rest 操作符来允许无限参数 rest … function demo(part1,…part2){ return {part1,part2} } console.log(demo(1,2,3,4,6)) demo(1,2,3,4,5,6) -&gt; {“part1”:1,”part2”:[2,3,4,5,6]} ######################################################## 七、Map var map = new Map(); map.set(“Potato”,12) map.set(“Tomato”,34) console.log(map.get(“Potato”)) for(let item of map){ console.log(item) } map.get(“Potato”) -&gt; 12 item -&gt; [“Potato”,12] item -&gt; [“Tomato”,34] for(let item in map){ console.log(item) } //undefined 可以使用除字符串之外的其他类型。 var map = new Map(); var key = {a: “a”} map.set(key, 12); console.log(map.get(key)) console.log(map.get({a: “a”})) map.get(key) -&gt; 12 map.get({a: “a”}) -&gt; undefined ######################################################## 八、WeakMap 使用键的对象，并且只保留对键的弱引用。 var wm = new WeakMap(); var o1 = {} var o2 = {} var o3 = {} wm.set(o1,1) wm.set(o2,2) wm.set(o3,{a:”a”}) wm.set({},4) console.log(wm.get(o2)) console.log(wm.has({})) delete o2; console.log(wm.get(o3)) for(let item in wm) { console.log(item) } for(let item of wm) { console.log(item) } 接下来让我们来看一下输出的结果吧 wm.get(o2) -&gt; 2 wm.has({}) -&gt; false wm.get(o3) -&gt; {“a”:”a”} 没有size属性,没有办法遍历它的成员 TypeError: wm[Symbol.iterator] is not a function surprise！！！🎉 有没有很惊喜吖 是不是和想的不一样捏 吼吼 稳住 我们能赢 让我们趁热打铁，来迎接下一个暴击 ######################################################## 九、WeakSet 也是不重复的值的集合 WeakSet 的成员只能是对象 WeakSet对象允许您在集合中存储弱持有的对象,没有引用的对象将被垃圾回收 var item = {a:”Potato”} var set new WeakSet(); set.add({a:”Potato”}).add(item).add({a:”Tomato”}).add({a:”Tomato”}) console.log(set.size) console.log(set.has({a:”Tomato”})) console.log(set.has(item)) for(let item of set) { console.log(item) } ※※※ ➡ WeakSet没有size属性,没有办法遍历它的成员 接下来让我们再来看一下输出的结果吧！！！！ set.size -&gt; undefined set.has({a:”Tomato”}) -&gt; false set.has(item) -&gt; true TypeError: set[Symbol.iterator] is not a function 号外号外 📢 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} 注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象 ######################################################## 十、关于This var object = { name:”Name”, arrowGetName:() =&gt; this.name, regularGetName:function(){ return this.name }, arrowGetThis:() =&gt; this, regularGetThis:function(){ return this } } console.log(object.arrowGetName()) console.log((object.arrowGetThis()) console.log(this) console.log(object.regularGetName()) console.log(object.regularGetThis()) object.arrowGetName() -&gt; object.arrowGetThis() -&gt; [object Window] this -&gt; [object Window] object.regularGetName() -&gt; Name object.regularGetThis() -&gt; {“name”:”Name”} 小葵花妈妈课堂开课了，小仙女感冒老不好，多半是废了。。。。。。。。 各位道友们，咱们下一章见。。。咳咳。。。小仙女要去吃药了 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/ES6%E7%AC%AC%E4%BA%8C%E5%BC%B9/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This Is the Beginning of the Story]]></title>
    <url>%2F2017%2F11%2F01%2FWebsite%2F</url>
    <content type="text"><![CDATA[忘了是什么时间，忘了在什么地点，只记得有人写过这样的话。。。 我走过山的时候，山不说话 我路过海的时候，海不说话 我坐着的毛驴一步一步滴滴答答 我带着的倚天喑哑 大家说我因为爱着杨过大侠 找不到 所以在峨眉安家 其实我只是喜欢峨眉的雾 像十六岁那年绽放的烟花 我路过海的时候，海不说话 我走过山的时候也听不到回答 我骑的毛驴 步步滴滴答答 悠悠飘向远处可从不想要回家 正当喜乐无忧年 韶华如花 远游风尘之色却不似十九风华 –程灵素]]></content>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
        <tag>ES6</tag>
        <tag>JQ</tag>
        <tag>HTML</tag>
        <tag>JS</tag>
        <tag>H5</tag>
        <tag>NODEJS</tag>
        <tag>WEBPACK</tag>
        <tag>WEBFRAME</tag>
        <tag>PIT</tag>
        <tag>ARTICAL</tag>
        <tag>LIFE</tag>
        <tag>SENTIMENTS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Photoes]]></title>
    <url>%2Fphotoes%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
