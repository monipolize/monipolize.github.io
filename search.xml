<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise真是个磨人的小妖精]]></title>
    <url>%2F2017%2F12%2F05%2FPromise%E7%9C%9F%E6%98%AF%E4%B8%AA%E7%A3%A8%E4%BA%BA%E7%9A%84%E5%B0%8F%E5%A6%96%E7%B2%BE%2F</url>
    <content type="text"><![CDATA[最近小仙女中了一种毒，一种叫做”异步时序“的毒，为了解这种毒小仙女掉进了”回调地狱“ 举个🌰 我们所操作的数据往往是通过向后端大大请求而得来的，BUT有时候会出现这样一种情况，由于所有数据都是异步请求的得来的，没个请求的返回时间不一样，所以会出现有相关依赖，或者说递进关系的数据会有问题，所以为了解决问题，我往往会在一个请求成功之后，再去发送另一个请求，BUT 恐怖的事情粗线了，经常或有这样的代码： 👇 $.ajax({ url: ‘……’, success: function (data) { $.ajax({ // 要在第一个请求成功后才可以执行下一步 url: ‘……’, success: function (data) { $.ajax({ // 要在第一个请求成功后才可以执行下一步 url: ‘……’, success: function (data) { // …… } }); } }); } }); 这简直是HELL 突然有天 Promise这个小妖精粗线了 什么事promise那? 一个 Promise 对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了 Promise对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。而且由于 Promise.all 这样的方法存在，可以让同时执行多个操作变得简单。接下来就来简单介绍 Promise 对象。 Promise 的三种状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态 举个 🌰 function helloWorld (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(“Hello World!”); } else { reject(“Good bye!”); } }); } helloWorld(true).then(function (message) { alert(message); }, function (error) { alert(error); }); resolve 方法可以使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。 reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 then 第一个参数是成功执行，第二个参数是失败执行 下面例子通过链式调用的方式，按顺序打印出了相应的内容。then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象 function printHello (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(“Hello”); } else { reject(“Good bye!”); } }); } function printWorld () { alert(“World”); } function printExclamation () { alert(“!”); } printHello(true) .then(function(message){ alert(message); }) .then(printWorld) .then(printExclamation); printHello(true).then(function (message) { return message; }).then(function (message) { return message + ‘ World’; }).then(function (message) { return message + ‘!’; }).then(function (message) { alert(message); }); catch catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。 .catch()的作用是捕获Promise的错误，与then()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获then()中抛出的错误，所以建议不要使用then()的rejected回调，而是统一使用catch()来处理错误 注意:当catch函数里没有抛出新的error时，promise认为错误已经被解决。 Promise.all 和 Promise.race Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。但只要有一个变成rejected状态，promise就会立刻变成rejected状态 var p1 = new Promise(function (resolve) { setTimeout(function () { resolve(“Hello”); }, 3000); }); var p2 = new Promise(function (resolve) { setTimeout(function () { resolve(“World”); }, 1000); }); Promise.all([p1, p2]).then(function (result) { console.log(result); // [“Hello”, “World”] }); 虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。 日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。 Promise.race 接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。promise就会立刻变成相同的状态并执行对于的回调 Promise.done() / Promise. finally() Promise.done() 的用法类似 .then() ，可以提供resolved和rejected方法，也可以不提供任何参数，它的主要作用是在回调链的尾端捕捉前面没有被 .catch() 捕捉到的错误 Promise. finally() 接受一个方法作为参数，这个方法不管promise最终的状态是怎样，都一定会被执行]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS和AMD和CMD]]></title>
    <url>%2F2017%2F12%2F04%2FcommonJS%E5%92%8CAMD%E5%92%8CCMD%2F</url>
    <content type="text"><![CDATA[先说说模块化，为什么要有模块化那，回想起最开始没有接触过模块化的日子，简直。。。。就不多说了，大家都懂。 模块化，从名字上来看，就是分块的意思，将大家写的veryvery长的代码，veryvery复杂的代码合理的分割成几个“快状”，这样不仅增加了清晰度，而且更利于与多人合作。 在JS中模块化规范有三种：CommonJS和AMD和CMD CommonJs 用在服务器端，AMD和CMD用在浏览器环境 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行（异步加载：依赖先执行）+延迟执行 CMD 是延迟执行（运行到需加载，根据顺序执行） 为什么同样是模块化却要区分针对服务器端和浏览器端那？ —————————-服务器端JS | 浏览器端JS————————— 相同的代码需要多次执行 | 代码需要从一个服务器端分发到多个客户端执行 CPU和内存资源是瓶颈 | 带宽是瓶颈 加载时从磁盘中加载 | 加载时需要通过网络加载 一、CommonJS CommonJS就是为JS的表现来制定规范，Commonjs是一个更偏向于服务器端的规范，NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作 在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个模块A.js，就可以像下面这样加载。 var A = require(‘A’); A.xxxx(); 再看一个了例子： exports.B = function B(){} var b = require(‘B’) exports.C = function C(){ return b()} CommonJS定义的模块分为:模块引用(require)、模块定义(exports)、模块标识(module) require()用来引入外部模块； exports对象用于导出当前模块的方法或变量，唯一的导出口； module对象就代表模块本身。 Node内部提供一个Module构建函数。所有模块都是Module的实例。 function Module(id, parent) { this.id = id; this.exports = {}; this.parent = parent; … } module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 Node为每个模块提供一个exports变量，指向module.exports exports.A = function (r) { return a; }; exports.B= function (r) { return b; }; 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 exports = function(x) {console.log(x)}; 上面这样的写法是无效的，因为exports不再指向module.exports了 exports.hello = function() { return ‘hello’; }; module.exports = ‘Hello world’; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了 规范：一个单独的文件就是一个模块。每一个模块都有自己单独的作用域，在本模块定义额变量或函数如果不导出，其他模块无法使用but如果你定义为global对象，那就可以使用啦。commonjs输出变量一般是使用module.exports,引用一个模块一般用require 看上面的例子，可以看出来requir其实是同步读取其他模块的内容，并编译执行，最后得到对应的模块接口。but在浏览器中会有问题，因为js脚本是异步的，CommonJS 模块在浏览器环境中无法正常加载。那怎么办呐？ 解决办法一: 使用服务器端组件，将模块化的代码进行处理，将每个模块和他所对应的依赖一起加载，但是这种方式导致你不得不 调整你的架构，so 宝宝不喜欢 解决办法二:也是本宝宝喜欢的 用标准模板来封装 模板：define(function(require, exports, module) {});这个模板可以在模块执行前对其进行分析，并将这个模块中 的所有依赖生成一张列表 看个 🌰 👇 A.JS define(function(require,exports,module){ exports.A = function(){ var s = 0; return s++ } }) B.JS define(function(require,exports,module){ var a = require(‘A’).A; exports.B = function(){ return s+”hahha” } }) C.JS define(function(require,exports,module){ var b = require(‘B’).B b(); }) 二、AMD AMD是”Asynchronous Module Definition”的缩写，JS原生不支持，所以使用AMD的时候需要对应的库，也就是RequireJS它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 当多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器的时候AMD是很好的选择。js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。由于AMD是异步方式所以也可以解决这个问题。 AMD规范使用define方法定义模块，下面就是一个例子： define([‘package/lib’], function(lib){ function foo(){ lib.log(‘hello world!’); } return { foo: foo }; }); AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： define(function (require, exports, module){ var someModule = require(“someModule”); var anotherModule = require(“anotherModule”); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function (){ someModule.doTehAwesome(); anotherModule.doMoarAwesome(); }; }); requireJS也是采用require()语句加载模块，但是他只有两个参数分别是module数组和callback require([module], callback); module数组:里面的成员就是要加载的模块 callback:加载成功之后的回调函数 看个 🌰 👇 require([B], function (b) { b.B(); }); RequireJS定义了一个函数 define，它是全局变量，用来定义模块:define(id?, dependencies?, factory); id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 看个 🌰 👇 define(“C”, [“require”, “exports”, “B”], function (require, exports, B) { exports.b = function() { return B.b(); } }); 既然AMD是依赖于RequireJs，那么我们先来看一下requireJS A.js requirejs.config({ paths: { jquery: ‘jquery.min’ //可以省略.js } }); //引入模块，用变量$表示jquery模块 requirejs([‘jquery’], function ($) { $(‘body’).css(‘background-color’,’red’); }); 引入模块也可以只写require() 在此模块内的方法和变量外部是无法访问的，只有通过return返回才行. define(‘B’,[‘jquery’], function ($) {//引入jQuery模块 return { b: function(x,y){ return x + y; } }; }); 将该模块命名为B.js保存。 require([‘jquery’,’B’], function ($,B) { console.log(B.b(10,100));//110 }); 三、CMD CMD是Common Module Definition的简写。CMD是国内发展的，他依赖于seaJS。seaJS和requireJS干的事情一模一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。 规范：一个模块就是一个文件 define(function(require, exports, module) { // 模块代码 }); require:把其他模块导入进来 exports:把模块内的一些属性和方法导出的 module :是一个对象，上面存储了与当前模块相关联的一些属性和方法 AMD是依赖关系前置,在定义模块的时候就要声明其依赖的模块; CMD是按需加载依赖就近,只有在用到某个模块的时候再去require： CMD define(function(require, exports, module) { var a = require(‘./a’) a.doSomething() var b = require(‘./b’) // 依赖可以就近书写 b.doSomething() }) AMD define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() … }) 总结: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作 AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs. CommonJs主要针对服务端，AMD/CMD主要针对浏览器端 AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。 AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。 AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。 CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。 CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。 使用CommonJs的话，因为nodeJs就是它的实现，所以使用node就行，也不用引入其他包。AMD则是通过 script标签引入RequireJs.CMD则是引入SeaJs。 理论说了这么多，现在每一个都举一个例子吧 CommonJS ：每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 // A.js var x = 5; var addX = function (value) { return value + x; }; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 global.warning = true; 但是不推荐这么做 ommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 var x = 5; var addX = function (value) { return value + x; }; module.exports.x = x; module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 var a = require(‘./A.js’); console.log(a.x); // 5 console.log(a.addX(1)); // 6]]></content>
      <categories>
        <category>FRAME</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>JS</tag>
        <tag>FRAME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue自定义指令]]></title>
    <url>%2F2017%2F11%2F28%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、自定义指令 -1.1 自定义全局指令 Vue.directive(指令id，指令定义对象) &lt;div v-hello v-text=&quot;msg&quot;&gt; &lt;/div&gt; Vue.directive(&apos;hello&apos;,{ //钩子函数 bind(){ //指令第一次绑定时调用，只执行一次，可执行初始化操作 }, inserted(){ //当指令所绑定的元素,插入到dom中调用 }, update(){ //当指令所绑定的元素所在模板更新时调用 }, componentUpdated(){ //当指令所绑定的元素所在模板完后一次更新周期时 }, unbind(){ //指令解除绑定时调用 } }) Vue.directive(&apos;world&apos;,{ bind(el,binding){ alert(1111) //el 指令所绑定的元素 el.style.color = &apos;red&apos; } }) //简化写法 Vue.directive(&apos;world&apos;,function(){ //这个函数会被bind和update调用 }) var vm = new Vue({ el:&apos;main&apos; data:{ msg:&apos;qqqq&apos; } }) -1.2 自定义局部指令 var vm = new Vue({ el:&apos;main&apos; data:{ msg:&apos;qqqq&apos; }, directive:{ hello:function(el){ el.style.color = red; }, world：{ inserted:function(el){ el.focus() } } } }) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自定义指令练习&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #main div{ width:100px; height: 200px; position:absolute; } .hello{ background:red; top: 0; left:0; } .world{ background:red; top: 0; right:0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;hello&quot; v-drag&gt;1111&lt;/div&gt; &lt;div class=&quot;world&quot; v-drag&gt;2222&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.directive(&apos;drag&apos;,function(el){ el.onmousedown = function(e){ //获取鼠标点击的位置，与div左边和上边的位置 var disx = e.clientX - el.offsetLeft var disy = e.clientY - el.offsetTop document.onmousemove = function(e){ //获取移动后div的位置，鼠标的位置减去dis var left = e.clientX - disx; var top = e.clientY - disy el.style.left = left+&apos;px&apos; el.style.top = top+&apos;px&apos; } //停止移动 document.onmouseup = function(){ document.onmousemove = null document.onmouseup = null } } }) var vm = new Vue({ el:&apos;main&apos;, data:{ }, methods:{ } }) &lt;/script&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios]]></title>
    <url>%2F2017%2F11%2F28%2Faxios%2F</url>
    <content type="text"><![CDATA[VUE本身不支持AJAX请求，需要使用vue-resource、axios等插件实现 axios是一个基于Promoise的一盒HTTP请求客户端，用来发送请求，返回的是一个promise对象，也是vue2.0官方推荐 不支持跨域 参考：GITHUB上搜索axios，查看API 1、使用axios发送ajax请求 -1.1安装axios，并引入 npm install axios -S -1.2基本用法 axios({}) axios.get(url,{}) //传参方式 1.url 2.params axios.post(url,{}) //传参方式 axios发送数据时候，默认数据格式request payload ，并非常用formdata格式，所以参数必须要以键值对的方式 1.自己拼接键值对 2.使用transformRequest，在请求发送前将请求数据转换 3.如果使用模块开发，可以用qs模块进行转换 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;axios&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/axios.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;main&apos;&gt; &lt;button @click=&quot;send&quot;&gt;&lt;/button&gt; &lt;button @click=&quot;sendGet&quot;&gt;&lt;/button&gt; &lt;button @click=&quot;sendPost&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function(){ new Vue({ el:&apos;main&apos;, methods:{ send(){ axios({ method:&apos;get&apos;, url:&apos;./01.json&apos;, data:{ &apos;xx&apos;:xx } }).then(function(rs){ console.log(rs.data) }).catch(rs =&gt; { console.log(&apos;请求失败：&apos;+rs) }) }, sendGet(){ axios.get(&apos;server.php？name=tom&amp;age=23&apos;) .then(rs=&gt;{ console.log(rs.data) }).catch(err=&gt;{ console.log(err) }) axios.get(&apos;server.php&apos;,{ params:{ name:&apos;tom&apos;, age:19 } }) .then(rs=&gt;{ console.log(rs.data) }).catch(err=&gt;{ console.log(err) }) }, sendPost(){ axios.post(&apos;server.php&apos;,&apos;name=tom&amp;age=29&apos;) .then(rs=&gt;{ console.log(rs.data) }).catch(err=&gt;{ console.log(err) }) ###################################################################### axios.post(&apos;server.php&apos;,{ name:&apos;tom&apos;, age:19 },{ transformRequest:[ function(data){ let params=&apos;&apos; for(let index in data){ params+=index+&apos;=&apos;+data[index]+&apos;&amp;&apos; } return params; } ] }) .then(rs=&gt;{ console.log(rs.data) }).catch(err=&gt;{ console.log(err) }) } } }) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2、发送跨域请求，使用vue-resourse -2.1 使用vue-resourse npm install vue-resourse -2.2 使用this.$http this.$http.get() this.$http.post() this.$http.delete() this.$http.put() &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;跨域请求&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-resourse.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button @click=&quot;sendJsonp&quot;&gt;发送跨域请求&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function(){ new Vue({ el:&apos;main&apos;, methods:{ sendJsonp(){ this.$http.get(&apos;&apos;,) this.$http.post(&apos;&apos;,) this.$http.jsonp(&apos;https://sug.so.360.cn/suggest&apos;,{ params:{ word:&quot;a&quot; }, jsonp:&apos;cb&apos;//修改callback名称 }).then(rs=&gt;{ console.log(rs.data.s) }) } } }) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是虚拟DOM以及VUE的虚拟DOM]]></title>
    <url>%2F2017%2F11%2F27%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈VUE-ROUTER]]></title>
    <url>%2F2017%2F11%2F27%2FVUEROUTER%2F</url>
    <content type="text"><![CDATA[单页面应用：根据不同的url，显示不同内容，但显示在同一个页面中 例子： https://github.com/monipolize/vueRouter [参考]（ https://router.vuejs.org/zh-cn） bower info vue-router cnpm install vue-router –s ###基本用法 -1、对页面布局 -2、配置路由 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;路由的基本用法&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* .router-link-active{ font-size: 20px; color:orange; text-decoration: none; } */ .active{ font-size: 20px; color:orange; text-decoration: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div&gt; &lt;!--router-link组件定义导航 to属性定义url --&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; &lt;router-link to=&quot;/new&quot;&gt;新闻&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;!-- router-view 用来显示路由内容--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; //1.定义相应的组件 var home = { template:&quot;&lt;h3&gt;我是主页&lt;/h3&gt;&quot; } var news = { template:&quot;&lt;h3&gt;我是新闻&lt;/h3&gt;&quot; } //2，配置路由 const myroutes = [ {path:&apos;/home&apos;,component:home}, {path:&apos;/news&apos;,component:news}, {path:&apos;*&apos;,redirect:&apos;/home&apos;} ] //3.创建路由实例 const router = new VueRouter({ routes:myroutes, mode:&apos;history&apos;, linkActiveClass:&apos;active&apos;//更改活动连接class类名 }); //4.创建VUE，并将路由挂载（注入路由） new Vue({ el:&apos;#main&apos;, router//相当于router：router }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ###路由嵌套和参数传递 传参的两种方式： 1、查询字符串：login？name=tom&amp;pwd=123 2、rest风格：login/tom/123 ###路由实例的方法 router.push() 添加路由，功能上与router-link相同 router.replace() 替换路由，没有历史记录 ###路由结合动画 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;路由的嵌套，参数传递&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/animate.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; /* .router-link-active{ font-size: 20px; color:orange; text-decoration: none; } */ .active{ font-size: 20px; color:orange; text-decoration: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div&gt; &lt;!--router-link组件定义导航 to属性定义url --&gt; &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; &lt;router-link to=&quot;/user&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;!-- router-view 用来显示路由内容--&gt; &lt;transition enter-active-class=&quot;animated bounceInLeft&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;br /&gt; &lt;button @click=&quot;push&quot;&gt;添加路由&lt;/button&gt; &lt;button @click=&quot;replace&quot;&gt;替换路由&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;template id=&quot;user&quot;&gt; &lt;div&gt; &lt;h3&gt;用户信息&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;router-link to=&quot;/user/login?name=tom&amp;pwd=123&quot;&gt;登录&lt;/router-link&gt; &lt;/li&gt; &lt;li&gt; &lt;router-link to=&quot;/user/reg/john/123&quot;&gt;注册&lt;router-link&gt; &lt;/li&gt; &lt;!-- //转换 --&gt; &lt;router-link to=&quot;/user/reg&quot; tag=&quot;li&quot;&gt;注册&lt;router-link&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- router-view 用来显示路由内容--&gt; &lt;transition enter-active-class=&quot;animated bounceInLeft&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/template&gt; &lt;script&gt; //1.定义相应的组件 var home = { template:&quot;&lt;h3&gt;我是主页{{$route.path}}&lt;/h3&gt;&quot; } var User = { template:&quot;#user&quot; } var login = { template:&quot;&lt;h3&gt;用户登录:获取参数：{{$route.query}},{{$route.query.name}},{{$route.query.pwd}}&lt;/h3&gt;&quot; } var reg = { template:&quot;&lt;h3&gt;用户注册:获取参数：{{$route.params.name}}&lt;/h3&gt;&gt;&quot; } //2，配置路由 const myroutes = [ { path:&apos;/home&apos;, component:home }, { path:&apos;/user&apos;, component:user, //子路由 children:[ { path:&apos;login&apos;, component:login }, { path:&apos;reg/:name/:pwd&apos;, component:reg } ] }, { path:&apos;*&apos;, redirect:&apos;/home&apos; } ] //3.创建路由实例 const router = new VueRouter({ routes:myroutes, mode:&apos;history&apos;, linkActiveClass:&apos;active&apos;//更改活动连接class类名 }); //4.创建VUE，并将路由挂载（注入路由） new Vue({ el:&apos;#main&apos;, router,//相当于router：router methods:{ push(){//切换路由 router.push({path:&apos;home&apos;}); }, replace(){ router.replace({path:&apos;user&apos;}); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CANVAS]]></title>
    <url>%2F2017%2F11%2F22%2FCANVAS%2F</url>
    <content type="text"><![CDATA[理解： 是一个可以使用脚本(通常为JavaScript)在其中绘制图形的 HTML 元素 元素不被一些老的浏览器所支持，但是所有的主流浏览器的新近版本都支持 入门用法： 在页面中添加canvas元素， canvas看起来和img元素很相像，唯一的不同就是它并没有src和alt 属性。实际上， canvas标签只有两个属性—— width和height.默认初始化宽度为300像素和高度为150像素 某些较老的浏览器（尤其是IE9之前的IE浏览器）或者文本浏览器不支持HTML元素”canvas”，在这些浏览器上你应该总是能展示替代内容。 举个 🌰 &lt;canvas id=&quot;stockGraph&quot; width=&quot;150&quot; height=&quot;150&quot;&gt; current stock price: $3.15 +0.15 &lt;/canvas&gt; &lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt; &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot;/&gt; &lt;/canvas&gt; 渲染上下文:canvas元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能 var canvas = document.getElementById(&apos;tutorial&apos;); var ctx = canvas.getContext(&apos;2d&apos;); 检查支持性: var canvas = document.getElementById(‘tutorial’); if (canvas.getContext){ var ctx = canvas.getContext(‘2d’); // drawing code here } else { // canvas-unsupported code here } 来个基本的 🌰 &lt;html&gt; &lt;head&gt; &lt;script type=&quot;application/javascript&quot;&gt; function draw() { var canvas = document.getElementById(&quot;canvas&quot;); if (canvas.getContext) { var ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;rgb(200,0,0)&quot;; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = &quot;rgba(0, 0, 200, 0.5)&quot;; ctx.fillRect (30, 30, 55, 50); } } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;draw();&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;/html&gt; 绘制 矩形 canvas提供了三种方法绘制矩形：fillRect(x, y, width, height)绘制一个填充的矩形 strokeRect(x, y, width, height)绘制一个矩形的边框 clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明 （x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。） 路径 形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的 步骤：首先，你需要创建路径起始点。然后你使用画图命令去画出路径。之后你把路径封闭。一旦路径生成，你就能通过描边或填 充路径区域来渲染图形。 beginPath() 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath() 闭合路径之后图形绘制命令又重新指向到上下文中。 stroke() 通过线条来绘制图形轮廓。 fill() 通过填充路径的内容区域生成实心的图形。 举个 🌰 function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext){ var ctx = canvas.getContext(&apos;2d&apos;); ctx.beginPath(); ctx.moveTo(75,50); ctx.lineTo(100,75); ctx.lineTo(100,25); ctx.fill(); } } 移动笔触：moveTo(x, y) 将笔触移动到指定的坐标x以及y上。 当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径 来个 🌰 function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext){ var ctx = canvas.getContext(&apos;2d&apos;); ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制 ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // 口(顺时针) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); } } 线: 直线:lineTo(x, y) 绘制一条从当前位置到指定x以及y位置的直线。 function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext){ var ctx = canvas.getContext(&apos;2d&apos;); // 填充三角形 ctx.beginPath(); ctx.moveTo(25,25); ctx.lineTo(105,25); ctx.lineTo(25,105); ctx.fill(); // 描边三角形 ctx.beginPath(); ctx.moveTo(125,125); ctx.lineTo(125,45); ctx.lineTo(45,125); ctx.closePath(); ctx.stroke(); } } 你会注意到填充与描边三角形步骤有所不同。正如上面所提到的，因为路径使用填充（filled）时，路径自动闭合使用描边（stroked）则不会闭合路径。如果没有添加闭合路径closePath()到描述三角形函数中，则只绘制了两条线段 ，并不是一个完整的三角形. 圆弧:绘制圆弧或者圆，我们使用arc()方法 arc(x, y, radius, startAngle, endAngle, anticlockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时 针方向。 arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。 看个 🌰 function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext){ var ctx = canvas.getContext(&apos;2d&apos;); for(var i=0;i&lt;4;i++){ for(var j=0;j&lt;3;j++){ ctx.beginPath(); var x = 25+j*50; // x 坐标值 var y = 25+i*50; // y 坐标值 var radius = 20; // 圆弧半径 var startAngle = 0; // 开始点 var endAngle = Math.PI+(Math.PI*j)/2; // 结束点 var anticlockwise = i%2==0 ? false : true; // 顺时针或逆时针 ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); if (i&gt;1){ ctx.fill(); } else { ctx.stroke(); } } } } } 二次贝塞尔曲线及三次贝塞尔曲线： quadraticCurveTo(cp1x, cp1y, x, y) 绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 来个例子： function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext) { var ctx = canvas.getContext(&apos;2d&apos;); // 二次贝尔赛曲线 ctx.beginPath(); ctx.moveTo(75,25); ctx.quadraticCurveTo(25,25,25,62.5); ctx.quadraticCurveTo(25,100,50,100); ctx.quadraticCurveTo(50,120,30,125); ctx.quadraticCurveTo(60,120,65,100); ctx.quadraticCurveTo(125,100,125,62.5); ctx.quadraticCurveTo(125,25,75,25); ctx.stroke(); } } function draw() { var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext){ var ctx = canvas.getContext(&apos;2d&apos;); //三次贝塞尔曲线 ctx.beginPath(); ctx.moveTo(75,40); ctx.bezierCurveTo(75,37,70,25,50,25); ctx.bezierCurveTo(20,25,20,62.5,20,62.5); ctx.bezierCurveTo(20,80,40,102,75,120); ctx.bezierCurveTo(110,102,130,80,130,62.5); ctx.bezierCurveTo(130,62.5,130,25,100,25); ctx.bezierCurveTo(85,25,75,37,75,40); ctx.fill(); } } 矩形：rect(x, y, width, height) 绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。 当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0） 参考： https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes ；]]></content>
      <categories>
        <category>绘图类</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>绘图类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端问题总结]]></title>
    <url>%2F2017%2F11%2F22%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、先来说说touch事件与点击穿透问题 touch事件的来源：PC网页上，响应的是鼠标事件，包括mousedown、mouseup、mousemove和click事件 。可被拆解成：mousedown -&gt; click -&gt; mouseup三步。手机上没有鼠标，所以就用触 摸事件去实现类似的功能。touch事件包含touchstart、touchmove、touchend.手指触发触摸事件的过程为：touchstart -&gt; touchmove -&gt; touchend。在手机上，当我们手触碰屏幕时，要过300ms左右才会触发mousedown事件 所以click事件在手机上看起来就像慢半拍一样。手机上响应 click 事件会有300ms的延迟 touch事件中可以获取以下参数:touches 屏幕中每根手指信息列表 targetTouches 和touches类似，把同一节点的手指信息过滤掉 changedTouches 响应当前事件的每根手指的信息列表 在说一说tap：PC页面绑定click，相应地手机页面就绑定tap 但原生的touch事件本身是没有tap的，js库里提供的tap事件都是模拟出来的 浏览器在 touchend 后会等待约300ms，原因是判断用户是否有双击（double tap）行为。如果没有 tap 行为，则触发 click 事件，而双击过程中就不适合触发 click 事件了。由此可以看出 click 事件触发代表一轮触摸事件的结束。 点击穿透问题：我们先看个 🌰 &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;underLayer&quot;&gt;底层元素&lt;/div&gt; &lt;div id=&quot;popupLayer&quot;&gt; &lt;div class=&quot;layer-title&quot;&gt;弹出层&lt;/div&gt; &lt;div class=&quot;layer-action&quot;&gt; &lt;button class=&quot;btn&quot; id=&quot;closePopup&quot;&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;bgMask&quot;&gt;&lt;/div&gt; 然后为底层元素绑定 click 事件，而弹出层的关闭按钮绑定 tap 事件。 $(‘#closePopup’).on(‘tap’, function(e){ $(‘#popupLayer’).hide(); $(‘#bgMask’).hide(); }); $(&apos;#underLayer&apos;).on(&apos;click&apos;, function(){ alert(&apos;underLayer clicked&apos;); }); 点击关闭按钮，touchend首先触发tap，弹出层和遮罩就被隐藏了。touchend后继续等待300ms发现没有其他行为了，则继续触发click，由于这时弹出层已经消失，所以当前click事件的target就在底层元素上，于是就alert内容。整个事件触发过程为 touchend -&gt; tap -&gt; click。由于click事件的滞后性（300ms），在这300ms内上层元素隐藏或消失了，下层同样位置的DOM元素触发了click事件（如果是input框则会触发focus事件），看起来就像点击的target“穿透”到下层去 解决点击穿透问题： 方法一：遮挡 由于 click 事件的滞后性，在这段时间内原来点击的元素消失了，于是便“穿透”了。因此我们顺着这个思路就想到， 可以给元素的消失做一个fade效果，类似jQuery里的fadeOut，并设置动画duration大于300ms，这样当延迟的 click 触发时，就不会“穿透”到下方的元素了。不用延时动画，我们还可以动态地在触摸位置生成一个透明的元素，这样当上层元素消失而延迟的click来到时，它点击到的是那个透明的元素，也不会“穿透”到底下。在一定的timeout后再将生成的透明元素移除 方法二： pointer-events pointer-events是CSS3中的属性，它有很多取值，有用的主要是auto和none $(&apos;#closePopup&apos;).on(&apos;tap&apos;, function(e){ $(&apos;#popupLayer&apos;).hide(); $(&apos;#bgMask&apos;).hide(); $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;none&apos;); setTimeout(function(){ $(&apos;#underLayer&apos;).css(&apos;pointer-events&apos;, &apos;auto&apos;); }, 400); }); 方法三：fastclick 使用fastclick库，其实现思路是，取消 click 事件，用 touchend 模拟快速点击行为 FastClick.attach(document.body);]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUEX的几个步骤]]></title>
    <url>%2F2017%2F11%2F20%2FVUEX%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[例子： https://github.com/monipolize/vuex 简单来说，用来集中管理数据，类似于React中的Redux，都是基于FLUX的前端状态管理框架 流程图 vue组件 -&gt; 发出动作 -&gt; action -&gt;提交改变 -&gt;mutation发生改变 -&gt; state -&gt; 更新组建 ###1、简介 ###2.基本用法 ####2.1 安装 cnpm install vuex -S ####2.2 创建store文件，在入口文件导入,并配置store选项 ####2.3 编辑store VUEX的核心就是store，相当于一个容器，一个store中包含几个属性 1.state 定义属性（状态数据） 2.getters 用来获取属性的 3.actions 定义方法（动作） 4.commit 提交变化 5.mutations 定义变化 注意：不要直接在action中修改数据，而是提交变化，目的是为了追踪数据变化 ####2.4 编辑App.vue 在子组件中，访问store对象的两种方式 方式1：通过this.$store.state.count 方式2：通过负主函数mapGetters，mapActions，mapState访问 mapGetters： 获取属性 mapActions： 获取方法 mapState: 或取的数据 ###3 更好的组织项目结构 建议：store -&gt;index.js组装模块的地方+actions.js+mutations.js+mymodules |-src |-store |-index.js |-getters.js |-actions.js |-mutation.js |-modules//分为多个模块，每个模块都可以拥有自己的state，getters,actiobs,mutations |-user.js |-cart.js |-....]]></content>
      <categories>
        <category>VUEX</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE必须知道的几个问题]]></title>
    <url>%2F2017%2F11%2F17%2FVUE%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、active-class是哪个组件的属性？嵌套路由怎么定义？ 答：vue-router模块的router-link组件。 2、怎么定义vue-router的动态路由？怎么获取传过来的动态参数？ 答：在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id 3、vue-router有哪几种导航钩子？ 答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件 4、scss是什么？安装使用的步骤是？有哪几大特性？ 答：预处理css，把css当前函数编写，定义变量,嵌套。 先装css-loader、node-loader、sass-loader等加载器模块，在webpack-base.config.js配置文件中加多一个拓展:extenstion，再加多一个模块：module里面test、loader 4.1、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？ 答：css的预编译。 使用步骤： 第一步：用npm 下三个loader（sass-loader、css-loader、node-sass） 第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss 第三步：还是在同一个文件，配置一个module属性 第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss” 有哪几大特性: 1、可以用变量，例如（$变量名称=值）； 2、可以用混合器，例如（） 3、可以嵌套 5、mint-ui是什么？怎么使用？说出至少三个组件使用方法？ 答：基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper 6、v-model是什么？怎么使用？ vue中标签怎么绑定事件？ 答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件： 7、axios是什么？怎么使用？描述使用它实现登录功能的流程？ 答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中 8、axios+tp5进阶中，调用axios.post(‘api/user’)是进行的什么操作？axios.put(‘api/user/8′)呢？ 答：跨域，添加用户操作，更新操作。 9、什么是RESTful API？怎么使用? 答：是一个api的标准，无状态请求。请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好。标准有：.post .put .delete 10、vuex是什么？怎么使用？哪种功能场景使用它？ 答：vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车 11、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？ 答：一个model+view+viewModel框架，数据模型model，viewModel连接两个 区别：vue数据驱动，通过数据来显示视图层而不是节点操作。 场景：数据操作比较多的场景，更加便捷 12、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？ 答：全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives 钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新） 钩子函数参数：el、binding 13、说出至少4种vue当中的指令和它的用法？ 答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定 14、vue-router是什么？它有哪些组件？ 答：vue用来写路由一个插件。router-link、router-view 15、导航钩子有哪些？它们有哪些参数？ 答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave 参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种 16、Vue的双向数据绑定原理是什么？ 答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 ps：16题答案同样适合”vue data是怎么实现的？”此面试题。 17、请详细说下你对vue生命周期的理解？ 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 18、请说下封装 vue 组件的过程？ 答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。 19、你是怎么认识vuex的？ 答：vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。 通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。 应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 20、vue-loader是什么？使用它的用途有哪些？ 答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。 用途：js可以写es6、style样式可以scss或less、template可以加jade等 21、请说出vue.cli项目中src目录每个文件夹和文件的用法？ 答：assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件 22、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？ 答：第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default { 第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’ 第三步：注入到vue的子组件的components属性上面,components:{smithButton} 第四步：在template视图view中使用， 问题有：smithButton命名，使用的时候则smith-button。 23、聊聊你对Vue.js的template编译的理解？ 答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点） 详情步骤： 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUEX摘要]]></title>
    <url>%2F2017%2F11%2F17%2FVUEX%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[参考博客： https://segmentfault.com/a/1190000007516967 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 我们先来看一个 🌰 new Vue({ // state data () { return { count: 0 } }, // view template: ` &lt;div&gt;{{ count }}&lt;/div&gt; `, // actions methods: { increment () { this.count++ } } }) 这个状态自管理应用包含以下几个部分：state，驱动应用的数据源；view，以声明方式将 state 映射到视图；actions，响应在 view 上的用户输入导致的状态变化。 state -&gt; view -&gt; actions -&gt; state 核心：每一个 Vuex 应用的核心就是 store（仓库） Vuex 和单纯的全局对象有以下两点不同：① Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化， 那么相应的组件也会相应地得到高效更新 ② 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation 注意:通过提交 mutation 的方式，而非直接改变 store.state.count,可以更明确地追踪到状态的变化 看个例子：安装Vuex之后，来创建一个 store。创建过程直截了当——仅需要提供一个初始state对象和一些 mutation // 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：👇 store.commit(‘increment’) console.log(store.state.count) // -&gt; 1 看个完整的吧 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ count }}&lt;/p&gt; &lt;p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment: state =&gt; state.count++, decrement: state =&gt; state.count-- } }) new Vue({ el: &apos;#app&apos;, computed: { count () { return store.state.count } }, methods: { increment () { store.commit(&apos;increment&apos;) }, decrement () { store.commit(&apos;decrement&apos;) } } }) 看到这 大家应该有了基本了解吧，其实就是相当于 将所有状态放到一个BUS中，通过触发methods中 对应的方法，触发状态的改变，再根据计算属性的特质实现实时更新。 下面让我们聊一聊具体的核心概念吧 1、state：单一状态树 Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。作为一个“唯一数据源 (SSOT)”而存在 那么如何在组件中获得vuex状态那？ 由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态 // 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return store.state.count } } } 上面例子中的模式导致组件依赖全局状态单例 Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)） const app = new Vue({ el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` }) //子组件能通过 this.$store 访问到 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return this.$store.state.count } } } mapState：辅助函数 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键 // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from &apos;vuex&apos; export default { // ... computed: mapState({ // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } 对象展开运算符 computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ // ... }) } 2、getter 有时候我们需要从 store 中的 state 中派生出一些状态 computed: { doneTodosCount () { return this.$store.state.todos.filter(todo =&gt; todo.done).length } } 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。Vuex 允许我们在 store 中定义“getter”。就像计算属性一样，getter 的返回值会根据它的依赖 被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &apos;...&apos;, done: true }, { id: 2, text: &apos;...&apos;, done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } } //store.getters.doneTodos // -&gt; [{ id: 1, text: &apos;...&apos;, done: true }] }) Getter 也可以接受其他 getter 作为第二个参数： getters: { // … doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length } } store.getters.doneTodosCount // -&gt; 1 computed: { doneTodosCount () { return this.$store.getters.doneTodosCount } } mapGetters：辅助函数 import { mapGetters } from &apos;vuex&apos; export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) } } 如果你想将一个 getter 属性另取一个名字，使用对象形式： mapGetters({ // 映射 this.doneCount 为 store.getters.doneTodosCount doneCount: ‘doneTodosCount’ }) 3、Mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } } 要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： store.commit(‘increment’) 提交载荷（Payload）：你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload） mutations: { increment (state, n) { state.count += n } } store.commit(‘increment’, 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： // … mutations: { increment (state, payload) { state.count += payload.amount } } store.commit(‘increment’, { amount: 10 }) 对象风格的提交方式，整个对象都作为载荷传给mutation函数 store.commit({ type: ‘increment’, amount: 10 }) Mutation 需遵守 Vue 的响应规则:① 提前在你的 store 中初始化好所有所需属性 ② 当需要在对象上添加新属性时，Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象,state.obj = { …state.obj, newProp: 123 } 使用常量替代 Mutation 事件类型 // mutation-types.js export const SOME_MUTATION = ‘SOME_MUTATION’ // store.js import Vuex from ‘vuex’ import { SOME_MUTATION } from ‘./mutation-types’ const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) 4、action const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters } } }) 分发Action:通过 store.dispatch 方法触发 store.dispatch(‘increment’) // 以载荷形式分发 store.dispatch(‘incrementAsync’, { amount: 10 }) // 以对象形式分发 store.dispatch({ type: ‘incrementAsync’, amount: 10 }) 在组件中分发 Action import { mapActions } from ‘vuex’ export default { // … methods: { …mapActions([ ‘increment’, // 将 this.increment() 映射为 this.$store.dispatch(&#39;increment&#39;) // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions({ add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` }) } } 5、module vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态 模块的局部状态 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象 const moduleA = { state: { count: 0 }, mutations: { increment (state) { // 这里的 state 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } } } 项目结构 遵守的规则：应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。]]></content>
      <categories>
        <category>VUEX</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>VUEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学Bootstrap]]></title>
    <url>%2F2017%2F11%2F16%2F%E9%87%8D%E5%AD%A6Bootstrap%2F</url>
    <content type="text"><![CDATA[下载地址: http://getbootstrap.com/docs/4.0/getting-started/download/ bootstrap是一个响应式CSS框架 1、入门demo &lt;!DOCTYPE html&gt; bootstrap起步 hello world 你会看到左上角有一个hello world 绿色按钮，说明你已经成功调用bootstrap。你并不需要写style样式只需要在html标签写一些class，因为一切样式都写在bootstrap(.min).css文件里面等着你去调用 2、bootstrap响应式栅栏 原理:CSS3的@media查询 //@media查询设备的一个固定用法，后面一般接all（所有设备）或者screen（电脑屏幕，平板电脑，智能手机等），后面的and可以增加一下判断的条件 先看一个媒体查询的例子 👇 &lt;!DOCTYPE html&gt; 响应式原理 /div的公用样式/div { height: 50px; } /当屏幕宽度最大值不能超过400px/@media all and (max-width: 400px) { div { width: 100%; background-color: red; } } /当屏幕宽度在400px~700px之间/@media all and (min-width: 400px) and (max-width: 700px) { div { width: 50%; background-color: yellow; } } /当屏幕宽度不小于700px/@media all and (min-width: 700px) { div { width: 20%; background-color: blue; } } 真正栅栏 👇 &lt;!DOCTYPE html&gt; https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; bootstrap起步 模块1 模块2 “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列 ※※※用 这是列（column）表示,里面的xx可以填xs,sm,md,lg。分别对应上图表中屏幕尺寸 3、看文档吧 css预览： ① Bootstrap 使用了一些 HTML5 元素和 CSS 属性。为了让这些正常工作，您需要使用 HTML5 文档类型（Doctype）。 因此，请在使用 Bootstrap 项目的开头包含下面的代码段&lt;!DOCTYPE html&gt; ② 移动设备优先是 Bootstrap 3 的最显著的变化，为了让 Bootstrap 开发的网站对移动设备友好，确保适当的绘制和触屏缩放，需要在网页的 head 之中添加 viewport meta 标签，如下 ③ 响应式图片 .img-responsive { //设置 height:auto，相关元素的高度取决于浏览器。 //设置 max-width 为 100% 会重写任何通过 width 属性指定的宽度 display: block; height: auto; max-width: 100%; } ④ 基本的全局显示 Bootstrap 3 使用 body {margin: 0;} 来移除 body 的边距。 ⑤ 排版 使用 @font-family-base、 @font-size-base 和 @line-height-base 属性作为排版样式 ⑥ 链接样式 通过属性 @link-color 设置全局链接的颜色。 ⑦ 容器 .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } Chrome Firefox IE Opera Safari Android YES YES 不适用 不适用 不适用 iOS YES 不适用 不适用 不适用 YES Mac OS X YES YES 不适用 YES YES Windows YES YES YES* YES 不适用 网格系统 原理：网格系统通过一系列包含内容的行和列来创建页面布局。下面列出 了 Bootstrap 网格系统是如何工作的： 行必须放置在 .container class内，以便获得适当的对齐（alignment）和内边距（padding）。使用行来创建列的水平组。 内容应该放置在列内，且唯有列可以是行的直接子元素。预定义的网格类. 比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows上的外边距（margin） 取负，表示第一列和最后一列的行偏移。 媒体查询: / 超小设备（手机，小于 768px） / / Bootstrap 中默认情况下没有媒体查询 / / 小型设备（平板电脑，768px 起） / @media (min-width: @screen-sm-min) { … } / 中型设备（台式电脑，992px 起） / @media (min-width: @screen-md-min) { … } / 大型设备（大台式电脑，1200px 起） / @media (min-width: @screen-lg-min) { … } @media (max-width: @screen-xs-max) { ... } @media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... } @media (min-width: @screen-md-min) and (max-width: @screen-md-max) { ... } @media (min-width: @screen-lg-min) { ... } 具体例子 ➡️ 看这里： （demo6，demo7，demo8） 响应式的列重置 &lt;!DOCTYPE html&gt; Bootstrap 实例 - 响应式的列重置 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot; &gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8; box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &lt;/p&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;clearfix visible-xs&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8; box-shadow:inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6 col-sm-3&quot; style=&quot;background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>BOOTSTRAAP</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>BOOTSTRAAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS必须知道的几件事]]></title>
    <url>%2F2017%2F11%2F15%2FJS%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[一、JS的几种设计模式 1、工厂模式 理解：向工厂一样批量生产。解决多个相似的问题，解决多个类似对象声明的问题;解决实列化对象产生重复的问题 🌰 👇 function Person(name,age,sex){ var obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function(){ return this.name } return obj; } var p1 = new Person(&quot;yan&quot;,&quot;22&quot;,&quot;男&quot;); var p2 = new Person(&quot;haha&quot;,&quot;22&quot;,&quot;女&quot;); console.log(typeof p1); // object console.log(typeof p2); // object console.log(p1 instanceof Object); // true 优点:解决多个相似的问题。 缺点:对象的类型不知道 再举一个复杂的 🌰 var Person = function(name){ this.name = name; this.method = function(){ return this.name } } Person.prototype = { constructor:Person, buy:function(sex){ var p1 = this.createPerson(sex) p1.boy(); p1.girl(); return p1 }, createPerson:function(sex){ throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;) } } // 实现原型继承 function extend(sub,sup){ //Sub表示子类，Sup表示超类 var F = function(){}; // 设置空函数的原型为超类的原型 F.prototype = sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) { // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; } } var Child = function(name){ this.name = name; Person.call(this,name) } // 子类继承父类原型方法 extend(Child,Person) // Child 子类重写父类的方法 Child.prototype.createPerson = function(){ var A = function(){ console.log(&quot;AAAA&quot;); }; var B = function(){ console.log(&quot;BBBBB&quot;); }; return { A: A, B: B } } var childClass = new Child(&quot;妮妮&quot;); console.log(childClass); 2、单体模式 理解:将代码组织为一个逻辑单元。用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。 优点:以用来划分命名空间，减少全局变量的数量。可以被实例化，且实例化一次。 🌰 👇 var Person = { name:&quot;haha&quot;, age:&quot;12&quot;, method1:function(){ return this.name }, method2：function(){ return this.age } } 上面的只是不能被实例化的一个类，因此不是单体模式 改造一下吧 👇 var Person = function(name){ this.name = name; } Person.prototype.getName = function(){ return this.name; } function getInstance(name){ var instance = null; if(!instance){ instance = new Person(name) } return instance; } var a = getInstance(&quot;aa&quot;) var b = getInstance(&quot;bb&quot;); // 因为单体模式是只实例化一次，所以下面的实例是相等的 由于单体模式只实例化一次，因此第一次调用，返回的是a实例对象，当我们继续调用的时候，b的实例就是a的实例 console.log(a === b); // true console.log(a.getName());// aa console.log(b.getName());// aa 3、理解模块模式 理解：单体模式添加私有变量和私有方法能够减少全局变量的使用 var singleMode = (function(){ // 创建私有变量 var privateNum = 112; function privateFunc(){ // 实现自己的业务逻辑代码 } return { publicMethod1: publicMethod1, publicMethod2: publicMethod1 }; })() 来个 🌰 function CustomType() { this.name = “tugenhua”; }; CustomType.prototype.getName = function(){ return this.name; } var application = (function(){ // 定义私有 var privateA = “aa”; // 定义私有函数 function A(){}; // 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 var object = new CustomType(); // 添加公有属性 object.A = &quot;aa&quot;; // 添加公有方法 object.B = function(){ return privateA; } // 返回该对象 return object; })(); console.log(application.A);// aa console.log(application.B()); // aa console.log(application.name); // tugenhua console.log(application.getName());// tugenhua 4、代理模式 理解:代理是一个对象，它可以用来控制对本体对象的访问，它与本体对象实现了同样的接口，代理对象会把所有的调用方法传递给本体对象的 5、职责链模式 理解：职责连是由多个不同的对象组成的，发送者是发送请求的对象，而接收者则是链中那些接收这种请求并且对其进行处理或传递的对象。请求本身有时候也可以是一个对象，它封装了和操作有关的所有数据，基本实现流程如下： 发送者知道链中的第一个接收者，它向这个接收者发送该请求 每一个接收者都对请求进行分析，然后要么处理它，要么它往下传递 每一个接收者知道其他的对象只有一个，即它在链中的下家(successor) 如果没有任何接收者处理请求，那么请求会从链中离开 优点：消除请求的发送者与接收者之间的耦合 链中的节点对象可以灵活地拆分重组，增加或删除一个节点，或者改变节点的位置都是很简单的事情 缺点：职责链模式中多了一点节点对象，可能在某一次请求过程中，大部分节点没有起到实质性作用，他们的作用只是让 请求传递下去，从性能方面考虑，避免过长的职责链提高性能。 6、命令模式 7、模板方法模式 8、策略模式 理解：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换 优点：策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。 策略模式中的代码可以复用。 9、观察者模式 理解：它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知 举个 🌰 var shoeObj = {}; // 定义发布者 shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者 shoeObj.listen = function(fn) { shoeObj.list.push(fn); // 订阅消息添加到缓存列表 } // 发布消息 shoeObj.trigger = function(){ for(var i = 0,fn; fn = this.list[i++];) { fn.apply(this,arguments); } } shoeObj.listen(function(color,size){ console.log(&quot;颜色是：&quot;+color); console.log(&quot;尺码是：&quot;+size); }); shoeObj.listen(function(color,size){ console.log(&quot;再次打印颜色是：&quot;+color); console.log(&quot;再次打印尺码是：&quot;+size); }); shoeObj.trigger(&quot;红色&quot;,40); shoeObj.trigger(&quot;黑色&quot;,42); 参考博客： https://www.cnblogs.com/tugenhua0707/p/5198407.html 二、理论知识 1、常用的有几种浏览器，内核是什么？ 浏览器：IE，Chrome，FireFox，Safari，Opera。 内核：Trident，Gecko，Presto，Webkit。 2、box-sizing常用的属性有哪些？分别有什么作用？ box-sizing: content-box|border-box|inherit; content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。 border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 3、Doctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 4、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 5、介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 6、html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 7、简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 8、this对象的理解 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； 9、你有哪些性能优化的方法？ 减少http请求次数：CSS Sprites, CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style。 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 10、深入理解JS中的Function.prototype.bind()方法 Function.prototype.bind = function(context) { var self = this; // 保存原函数 return function() { // 返回一个新函数 return self.apply(context, arguments); // 执行新函数时，将传入的上下文context作为新函数的this } } bind()的兼容性写法 if (!Function.prototype.bind) { Function.prototype.bind = function() { var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转成数组 return function() { // 返回一个新函数 // 执行新函数时，将传入的上下文context作为新函数的this // 并且组合两次分别传入的参数，作为新函数的参数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); } }; } 11、]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2017%2F11%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中 为什么使用缓存 （1）减少网络带宽消耗 （2）降低服务器压力 （3）减少网络延迟，加快页面打开速度 浏览器端的缓存规则 对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的 分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本， 还是需要去源服务器获取更新的版本。 新鲜度（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的： 含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内； 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度 校验值（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag）， 它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期， 浏览器需求重新获取资源内容。 1、使用HTML Meta 标签 &lt;!- Pragma是http1.0版本中给客户端设定缓存方式之一 -&gt;–&gt; 事实上这种禁用缓存的形式用处很有限： a. 仅有IE才能识别这段meta标签含义，其它主流浏览器仅识别“Cache-Control: no-store”的meta标签。 b. 在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。 2、HTTP消息报头 Pragma：no-cache 诉浏览器忽略资源的缓存副本，每次访问都需要去服务器拉取【http1.0中存在的字段，在http1.1已被抛弃，使用Cache-Control替代，但为了做http协议的向下兼容，很多网站依旧会带上这个字段】 Expires：Mon, 15 Aug 2016 03:56:47 GMT 告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代 Cache-Control：no-cache 告诉浏览器忽略资源的缓存副本，强制每次请求直接发送给服务器，拉取资源，但不是“不缓存” no-store 强制缓存在任何情况下都不要保留任何副本 max-age=[秒] 指明缓存副本的有效时长，从请求时间开始到过期时间之间的秒数 public 任何路径的缓存者（本地缓存、代理服务器），可以无条件的缓存改资源 private 只针对单个用户或者实体（不同用户、窗口）缓存资源 Last-Modified：Mon, 15 Aug 2016 03:56:47 GMT 告诉浏览器这个资源最后的修改时间 If-Modified-Since：Mon, 15 Aug 2016 03:56:47 GMT 其值为上次响应头的Last-Modified值，再次向web服务器请求时带上头If-Modified-Since。 web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。 若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内）， 包括更新Last-Modified的值，HTTP 200；若最后修改时间较旧，说明资源无新修改， 则响应HTTP 304 ETag：”fd56273325a2114818df4f29a628226d” 告诉浏览器当前资源在服务器的唯一标识符（生成规则又服务器决定） If-None-Match：”fd56273325a2114818df4f29a628226d” 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。 web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304 变更后对比 Cache-Control与Expires：Cache-Control与Expires的作用一致，都是指明当前资源的有效期 只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。 注意： Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存， 但是需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致， 以免负载均衡到不同机器导致比对失败 不能缓存的请求： HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0）， 或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 2、需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存 POST请求无法被缓存 HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画]]></title>
    <url>%2F2017%2F11%2F14%2FCSS3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[没事唠唠原生AJAX]]></title>
    <url>%2F2017%2F11%2F14%2F%E6%B2%A1%E4%BA%8B%E5%94%A0%E5%94%A0%E5%8E%9F%E7%94%9FAJAX%2F</url>
    <content type="text"><![CDATA[什么事ajax那？简单点来说就是“无刷新数据读取,读取服务器上的信息”。支持GET/POST请求。 GET用于获取数据，POST用于上传数据 GET的特点:1.通过网址传递(放入url中),会将传递的数据放到网址上面,–名字=值&amp;名字=值 2.容量小 3.安全性低 4.有缓存 POST的特点:1.不通过网址传递 2.容量较大,一般可达2G 3.安全性相对较高 4.没有缓存 ajax的流程: 1.建立xmlHttpRequrest连接； 非IE6浏览器:var oAjax = new XMLHttpRequest(); IE6浏览器:var oAjax = new ActiveXObject(“Microsoft.XMLHTTP”); 2.请求向台台服务器发送请求； oAjax.open(方法,文件名,异步传输); 👉 oAjax.open(‘GET’,’a.txt?t=’+new Date().getTime(),true);（阻止缓存） oAjax.send(); 3.根据服务器返回状态码进行相关的操作. readyState属性：0(未初始化)还没有调用open方法 1(载入)已经调用send()方法,正在发送请求 2(载入完成)send()方法完成,已经收到全部相应内容 3(解析)正在解析收到的响应内容 4(完成)响应内容解析完成,可以在客户端调用(完成并不一定成功,需要status来检测是成功还是失败) status属性：200 成功 404 返回值responseText:从服务器返回来的文本:oAjax.responseText oAjax.onreadystatechange=function(){ //oAjax.readyState: 表示浏览器和服务器之间进行到哪一步了 if(oAjax.readyState==4){ //读取完成 if(oAjax.status==200){ //读取的结果是成功 alert(‘成功:’+oAjax.responseText); } } } 4.返回的数据进行格式化 上代码 &lt;script&gt; window.onload=function() { var oBtn = document.getElementById(&quot;btn1&quot;); oBtn.onclick = function() { if(window.XMLHttpRequest)//如果有XMLHttpRequest，那就是非IE6浏览器。() { var oAjax = new XMLHttpRequest();//创建ajax对象 } else//如果没有XMLHttpRequest，那就是IE6浏览器 { var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6浏览器创建ajax对象 } //open(方法、文件名、异步传输） //方法： //传输方式是get方式还是post方式。 //文件名 //告诉服务器要读哪个文件 //异步传输 //异步：多件事一件一件的做 //同步：多件事情一起进行 //但是js里面的同步和异步和现实的同步异步相反。 //同步：多件事一件一件的做 //异步：多件事情一起进行 //ajax天生是用来做异步的 oAjax.open(&quot;GET&quot;,&quot;a.txt?t=&apos;+new Date().getTime()&quot;,true);//加上t=&apos;+new Date().getTime()&quot;的目的是为了消除缓存，每次的t的值不一样。 //3.发送请求 oAjax.send(); //4.接收返回 //客户端和服务器端有交互的时候会调用onreadystatechange oAjax.onreadystatechange=function() { //oAjax.readyState //浏览器和服务器，进行到哪一步了。 //0-&gt;（未初始化）：还没有调用 open() 方法。 //1-&gt;（载入）：已调用 send() 方法，正在发送请求。 //2-&gt;载入完成）：send() 方法完成，已收到全部响应内容。 //3-&gt;（解析）：正在解析响应内容。 //4-&gt;（完成）：响应内容解析完成，可以在客户端调用。 if(oAjax.readyState==4) { if(oAjax.status==200)//判断是否成功,如果是200，就代表成功 { alert(&quot;成功&quot;+oAjax.responseText);//读取a.txt文件成功就弹出成功。后面加上oAjax.responseText会输出a.txt文本的内容 } else { alert(&quot;失败&quot;); } } }; } }; /*//上面if里面需要些window的原因 //js里面的变量和属性 var a = 12; alert(a);//页面上弹出12很正常，而实际上输出的是下面的写法，是属于window的，只是window能省就省了。 alert(window.a);//输出结果是一样的 window.alert(window.a); //想a这种全局变量实际上是winow的一个属性。 //如果不定义一个变量a直接像下面那样输出a alert(a)//系统会报错，而不是undefind，因为没有定义变量a。 alert(window.a);//如果是这样写，系统就不会报错了，会显示undefind。 //出现上面的原因是因为直接写a从根上就找不到a，而前面加上window只是找不到window的属性a了。*/ &lt;/script&gt; 用JS写一个ajax 来个完整的 🌰 &quot;var Ajax={ get: function(url, fn) { var obj = new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据 obj.open(&apos;GET&apos;, url, true); obj.onreadystatechange = function() { if (obj.readyState == 4 &amp;&amp; obj.status == 200 || obj.status == 304) { // readyState == 4说明请求已完成 fn.call(this, obj.responseText); //从服务器获得数据 } }; obj.send(); }, post: function (url, data, fn) { // datat应为&apos;a=a1&amp;b=b1&apos;这种字符串格式，在jq里如果data为对象会自动将对象转成这种字符串格式 var obj = new XMLHttpRequest(); obj.open(&quot;POST&quot;, url, true); obj.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); // 添加http头，发送信息至服务器时内容编码类型 obj.onreadystatechange = function() { if (obj.readyState == 4 &amp;&amp; (obj.status == 200 || obj.status == 304)) { // 304未修改 fn.call(this, obj.responseText); } }; obj.send(data); } }&quot; JQ提供的ajax $.ajax({ url: , type: ‘’, dataType: ‘’, data: { }, success: function(){ }, error: function(){ } }) 推荐参考链接： https://www.cnblogs.com/yufann/p/JS-Ajax.html https://www.cnblogs.com/Strive-count/p/6386074.html]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的理解以及方法]]></title>
    <url>%2F2017%2F11%2F14%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参考地址： http://blog.csdn.net/kongjiea/article/details/44201021 http://blog.csdn.net/Joyhen/article/details/21631833 受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间） 这里需要明确的一点是：所谓的域跟js的存放服务器没有关系，比如baidu.com的页面加载了google.com的js，那么此js的所在域是”baidu.com”而不是google.com。也就是说，此时该js能操作baidu.com的页面对象，而不能操作”google.com”的页面对象。 注意注意 📢 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的， 第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 跨域的方法总结 单向跨域（一般用于获取数据） 1、使用JSONP跨域（动态创建script标签） 原理：因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用，如返回JSONP_getUsers([“paco”,”john”,”lili”])，也就是说此文件返回的结果调用了JSONP_getUsers函数，并且把[“paco”,”john”,”lili”]传进去，这个[“paco”,”john”,”lili”]是一个用户列表。那么如果此时我们的页面中有一个JSONP_getUsers函数，那么JSONP_getUsers就被调用到，并且传入了用户列表。此时就实现了在本域获取其他域数据的功能，也就是跨域。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求 JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。可以看出来JSONP跨域一般用于获取其他域的数据。 2、flash URLLoader 3、”window.name” window 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的”window.name”和iframe中的”window.name”互相独立的，所以不能直接在A中获取”window.name”，而要通过iframe获取 4、服务器代理 5、”location.hash（两个iframe之间）+ iframe，又称FIM，Fragment Identitier Messaging的简写” 6、”document.domain + iframe” 7、 postMessage “window.onload = function() { var ifr = document.getElementById(‘ifr’); var targetOrigin = ‘ http://b.com‘; // 若写成’ http://b.com/c/proxy.html&#39;效果一样 // 若写成’ http://c.com&#39;就不会执行postMessage了 ifr.contentWindow.postMessage(‘I was there!’, targetOrigin); };” //b.html “window.addEventListener(‘message’, function(event){ // 通过origin属性判断消息来源地址 if (event.origin == ‘ http://a.com‘) { alert(event.data); // 弹出”I was there!” alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 } }, false);” 8、CORS CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP以及HTTPS详解以及对比]]></title>
    <url>%2F2017%2F11%2F14%2FHTTP%E4%BB%A5%E5%8F%8AHTTPS%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[现在很多网站都已经从原来的HTTP切换到了HTTPS这中间出现了很多疑惑和问题，所以小仙女就很疑惑，为什么要大费周章的切换那？HTTPS到底有什么好处，新增加了什么？ 👀👇 看了一些大牛的介绍，从中总结了一下 参考博客： https://www.cnblogs.com/qiangxia/p/5261813.html ※https就是http和TCP之间有一层SSL层，这一层的实际作用是防止钓鱼和加密。防止钓鱼通过网站的证书，网站必须有CA证书，证书类似于一个解密的签名。另外是加密，加密需要一个密钥交换算法，双方通过交换后的密钥加解密。 我们先简明扼要的说列举一下他们区别，后文在分别详细介绍 http和https ① HTTPS是以安全为目标的HTTP通道，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL ② https具有安全性的ssl加密传输协议需要到ca申请证书，http是超文本传输协议，明文传输 ③ http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443 SSL的位置介于应用层和TCP层之间，应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头 TLS/SSL中使用了非对称加密，对称加密以及HASH算法 先说一下HTTP吧，http的全称是Hypertext Transfer Protocol Vertion （超文本传输协议），说通俗点就是用网络链接传输文本信息的协议，每次开网页时为什么要出现“ http://”呢？ 其实这个道理非常简单，因为你要获得网络上超文本信息，那么你肯定要遵循其超文本传输的规范。所以每次开网页出现的 “http：//”就如暗号，当暗号正确后才能获得相关信息。 HTTPS的全称是Secure Hypertext Transfer Protocol（安全超文本传输协议），是在http协议基础上增加了使用SSL加密传送信息的协议，它是一个安全通信通道，它基于HTTP开发，在客户计算机和服务器之间交换信息。它使用SSL进行信息交换。SSL使 用40 位关键字作为RC4流加密算法，SSL\TLS保护整个上层应用协议的通信包，Cookie是HTTP包的一部分。 你访问HTTPS网站，网站把公钥给你。验证公钥，然后生成一个串随机AES_128密码（假如是用AES加密），并把这个 密码用刚才那个公钥加密，发给服务端。服务端用私钥解密你的发送的数据，得到你随机生成的AES_128密码，并把网页内容全部用AES_128加密器起来，发会给你。浏览器用刚刚的AES_128密码解密 服务器返回的数据，得到你可读的内容。之后你发出的请求数据，也是用AES_128密码来加密。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页打开的整个过程]]></title>
    <url>%2F2017%2F11%2F14%2F%E7%BD%91%E9%A1%B5%E6%89%93%E5%BC%80%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[平时 我们经常会浏览一些网站，BUT你知道从输入URL到页面加载完成的过程中都发生了什么事情吗？ 先说一下简单的过程: 1、输入网站 2、DNS解析Ip（浏览器缓存-&gt;系统缓存-&gt;路由器缓存） 3、浏览器向服务器发送一个HTTP请求 4、服务器处理请求 5、服务器返回一个 HTTP 响应 6、浏览器显示 HTML 7、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等 8、浏览器发送异步请求 详细步骤看下面 👇 举个 🌰 例如： http://www.icey-monopolize.com/question/11111/ 协议部分：http 网络地址：www.icey-monopolize.com 资源路径：/question/111111/ 把url分割成几个部分：协议，网址，资源路径 网址：表明连接网络上那一台机器，可以是域名，也可以是某个IP，可以包含端口号 协议：表明以哪种方式来获取资源，例如HTTP,HTTPS,FTP等等 如果网络地址不是IP的话，会通过DNS（域名系统）将地址解析成对应的IP 紧接着发起网络连接，根据协议要求请求数据。服务器相应请求并返回给浏览器 浏览器加载资源并显示 以上只是最基本的步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及 详细可以看： http://www.guokr.com/question/554991/]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2017%2F11%2F14%2Fvue%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1、先叨叨生命周期吧 new Vue() -&gt; beforecreated -&gt; created -&gt; beforeMount -&gt; mounted -&gt; beforeDestory -&gt; destoryed -&gt;beforeUpdate -&gt; updated new: 创建一个新对象,将这个新对象的 proto 指向 构造函数的 prototype 成员对象 -&gt; 将构造函数的this指针指向这个新创建的对象 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 beforeUpdate: updated: beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 2、常用指令 v-if指令 v-show指令 v-else指令 v-for指令 v-bind指令 v-on指令 v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：v-if=”expression” expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式 v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性 可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别 v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似：v-for=”item in items” items是一个数组，item是当前被遍历的数组元素。 v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class v-bind:argument=”expression”v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性（attribute），例如：v-bind:class v-bind:argument=”expression” NaN v-bind指令可以缩写为一个冒号 NaN v-on指令用于给监听DOM事件，它的用语法和v-bind是类似的，例如监听 元素的点击事件： 有两种形式调用方法：绑定一个方法（让事件指向方法的引用），或者使用内联语句。Greet按钮将它的单击事件直接绑定到greet()方法，而Hi按钮则是调用say()方法。 Greet v-on指令可以缩写为@符号 Greet 3、vue和react的区别 相同点： ① React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写. vue特殊 文件格式，对文件内容都有一些约定，两者都需要编译后使用。 ② 中心思想相同：一切都是组件，组件实例之间可以嵌套 ③ 都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载 ④ 在组件开发中都支持mixins的特性 不同点： ① React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。 ② Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作DOM。 4、vue的优缺点 优点:简单：官方文档很清晰，比 Angular 简单易学。 快速：异步批处理方式更新 DOM。 组合：用解耦的、可复用的组件组合你的应用程序。 紧凑：~18kb min+gzip，且无依赖。 强大：表达式 &amp; 无需声明依赖的可推导属性 (computed properties)。 对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。 缺点: 不支持IE8 ① Vue开发Native App的能力弱一些 ② template 不好 debug Vue.js的特性如下： 1.轻量级的框架 2.双向数据绑定 3.指令 4.插件化 Vue.js与其他框架的区别？ 1.与AngularJS的区别 相同点： 都支持指令：内置指令和自定义指令。 都支持过滤器：内置过滤器和自定义过滤器。 都支持双向数据绑定。 都不支持低端浏览器。 5、什么是虚拟DOM DOM是文档对象模型(Document Object Model)的简写，在浏览器中我们可以通过js来操作DOM，但是这样的操作性能很差，于是Virtual Dom应运而生。我的理解，Virtual Dom就是在js中模拟DOM对象树来优化DOM操作的一种技术或思路。 一个VNode的实例对象包含了以下属性 tag: 当前节点的标签名 data: 当前节点的数据对象，具体包含哪些字段可以参考vue源码types/vnode.d.ts中对VNodeData的定义 children: 数组类型，包含了当前节点的子节点 text: 当前节点的文本，一般文本节点或注释节点会有该属性 elm: 当前虚拟节点对应的真实的dom节点 ns: 节点的namespace context: 编译作用域 functionalContext: 函数化组件的作用域 key: 节点的key属性，用于作为节点的标识，有利于patch的优化 componentOptions: 创建组件实例时会用到的选项信息 child: 当前节点对应的组件实例 parent: 组件的占位节点 raw: raw html isStatic: 静态节点的标识 isRootInsert: 是否作为根节点插入，被 包裹的节点，该属性的值为false isComment: 当前节点是否是注释节点 isCloned: 当前节点是否为克隆节点 isOnce: 当前节点是否有v-once指令 VNode可以理解为vue框架的虚拟dom的基类，通过new实例化的VNode大致可以分为几类 EmptyVNode: 没有内容的注释节点 TextVNode: 文本节点 ElementVNode: 普通元素节点 ComponentVNode: 组件节点 CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true 6.是否允许调试(生产环境不允许调试) vue.config.devtools = false vue.config.productionTip = false 7.计算属性 -7.1 计算属性也是用来存储数据，具有以下特点： a.数据可以进行逻辑处理操作 b.对计算属性中的数据进行监视 -7.2 计算属性vs方法 将计算属性的get函数定义为一个方法，也可以是实现 区别：1.计算属性是基于他的依赖进行更新的，只有在相关依赖发生改变时才会更新变化 2.计算属性是有缓存的，只要相关依赖为改变，多次访问计算属性得到得值，是之前缓存的结果，不会执行 get和set 计算属性有两部分组成，获取计算属性和设置计算属性的 默认只有get，若需要set则需要自己添加 computed:{ num:{ get:function(){ return this.num1 }, set:function(val){ this.num1 = val } } } 8、vue实例的属性 属性 vm.$el vm.$data vm.$options vm.$refs &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue实例的属性和方法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;main&apos;&gt; {{msg}} &lt;h2 id=&quot;aa&quot; ref=&quot;hello&quot;&gt;你好&lt;/h2&gt; &lt;h2 id=&quot;aa&quot; ref=&quot;world&quot;&gt;你好&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&apos;main&apos;, data:{ msg:&apos;1111111&apos; }, name:&apos;111&apos;, hshs:function(){}//直接写在外面 }) /** * 属性 */ //vm.属性名 console.log(vm.msg) //vm.$el 用来获取实例关联的元素 // console.log(vm.$el) //dom对象 div vm.$el.style.color = &apos;red&apos; //vm.$data 用来获取数据对象 console.log(vm.$data.msg) //vm.$options 获取自定义选项 console.log(vm.$options.name) console.log(vm.$options.hshs) //vm.$refs 用来获取页面中所有添加了ref属性的元素 // 获取自定义选项 console.log(vm.$refs) console.log(vm.$refs.hello) console.log(vm.$refs.world) vm.$refs.world.style.color = &apos;yellow&apos; &lt;/script&gt; &lt;/body&gt; 方法: vm.$mount vm.$destroy() vm.$nextTick() $vm.$set() $vm.$delete() vm.$watch() /** 方法 */ //vm.$mount 手动挂载vue实例 var vm = new Vue({ data:{ msg:&apos;1111111&apos; } }) vm.$mount(‘#main’) 或者 new Vue({ el:’main’, data:{ msg:’1111111’, name:’tom’ } }).$mount(‘#main’) //vm.$destoryed 销毁实例,清除实例连接和指令，时间监听，但是数据还在 vm.$destoryed() //vm.$nextTick(callback) //修改数据 vm.name =’hahah’ //页面重新渲染更新，此时dom还没更新完就执行下面的代码，获取不到更改后的值 console.log(vm.$refs.title.textContent) 此时需要将上面代码进行延迟，延迟到DOM更新完之后执行，所以看下面 vm.$nextTick(function(){ console.log(vm.$refs.title.textContent) }) //$vm.$set(obj,key,value) 用来给对象添加一个属性并制定值 //$vm.$delete()(obj,key) 删除对象属性 //vm.$watch(data,callback) 监视数据变化 var vm = new Vue({ data:{ msg:’1111111’, user:{ id:111, name:’tom’ } } }).$mount(‘#main’) //通过普通方式.xx来为对象添加属性时，无法实时监听，所以用set,可以实时监视 vm.$set(vm.user,’age’,28) 若在vue中直接写this.$set(this.user,’age’,28) 或者写全局的 Vue.set(this.user,’age’,28) Vue.set(vm.user,’age’,28) //$vm.$delete()(obj,key) vm.$delete(vm.user,’name’) this.$delete(this.user,’name’) Vue.delete(vm.user,’age’) Vue.delete(this.user,’age’) //vm.$watch(data,callback[]) 监视数据变化 var vm = new Vue({ data:{ msg:’1111111’, user:{ id:111, name:’tom’, age:16 } }, computed:{ myname:function(){} } }).$mount(‘#main’) //方法一 vm.$watch(‘name’,function(newValue,oldValue){ console.log(new) console.log(old) }) //方法二 var vm = new Vue({ data:{ msg:’1111111’, haha:’11’, user:{ id:111, name:’tom’, age:16 } }, computed:{ myname:function(){} }, watch:{ haha:function(newValue,oldValue){ }, &lt;!-- user:(newValue,oldValue)=&gt;{//当user下的age被修改，想要触发watch则需要深度监听 console.log(&apos;被修改了&apos;) } --&gt; user:{ //当对象下的属性修改时，也会被监视 handler:(newValue,oldValue)=&gt;{//当user下的age被修改，想要触发watch则需要深度监听 console.log(&apos;被修改了&apos;+newValue.name) }, deep:true } } }).$mount(‘#main’) 9、父子组件通信 //这里必须要用 - 代替驼峰 data(){ return { msg: [1,2,3] }; } props: [‘childMsg’] props: { childMsg: Array //这样可以指定传入的类型，如果类型不对，会警告 } props: { childMsg: { type: Array, default: [0,0,0] //这样可以指定默认的值 } } 子组件: methods: { up() { this.$emit(‘upup’,’hehe’); //主动触发upup方法，’hehe’为向父组件传递的数据 } } //监听子组件触发的upup事件,然后调用change方法 methods: { change(msg) { this.msg = msg; } }]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码理解]]></title>
    <url>%2F2017%2F11%2F14%2Fvue%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[用了一阵子vue，踩了无数的坑，回头发现貌似自己只是会用vue，但并不是了解，理解vue，所以在网上 搜罗了很多大神们对于vue底层源码的理解。现在总结一下。 ps：由于借鉴了很多很多大神的blog，so 就不一一列举了。如有雷同纯属正常。 能记住的： https://segmentfault.com/a/1190000010646462 vue程序大概可以分为两大部分 1、全局设计：全局接口，默认选项等 2、vm实例设计：包括接口，实例初始化过程设计 init -&gt; data -&gt; computed -&gt; watch -&gt; template -&gt; directive -&gt; repeat / if -&gt; component -&gt; transition -&gt; expression -&gt; path -&gt; filter 整个实例化的过程中，重中之重就是把数据model和试图view建立联系 真个过程是这样的，首先对data进行监听，把template解析成一段document fragment，然后解析其中的directive 得到每一个指令所以来的数据项。 举个 栗子 v-text=”message” 解析：所依赖的数据项 this.$data.message，相应的视图更新方法 node.textContent = this.$data.message 最后通过watcher把data和template结合起来，当数据变化的时候就会触发observer进而跟新视图 从文件结构上来看。vue的源代码放在项目的src中，src目录下存在很多文件， 上一张图片 ① instance/init.js instance/scope.js : 数据初始化，相关的子程序 -&gt; observer/**/ -&gt; batcher.js -&gt; observer/dep instance/compile.js : 视图初始化 + 相关子程序 -&gt; compile/**/ -&gt; directive.js -&gt; parsers ② 核心要素：directives,element-directives,filter,transition ③ 工具方法 util/ ④ config.js 默认配置 一些细节 1、this._eventsCount this._eventsCount = {} 为了避免不必要的深度遍历，当事件发生时，如果当前vm的_eventsCount 的值为0，则不必向其子vm继续传播 该事件 看代码 2、数据更新的diff机制 视图更新主要在于大列表的更新和深层数据更新这两方面 首先遍历新列表里的每一项，如果该项的 vm 之前就存在，则打一个 _reused 的标 如果不存在对应的 vm，则创建一个新的。其次，遍历旧列表里的每一项，如果 _reused 的标没有被打上， 则说明新列表里已经没有它了，就地销毁该 vm。然后，整理新的 vm 在视图里的顺序，同时还原之前打上 的 _reused 标。就此列表更新完成。 3、[keep-alive]特性 Vue.js 为其组件设计了一个 [keep-alive] 的特性，如果这个特性存在，那么在组件被重复创建的时候， 会通过缓存机制快速创建组件，以提升视图更新的性能。代码在 directives/component.js。 4、数据监听 很容易想到 Object.defineProperty 这个 API，为此属性设计一个特殊的 getter/setter，然后在 setter 里 触发一个函数，就可以达到监听的效果。 看一段代码 数组可能会有点麻烦，Vue.js 采取的是对几乎每一个可能改变数据的方法进行 prototype 更改： 看代码 BUT会有两个问题出现 ① 无法监听数据的 length，导致 arr.length 这样的数据改变无法被监听 ② 通过角标更改数据，即类似 arr[2] = 1 这样的赋值操作，也无法被监听 不过不用担心，同时 Vue.js 提供了两个额外的“糖方法” $set 和 $remove 来弥补这方面限制带来的不便。 5、path 解析器 parsers 文件夹里有各种文件，其中parsers/path.js 主要的职责是可以把一个 JSON 数据里的某一个“路径”下的数据取出来，比如： var path = &apos;a.b[1].v&apos; var obj = { a: { b: [ {v: 1}, {v: 2}, {v: 3} ] } } parse(obj, path) // 2 具体代码可以看Js文件，稍微梳理一下 看图 视图的解析过程，Vue.js 的策略是把 element 或 template string 先统一转换成 document fragment，然后再分解和解析其中的子组件和 directives。 6、双向数据绑定 双向数据绑定说的直接一点 ，就是在单项数据绑定的基础上给可输入的元素增加了change事件，动态修稿model和view 官方解释：将对象属性变化绑定到UI 实现数据绑定的做法大概有几种 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） ① 发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value) 但是我们不推荐这种方式我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图， ② 脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定 时轮询检测数据变动。angular只有在指定的事件触发时进入脏值检测 DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() ③ 数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter， 在数据变动时发布消息给订阅者，触发相应的监听回调。其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持， 达到监听数据变动的目的 要实现mvvm的双向绑定，就必须要实现以下几点： 1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数 new MVVM() -&gt; observer -&gt; 通知变化-&gt;dep -&gt; watcher -&gt; compile -&gt; 数据变化，绑定更新函数 -&gt; watcher -&gt; 初始化视图 -&gt; updater &lt;- watcher 实现Observer：知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性 对象的属性，都加上 setter和getter var data = {name:”myself”} observe(data) data.name = “dmq” function observe(data){ if(!data || typeof data !== ‘object’){ return } Object.key(data).forEach(function(key){ defineReactive(data,key,data[key]) }) } function defineReactive(data,key,val){ var dep = new Dep(); observe(val)//监听子属性 Object.defineProperty(data,key,{ enumerable:true, configutable:false, get:function(){ // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val }, set:function(newVal){ if (val === newVal) return; console.log(“监听到”+val+”变化成了”+newVal) val = newVal dep.notify()// 通知所有订阅者 } }) } 这样我们已经可以监听每个数据的变化了,其中 dep.notify()见下文 接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法 function Dep() { this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; 接下来 我们需要一个订阅者订阅者Watcher var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作， 所以我们可以在 getter里面动手脚： Watcher.prototype = { get: function(key) { Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; } } 实现compile compile主要是负责解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图，如图所示： new Compile -&gt; 指令解析-&gt;模板指令替换对应数据 -&gt; update -&gt;new Updater()监听数据绑定新函数-&gt;update 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回 原来的真实dom节点中 function Compile(el){ this.$el = this.isElementNode(el) ? el : document.querySelector(el) if(this.$el){ this.$fragment = this.node2Fragment(this.$el) this.init(); this.$el.appendChild(this.$fragment) } } Compile.prototype = { compileElement:function(el) { var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) { var text = node.textContent; var reg = /\{\{(.*)\}\}/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) { me.compile(node); } else if (me.isTextNode(node) &amp;&amp; reg.test(text)) { me.compileText(node, RegExp.$1); } // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) { me.compileElement(node); } }, init:function(){ this.compileElement(this.$fragment) }, node2Fragment:function(el){ var fragment = document.createDocumentFrgment() var child; while(chile = el.firstChild){ fragment.appendChild(child) } return fragment; } } compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定 function compile(node) { var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) { // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) { var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) { // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); } else { // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); } } }); } // 指令处理集合 &quot;var compileUtil = { text: function(node, vm, exp) { this.bind(node, vm, exp, &apos;text&apos;); }, // ...省略 bind: function(node, vm, exp, dir) { var updaterFn = updater[dir + &apos;Updater&apos;]; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) { // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); }); } };&quot; // 更新函数 &quot;var updater = { textUpdater: function(node, value) { node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value; } // ...省略 };&quot; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了花括号表达式声明的文本节点 实现watcher Watcher作为Observer和Compile之间通信的桥梁 ① 在自身实例化时往属性订阅器(dep)里面添加自己 ② 自身必须有一个update()方法 ③ 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 function Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); } &quot;Watcher.prototype = { update: function() { this.run(); // 属性值变化收到通知 }, run: function() { var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 } }, get: function() { Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; } };&quot; // 这里再次列出Observer和Dep，方便理解 “Object.defineProperty(data, key, { get: function() { // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; } // … 省略 });” “Dep.prototype = { notify: function() { this.subs.forEach(function(sub) { sub.update(); // 调用订阅者的update方法，通知变化 }); } }” 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈Webpack]]></title>
    <url>%2F2017%2F11%2F09%2F%E6%BC%AB%E8%B0%88webpack%2F</url>
    <content type="text"><![CDATA[具体项目 小伙伴们可以 clone我的git上的demo 上连接: 1、概念： webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph) ， 其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载 2、入口：告诉webpack从哪里开始，并根据相关依赖确定打包内容。 用entry属性来定义 单个入口 👇 const config = { entry: { main: ‘./demo1/index.js’ } }; 简写如下 👇 const config = { entry:&apos;./demo1/index.js&apos; } module.exports = config; 多个入口 👇 entry: {[entryChunkName: string]: string|Array&lt;string&gt;} const config = { entry: { index: &apos;./demo1/index.js&apos;, vendors: &apos;./demo1/vendors.js&apos; } }; 上面代码意味着从 index.js 和 vendors.js 开始创建依赖图，这些依赖图是彼此完全分离、互相独立的 3、出口：在哪里打包。filename 用于输出文件的文件名。目标输出目录 path 的绝对路径 用output 属性描述了如何处理归拢在一起的代码.”output.filename”代表打包名称。 “output.path”代表要打包emitted到哪里（emitted是生产或“排放的特殊术语。） //将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中 const config = { output: { filename: ‘bundle.js’, path: ‘/home/proj/public/assets’ } }; module.exports = config; ############################################################################## const path = require(‘path’); const config = { entry:’./demo1/index.js’, output:{ path:path.resolve(__dirname,’dist’), //path.resolve用于将相对路径转为绝对路径 filename:”demo1.bundle.js” } } module.exports = config; 如果配置创建了多个单独的 &quot;chunk&quot;（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称 { entry: { app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; }, output: { filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; } } // 写入到硬盘：./dist/app.js, ./dist/search.js 4、loader：loader 用于对模块的源代码进行转换,loader 可以将文件从不同的语言转换为JS 在文件被添加到依赖图中时，其转换为模块。在每个文件的基础上执行转换 识别出(identify)应该被对应的 loader 进行转换(transform)的那些文件 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中） ※※※ webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。然而 webpack 自身只理解 JavaScript。 module:{ rules:[ { test:/\.txt$/,use:&apos;raw-loader&apos;} ] } 对一个module定义一个规则，里面包含test和use两个属性，意味着当遇到被解析为&apos;.txt&apos;的路径的时候，在 对其进行打包之前先使用raw-loader转换一下 使用 loader 告诉 webpack 加载 CSS 文件 module.exports = { module: { rules: [ { test: /\.css$/, use: &apos;css-loader&apos; } ] } }; 多个loader的时候 module: { rules: [ { test: /\.css$/, use: [ { loader: [&apos;style-loader&apos;](/loaders/style-loader) }, { loader: [&apos;css-loader&apos;](/loaders/css-loader), options: { modules: true } } ] } ] } ※※※ 内联写法：import Styles from ‘style-loader!css-loader?modules!./styles.css’; 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader ※※※ CLI：webpack –module-bind jade-loader –module-bind ‘css=style-loader!css-loader’ 5、插件（Plugins）：常用于（但不限于）在打包模块的 “compilation” 和 “chunk” 生命周期执行操作和自定义功能 想用一个插件的时候，只要require()即可 多数插件可以通过选项自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 来创建它的一个实例。 webpack 插件是一个具有 apply 属性的JS对象 const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const webpack = require(&apos;webpack&apos;); const path = require(&apos;path&apos;); const config = { entry:&apos;./demo1/index.js&apos;, output:{ path:path.resolve(__dirname,&apos;dist&apos;), filename:&quot;demo1.bundle.js&quot; }, module:{ rules:[ { test:/\.txt$/,use:&apos;raw-loader&apos;} ] }, plugins:[ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./demo1/index.html&apos;}) ] } module.exports = config; 6、配置: webpack 的配置文件，是导出一个对象的 JavaScript 文件。是标准的 Node.js CommonJS 模块 ※※※做好避免编写很长的配置（应该将配置拆分为多个文件） 7、依赖图表：一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。 8、构建目标：因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target) 你可以在你的 webpack 配置中设置。 单个target module.exports = { target: ‘node’ //在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境 }; 多个target（webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库） var path = require(‘path’); var serverConfig = { target: ‘node’, output: { path: path.resolve(__dirname, ‘dist’), filename: ‘lib.node.js’ } }; var clientConfig = { target: &apos;web&apos;, // &lt;=== 默认是 &apos;web&apos;，可省略 output: { path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;lib.js&apos; } //… }; module.exports = [ serverConfig, clientConfig ]; //dist 文件夹下创建 lib.js 和 lib.node.js 文件。 9、安装使用]]></content>
      <categories>
        <category>WEBPACK</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>WEBPACK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ源码分段详细看]]></title>
    <url>%2F2017%2F11%2F07%2FJQ%E6%BA%90%E7%A0%81%E5%88%86%E6%AE%B5%E8%AF%A6%E7%BB%86%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[最近读jQuery源码，记下我对大师作品的理解和心得，跟大家分享。 JQ的代码结构 (function(){ //变量定义 var jQuery = function(){...}; //原型定义(包含核心方法) jQuery.fn = jQuery.prototype = {...}; jQuery.fn.init.prototype = jQuery.fn; //提供jQuery静态方法与对象方法的扩展函数 jQuery.extend = jQuery.fn.extend = function(){...}; //后面依次有多个对jQuery静态方法的扩展 jQuery.extend({...}); //后面依次有多个对jQuery对象方法的扩展 jQuery.fn.extend({...}); jQuery.support = (function() {...})(); //提供统一时间管理,jQuery内部使用,并不对外开放 jQuery.event = {...}; //Event类似于Java的POJO类.传递事件的对象 jQuery.Event = function( src, props ) {...}; //Sizzle选择器,一个框架,可独立使用。 (function(){ ... jQuery.find = Sizzle; ... })(); ... //将定义的jQuery定义为全局变量 window.jQuery = window.$ = jQuery; ... })(); 一. 自执行匿名函数。 在函数里定义的变量都是局部变量，这样就很好的避免了过多的全局变量(jQuery仅仅2个全局变量jQuery和$)。由于闭包属性，虽然函数自执行结束了，但自执行函数里面定义的局部函数和变量还是能够被定义成全局变量的jQuery和$所引用到。 二. extend 函数 在后面的段落中有大段大段的 jQuery.extend({…}) 和 jQuery.fn.extend({…}) 代码 在jQuery中有2中调用形式： 1）$.Ajax(…); 2）$(“#id”).data(“xxx”); 第一种调用我称为静态调用，就类似于Java的静态方法一样，不用生成对象，而是类级函数。这里的$就相当于命名空间一样。 第二种调用我成为对象调用，因为.data()方法是定义在原型中的，只有new个对象才能调用的，所以成为对象方法。 上JQ的源码 /*! jQuery JavaScript Library v1.11.3 http://jquery.com/ * Includes Sizzle.js http://sizzlejs.com/ * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors Released under the MIT license http://jquery.org/license * Date: 2015-04-28T16:19Z */ (function( global, factory ) { if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) { // For CommonJS and CommonJS-like environments where a proper window is present, // execute the factory and get jQuery // For environments that do not inherently posses a window with a document // (such as Node.js), expose a jQuery-making factory as module.exports // This accentuates the need for the creation of a real window // e.g. var jQuery = require(&quot;jquery&quot;)(window); // See ticket #14549 for more info module.exports = global.document ? factory( global, true ) : function( w ) { if ( !w.document ) { throw new Error( &quot;jQuery requires a window with a document&quot; ); } return factory( w ); }; } else { factory( global ); } // Pass this if window is not defined yet }(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) { // Can&apos;t do this because several apps including ASP.NET trace // the stack via arguments.caller.callee and Firefox dies if // you try to trace through &quot;use strict&quot; call chains. (#13335) // Support: Firefox 18+ // var deletedIds = []; var slice = deletedIds.slice; var concat = deletedIds.concat; var push = deletedIds.push; var indexOf = deletedIds.indexOf; var class2type = {}; var toString = class2type.toString; var hasOwn = class2type.hasOwnProperty; var support = {}; var version = &quot;1.11.3&quot;, // Define a local copy of jQuery jQuery = function( selector, context ) { // The jQuery object is actually just the init constructor &apos;enhanced&apos; // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context ); }, // Support: Android&lt;4.1, IE&lt;9 // Make sure we trim BOM and NBSP rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, // Used by jQuery.camelCase as callback to replace() fcamelCase = function( all, letter ) { return letter.toUpperCase(); }; jQuery.fn = jQuery.prototype = { // The current version of jQuery being used jquery: version, constructor: jQuery, // Start with an empty selector selector: &quot;&quot;, // The default length of a jQuery object is 0 length: 0, toArray: function() { return slice.call( this ); }, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function( num ) { return num != null ? // Return just the one element from the set ( num &lt; 0 ? this[ num + this.length ] : this[ num ] ) : // Return all the elements in a clean array slice.call( this ); }, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function( elems ) { // Build a new jQuery matched element set var ret = jQuery.merge( this.constructor(), elems ); // Add the old object onto the stack (as a reference) ret.prevObject = this; ret.context = this.context; // Return the newly-formed element set return ret; }, // Execute a callback for every element in the matched set. // (You can seed the arguments with an array of args, but this is // only used internally.) each: function( callback, args ) { return jQuery.each( this, callback, args ); }, map: function( callback ) { return this.pushStack( jQuery.map(this, function( elem, i ) { return callback.call( elem, i, elem ); })); }, slice: function() { return this.pushStack( slice.apply( this, arguments ) ); }, first: function() { return this.eq( 0 ); }, last: function() { return this.eq( -1 ); }, eq: function( i ) { var len = this.length, j = +i + ( i &lt; 0 ? len : 0 ); return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] ); }, end: function() { return this.prevObject || this.constructor(null); }, // For internal use only. // Behaves like an Array&apos;s method, not like a jQuery method. push: push, sort: deletedIds.sort, splice: deletedIds.splice }; jQuery.extend = jQuery.fn.extend = function() { var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) { deep = target; // skip the boolean and the target target = arguments[ i ] || {}; i++; } // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) { target = {}; } // extend jQuery itself if only one argument is passed if ( i === length ) { target = this; i--; } for ( ; i &lt; length; i++ ) { // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) { // Extend the base object for ( name in options ) { src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) { continue; } // Recurse if we&apos;re merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) { if ( copyIsArray ) { copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; } else { clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}; } // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values } else if ( copy !== undefined ) { target[ name ] = copy; } } } } // Return the modified object return target; }; jQuery.extend({ // Unique for each copy of jQuery on the page expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ), // Assume jQuery is ready without the ready module isReady: true, error: function( msg ) { throw new Error( msg ); }, noop: function() {}, // See test/unit/core.js for details concerning isFunction. // Since version 1.3, DOM methods and functions like alert // aren&apos;t supported. They return false on IE (#2968). isFunction: function( obj ) { return jQuery.type(obj) === &quot;function&quot;; }, isArray: Array.isArray || function( obj ) { return jQuery.type(obj) === &quot;array&quot;; }, isWindow: function( obj ) { /* jshint eqeqeq: false */ return obj != null &amp;&amp; obj == obj.window; }, isNumeric: function( obj ) { // parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;) // ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;) // subtraction forces infinities to NaN // adding 1 corrects loss of precision from parseFloat (#15100) return !jQuery.isArray( obj ) &amp;&amp; (obj - parseFloat( obj ) + 1) &gt;= 0; }, isEmptyObject: function( obj ) { var name; for ( name in obj ) { return false; } return true; }, isPlainObject: function( obj ) { var key; // Must be an Object. // Because of IE, we also have to check the presence of the constructor property. // Make sure that DOM nodes and window objects don&apos;t pass through, as well if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) { return false; } try { // Not own constructor property must be Object if ( obj.constructor &amp;&amp; !hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp; !hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) { return false; } } catch ( e ) { // IE8,9 Will throw exceptions on certain host objects #9897 return false; } // Support: IE&lt;9 // Handle iteration over inherited properties before own properties. if ( support.ownLast ) { for ( key in obj ) { return hasOwn.call( obj, key ); } } // Own properties are enumerated firstly, so to speed up, // if last one is own, then all properties are own. for ( key in obj ) {} return key === undefined || hasOwn.call( obj, key ); }, type: function( obj ) { if ( obj == null ) { return obj + &quot;&quot;; } return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ? class2type[ toString.call(obj) ] || &quot;object&quot; : typeof obj; }, // Evaluates a script in a global context // Workarounds based on findings by Jim Driscoll // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context globalEval: function( data ) { if ( data &amp;&amp; jQuery.trim( data ) ) { // We use execScript on Internet Explorer // We use an anonymous function so that context is window // rather than jQuery in Firefox ( window.execScript || function( data ) { window[ &quot;eval&quot; ].call( window, data ); } )( data ); } }, // Convert dashed to camelCase; used by the css and data modules // Microsoft forgot to hump their vendor prefix (#9572) camelCase: function( string ) { return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase ); }, nodeName: function( elem, name ) { return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase(); }, // args is for internal usage only each: function( obj, callback, args ) { var value, i = 0, length = obj.length, isArray = isArraylike( obj ); if ( args ) { if ( isArray ) { for ( ; i &lt; length; i++ ) { value = callback.apply( obj[ i ], args ); if ( value === false ) { break; } } } else { for ( i in obj ) { value = callback.apply( obj[ i ], args ); if ( value === false ) { break; } } } // A special, fast, case for the most common use of each } else { if ( isArray ) { for ( ; i &lt; length; i++ ) { value = callback.call( obj[ i ], i, obj[ i ] ); if ( value === false ) { break; } } } else { for ( i in obj ) { value = callback.call( obj[ i ], i, obj[ i ] ); if ( value === false ) { break; } } } } return obj; }, // Support: Android&lt;4.1, IE&lt;9 trim: function( text ) { return text == null ? &quot;&quot; : ( text + &quot;&quot; ).replace( rtrim, &quot;&quot; ); }, // results is for internal usage only makeArray: function( arr, results ) { var ret = results || []; if ( arr != null ) { if ( isArraylike( Object(arr) ) ) { jQuery.merge( ret, typeof arr === &quot;string&quot; ? [ arr ] : arr ); } else { push.call( ret, arr ); } } return ret; }, inArray: function( elem, arr, i ) { var len; if ( arr ) { if ( indexOf ) { return indexOf.call( arr, elem, i ); } len = arr.length; i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0; for ( ; i &lt; len; i++ ) { // Skip accessing in sparse arrays if ( i in arr &amp;&amp; arr[ i ] === elem ) { return i; } } } return -1; }, merge: function( first, second ) { var len = +second.length, j = 0, i = first.length; while ( j &lt; len ) { first[ i++ ] = second[ j++ ]; } // Support: IE&lt;9 // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists) if ( len !== len ) { while ( second[j] !== undefined ) { first[ i++ ] = second[ j++ ]; } } first.length = i; return first; }, grep: function( elems, callback, invert ) { var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; // Go through the array, only saving the items // that pass the validator function for ( ; i &lt; length; i++ ) { callbackInverse = !callback( elems[ i ], i ); if ( callbackInverse !== callbackExpect ) { matches.push( elems[ i ] ); } } return matches; }, // arg is for internal usage only map: function( elems, callback, arg ) { var value, i = 0, length = elems.length, isArray = isArraylike( elems ), ret = []; // Go through the array, translating each of the items to their new values if ( isArray ) { for ( ; i &lt; length; i++ ) { value = callback( elems[ i ], i, arg ); if ( value != null ) { ret.push( value ); } } // Go through every key on the object, } else { for ( i in elems ) { value = callback( elems[ i ], i, arg ); if ( value != null ) { ret.push( value ); } } } // Flatten any nested arrays return concat.apply( [], ret ); }, // A global GUID counter for objects guid: 1, // Bind a function to a context, optionally partially applying any // arguments. proxy: function( fn, context ) { var args, proxy, tmp; if ( typeof context === &quot;string&quot; ) { tmp = fn[ context ]; context = fn; fn = tmp; } // Quick check to determine if target is callable, in the spec // this throws a TypeError, but we will just return undefined. if ( !jQuery.isFunction( fn ) ) { return undefined; } // Simulated bind args = slice.call( arguments, 2 ); proxy = function() { return fn.apply( context || this, args.concat( slice.call( arguments ) ) ); }; // Set the guid of unique handler to the same of original handler, so it can be removed proxy.guid = fn.guid = fn.guid || jQuery.guid++; return proxy; }, now: function() { return +( new Date() ); }, // jQuery.support is not used in Core but other projects attach their // properties to it so it needs to exist. support: support }); // Populate the class2type map jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) { class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase(); }); function isArraylike( obj ) { // Support: iOS 8.2 (not reproducible in simulator) // `in` check used to prevent JIT error (gh-2145) // hasOwn isn&apos;t used here due to false negatives // regarding Nodelist length in IE var length = &quot;length&quot; in obj &amp;&amp; obj.length, type = jQuery.type( obj ); if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) { return false; } if ( obj.nodeType === 1 &amp;&amp; length ) { return true; } return type === &quot;array&quot; || length === 0 || typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj; } var Sizzle = /*! * Sizzle CSS Selector Engine v2.2.0-pre * http://sizzlejs.com/ * * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors * Released under the MIT license * http://jquery.org/license * * Date: 2014-12-16 */ (function( window ) { var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data expando = &quot;sizzle&quot; + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function( a, b ) { if ( a === b ) { hasDuplicate = true; } return 0; }, // General-purpose constants MAX_NEGATIVE = 1 &lt;&lt; 31, // Instance methods hasOwn = ({}).hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it&apos;s faster than native // http://jsperf.com/thor-indexof-vs-for/5 indexOf = function( list, elem ) { var i = 0, len = list.length; for ( ; i &lt; len; i++ ) { if ( list[i] === elem ) { return i; } } return -1; }, booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;, // Regular expressions // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;, // http://www.w3.org/TR/css3-syntax/#characters characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;, // Loosely modeled on CSS identifier characters // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ), // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)(?:&quot; + whitespace + // Operator (capture 2) &quot;*([*^$|!~]?=)&quot; + whitespace + // &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot; &quot;*(?:&apos;((?:\\\\.|[^\\\\&apos;])*)&apos;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace + &quot;*\\]&quot;, pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\((&quot; + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments: // 1. quoted (capture 3; capture 4 or capture 5) &quot;(&apos;((?:\\\\.|[^\\\\&apos;])*)&apos;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; + // 2. simple (capture 6) &quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; + // 3. anything else (capture 2) &quot;.*&quot; + &quot;)\\)|)&quot;, // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter rwhitespace = new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ), rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ), rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ), rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ), rattributeQuotes = new RegExp( &quot;=&quot; + whitespace + &quot;*([^\\]&apos;\&quot;]*?)&quot; + whitespace + &quot;*\\]&quot;, &quot;g&quot; ), rpseudo = new RegExp( pseudos ), ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ), matchExpr = { &quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ), &quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ), &quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ), &quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ), &quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ), &quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace + &quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace + &quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ), &quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ), // For use in libraries implementing .is() // We use this for POS matching in `select` &quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; + whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; ) }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /&apos;|\\/g, // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ), funescape = function( _, escaped, escapedWhitespace ) { var high = &quot;0x&quot; + escaped - 0x10000; // NaN means non-codepoint // Support: Firefox&lt;24 // Workaround erroneous numeric interpretation of +&quot;0x&quot; return high !== high || escapedWhitespace ? escaped : high &lt; 0 ? // BMP codepoint String.fromCharCode( high + 0x10000 ) : // Supplemental Plane codepoint (surrogate pair) String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 ); }, // Used for iframes // See setDocument() // Removing the function wrapper causes a &quot;Permission Denied&quot; // error in IE unloadHandler = function() { setDocument(); }; // Optimize for push.apply( _, NodeList ) try { push.apply( (arr = slice.call( preferredDoc.childNodes )), preferredDoc.childNodes ); // Support: Android&lt;4.0 // Detect silently failing push.apply arr[ preferredDoc.childNodes.length ].nodeType; } catch ( e ) { push = { apply: arr.length ? // Leverage slice if possible function( target, els ) { push_native.apply( target, slice.call(els) ); } : // Support: IE&lt;9 // Otherwise append directly function( target, els ) { var j = target.length, i = 0; // Can&apos;t trust NodeList.length while ( (target[j++] = els[i++]) ) {} target.length = j - 1; } }; } function Sizzle( selector, context, results, seed ) { var match, elem, m, nodeType, // QSA vars i, groups, old, nid, newContext, newSelector; if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) { setDocument( context ); } context = context || document; results = results || []; nodeType = context.nodeType; if ( typeof selector !== &quot;string&quot; || !selector || nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) { return results; } if ( !seed &amp;&amp; documentIsHTML ) { // Try to shortcut find operations when possible (e.g., not under DocumentFragment) if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) { // Speed-up: Sizzle(&quot;#ID&quot;) if ( (m = match[1]) ) { if ( nodeType === 9 ) { elem = context.getElementById( m ); // Check parentNode to catch when Blackberry 4.6 returns // nodes that are no longer in the document (jQuery #6963) if ( elem &amp;&amp; elem.parentNode ) { // Handle the case where IE, Opera, and Webkit return items // by name instead of ID if ( elem.id === m ) { results.push( elem ); return results; } } else { return results; } } else { // Context is not a document if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp; contains( context, elem ) &amp;&amp; elem.id === m ) { results.push( elem ); return results; } } // Speed-up: Sizzle(&quot;TAG&quot;) } else if ( match[2] ) { push.apply( results, context.getElementsByTagName( selector ) ); return results; // Speed-up: Sizzle(&quot;.CLASS&quot;) } else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName ) { push.apply( results, context.getElementsByClassName( m ) ); return results; } } // QSA path if ( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) { nid = old = expando; newContext = context; newSelector = nodeType !== 1 &amp;&amp; selector; // qSA works strangely on Element-rooted queries // We can work around this by specifying an extra ID on the root // and working up from there (Thanks to Andrew Dupont for the technique) // IE 8 doesn&apos;t work on object elements if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) { groups = tokenize( selector ); if ( (old = context.getAttribute(&quot;id&quot;)) ) { nid = old.replace( rescape, &quot;\\$&amp;&quot; ); } else { context.setAttribute( &quot;id&quot;, nid ); } nid = &quot;[id=&apos;&quot; + nid + &quot;&apos;] &quot;; i = groups.length; while ( i-- ) { groups[i] = nid + toSelector( groups[i] ); } newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context; newSelector = groups.join(&quot;,&quot;); } if ( newSelector ) { try { push.apply( results, newContext.querySelectorAll( newSelector ) ); return results; } catch(qsaError) { } finally { if ( !old ) { context.removeAttribute(&quot;id&quot;); } } } } } // All others return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed ); } /** * Create key-value caches of limited size * @returns {Function(string, Object)} Returns the Object data after storing it on itself with * property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) * deleting the oldest entry */ function createCache() { var keys = []; function cache( key, value ) { // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157) if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) { // Only keep the most recent entries delete cache[ keys.shift() ]; } return (cache[ key + &quot; &quot; ] = value); } return cache; } /** * Mark a function for special use by Sizzle * @param {Function} fn The function to mark */ function markFunction( fn ) { fn[ expando ] = true; return fn; } /** * Support testing using an element * @param {Function} fn Passed the created div and expects a boolean result */ function assert( fn ) { var div = document.createElement(&quot;div&quot;); try { return !!fn( div ); } catch (e) { return false; } finally { // Remove from its parent by default if ( div.parentNode ) { div.parentNode.removeChild( div ); } // release memory in IE div = null; } } /** * Adds the same handler for all of the specified attrs * @param {String} attrs Pipe-separated list of attributes * @param {Function} handler The method that will be applied */ function addHandle( attrs, handler ) { var arr = attrs.split(&quot;|&quot;), i = attrs.length; while ( i-- ) { Expr.attrHandle[ arr[i] ] = handler; } } /** * Checks document order of two siblings * @param {Element} a * @param {Element} b * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b */ function siblingCheck( a, b ) { var cur = b &amp;&amp; a, diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp; ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE ); // Use IE sourceIndex if available on both nodes if ( diff ) { return diff; } // Check if b follows a if ( cur ) { while ( (cur = cur.nextSibling) ) { if ( cur === b ) { return -1; } } } return a ? 1 : -1; } /** * Returns a function to use in pseudos for input types * @param {String} type */ function createInputPseudo( type ) { return function( elem ) { var name = elem.nodeName.toLowerCase(); return name === &quot;input&quot; &amp;&amp; elem.type === type; }; } /** * Returns a function to use in pseudos for buttons * @param {String} type */ function createButtonPseudo( type ) { return function( elem ) { var name = elem.nodeName.toLowerCase(); return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type; }; } /** * Returns a function to use in pseudos for positionals * @param {Function} fn */ function createPositionalPseudo( fn ) { return markFunction(function( argument ) { argument = +argument; return markFunction(function( seed, matches ) { var j, matchIndexes = fn( [], seed.length, argument ), i = matchIndexes.length; // Match elements found at the specified indexes while ( i-- ) { if ( seed[ (j = matchIndexes[i]) ] ) { seed[j] = !(matches[j] = seed[j]); } } }); }); } /** * Checks a node for validity as a Sizzle context * @param {Element|Object=} context * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value */ function testContext( context ) { return context &amp;&amp; typeof context.getElementsByTagName !== &quot;undefined&quot; &amp;&amp; context; } // Expose support vars for convenience support = Sizzle.support = {}; /** * Detects XML nodes * @param {Element|Object} elem An element or a document * @returns {Boolean} True iff elem is a non-HTML XML node */ isXML = Sizzle.isXML = function( elem ) { // documentElement is verified for cases where it doesn&apos;t yet exist // (such as loading iframes in IE - #4833) var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement; return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false; }; /** * Sets document-related variables once based on the current document * @param {Element|Object} [doc] An element or document object to use to set the document * @returns {Object} Returns the current document */ setDocument = Sizzle.setDocument = function( node ) { var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc; // If no document and documentElement is available, return if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) { return document; } // Set our document document = doc; docElem = doc.documentElement; parent = doc.defaultView; // Support: IE&gt;8 // If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded, // IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936 // IE6-8 do not support the defaultView property so parent will be undefined if ( parent &amp;&amp; parent !== parent.top ) { // IE11 does not have attachEvent, so all must suffer if ( parent.addEventListener ) { parent.addEventListener( &quot;unload&quot;, unloadHandler, false ); } else if ( parent.attachEvent ) { parent.attachEvent( &quot;onunload&quot;, unloadHandler ); } } /* Support tests ---------------------------------------------------------------------- */ documentIsHTML = !isXML( doc ); /* Attributes ---------------------------------------------------------------------- */ // Support: IE&lt;8 // Verify that getAttribute really returns attributes and not properties // (excepting IE8 booleans) support.attributes = assert(function( div ) { div.className = &quot;i&quot;; return !div.getAttribute(&quot;className&quot;); }); /* getElement(s)By* ---------------------------------------------------------------------- */ // Check if getElementsByTagName(&quot;*&quot;) returns only elements support.getElementsByTagName = assert(function( div ) { div.appendChild( doc.createComment(&quot;&quot;) ); return !div.getElementsByTagName(&quot;*&quot;).length; }); // Support: IE&lt;9 support.getElementsByClassName = rnative.test( doc.getElementsByClassName ); // Support: IE&lt;10 // Check if getElementById returns elements by name // The broken getElementById methods don&apos;t pick up programatically-set names, // so use a roundabout getElementsByName test support.getById = assert(function( div ) { docElem.appendChild( div ).id = expando; return !doc.getElementsByName || !doc.getElementsByName( expando ).length; }); // ID find and filter if ( support.getById ) { Expr.find[&quot;ID&quot;] = function( id, context ) { if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) { var m = context.getElementById( id ); // Check parentNode to catch when Blackberry 4.6 returns // nodes that are no longer in the document #6963 return m &amp;&amp; m.parentNode ? [ m ] : []; } }; Expr.filter[&quot;ID&quot;] = function( id ) { var attrId = id.replace( runescape, funescape ); return function( elem ) { return elem.getAttribute(&quot;id&quot;) === attrId; }; }; } else { // Support: IE6/7 // getElementById is not reliable as a find shortcut delete Expr.find[&quot;ID&quot;]; Expr.filter[&quot;ID&quot;] = function( id ) { var attrId = id.replace( runescape, funescape ); return function( elem ) { var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp; elem.getAttributeNode(&quot;id&quot;); return node &amp;&amp; node.value === attrId; }; }; } // Tag Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ? function( tag, context ) { if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) { return context.getElementsByTagName( tag ); // DocumentFragment nodes don&apos;t have gEBTN } else if ( support.qsa ) { return context.querySelectorAll( tag ); } } : function( tag, context ) { var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too results = context.getElementsByTagName( tag ); // Filter out possible comments if ( tag === &quot;*&quot; ) { while ( (elem = results[i++]) ) { if ( elem.nodeType === 1 ) { tmp.push( elem ); } } return tmp; } return results; }; // Class Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) { if ( documentIsHTML ) { return context.getElementsByClassName( className ); } }; /* QSA/matchesSelector ---------------------------------------------------------------------- */ // QSA and matchesSelector support // matchesSelector(:active) reports false when true (IE9/Opera 11.5) rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21) // We allow this because of a bug in IE8/9 that throws an error // whenever `document.activeElement` is accessed on an iframe // So, we allow :focus to pass through QSA all the time to avoid the IE error // See http://bugs.jquery.com/ticket/13378 rbuggyQSA = []; if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) { // Build QSA regex // Regex strategy adopted from Diego Perini assert(function( div ) { // Select is set to empty string on purpose // This is to test IE&apos;s treatment of not explicitly // setting a boolean content attribute, // since its presence should be enough // http://bugs.jquery.com/ticket/12359 docElem.appendChild( div ).innerHTML = &quot;&lt;a id=&apos;&quot; + expando + &quot;&apos;&gt;&lt;/a&gt;&quot; + &quot;&lt;select id=&apos;&quot; + expando + &quot;-\f]&apos; msallowcapture=&apos;&apos;&gt;&quot; + &quot;&lt;option selected=&apos;&apos;&gt;&lt;/option&gt;&lt;/select&gt;&quot;; // Support: IE8, Opera 11-12.16 // Nothing should be selected when empty strings follow ^= or $= or *= // The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section if ( div.querySelectorAll(&quot;[msallowcapture^=&apos;&apos;]&quot;).length ) { rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&apos;&apos;|\&quot;\&quot;)&quot; ); } // Support: IE8 // Boolean attributes and &quot;value&quot; are not treated correctly if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) { rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; ); } // Support: Chrome&lt;29, Android&lt;4.2+, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.7+ if ( !div.querySelectorAll( &quot;[id~=&quot; + expando + &quot;-]&quot; ).length ) { rbuggyQSA.push(&quot;~=&quot;); } // Webkit/Opera - :checked should return selected option elements // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked // IE8 throws error here and will not see later tests if ( !div.querySelectorAll(&quot;:checked&quot;).length ) { rbuggyQSA.push(&quot;:checked&quot;); } // Support: Safari 8+, iOS 8+ // https://bugs.webkit.org/show_bug.cgi?id=136851 // In-page `selector#id sibing-combinator selector` fails if ( !div.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) { rbuggyQSA.push(&quot;.#.+[+~]&quot;); } }); assert(function( div ) { // Support: Windows 8 Native Apps // The type and name attributes are restricted during .innerHTML assignment var input = doc.createElement(&quot;input&quot;); input.setAttribute( &quot;type&quot;, &quot;hidden&quot; ); div.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; ); // Support: IE8 // Enforce case-sensitivity of name attribute if ( div.querySelectorAll(&quot;[name=d]&quot;).length ) { rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; ); } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled) // IE8 throws error here and will not see later tests if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) { rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; ); } // Opera 10-11 does not throw on post-comma invalid pseudos div.querySelectorAll(&quot;*,:x&quot;); rbuggyQSA.push(&quot;,.*:&quot;); }); } if ( (support.matchesSelector = rnative.test( (matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector) )) ) { assert(function( div ) { // Check to see if it&apos;s possible to do matchesSelector // on a disconnected node (IE 9) support.disconnectedMatch = matches.call( div, &quot;div&quot; ); // This should fail with an exception // Gecko does not error, returns false instead matches.call( div, &quot;[s!=&apos;&apos;]:x&quot; ); rbuggyMatches.push( &quot;!=&quot;, pseudos ); }); } rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) ); rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) ); /* Contains ---------------------------------------------------------------------- */ hasCompare = rnative.test( docElem.compareDocumentPosition ); // Element contains another // Purposefully does not implement inclusive descendent // As in, an element does not contain itself contains = hasCompare || rnative.test( docElem.contains ) ? function( a, b ) { var adown = a.nodeType === 9 ? a.documentElement : a, bup = b &amp;&amp; b.parentNode; return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; ( adown.contains ? adown.contains( bup ) : a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16 )); } : function( a, b ) { if ( b ) { while ( (b = b.parentNode) ) { if ( b === a ) { return true; } } } return false; }; /* Sorting ---------------------------------------------------------------------- */ // Document order sorting sortOrder = hasCompare ? function( a, b ) { // Flag for duplicate removal if ( a === b ) { hasDuplicate = true; return 0; } // Sort on method existence if only one input has compareDocumentPosition var compare = !a.compareDocumentPosition - !b.compareDocumentPosition; if ( compare ) { return compare; } // Calculate position if both inputs belong to the same document compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ? a.compareDocumentPosition( b ) : // Otherwise we know they are disconnected 1; // Disconnected nodes if ( compare &amp; 1 || (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) { // Choose the first element that is related to our preferred document if ( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) { return -1; } if ( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) { return 1; } // Maintain original order return sortInput ? ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) : 0; } return compare &amp; 4 ? -1 : 1; } : function( a, b ) { // Exit early if the nodes are identical if ( a === b ) { hasDuplicate = true; return 0; } var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ]; // Parentless nodes are either documents or disconnected if ( !aup || !bup ) { return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) : 0; // If the nodes are siblings, we can do a quick check } else if ( aup === bup ) { return siblingCheck( a, b ); } // Otherwise we need full lists of their ancestors for comparison cur = a; while ( (cur = cur.parentNode) ) { ap.unshift( cur ); } cur = b; while ( (cur = cur.parentNode) ) { bp.unshift( cur ); } // Walk down the tree looking for a discrepancy while ( ap[i] === bp[i] ) { i++; } return i ? // Do a sibling check if the nodes have a common ancestor siblingCheck( ap[i], bp[i] ) : // Otherwise nodes in our document sort first ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0; }; return doc; }; Sizzle.matches = function( expr, elements ) { return Sizzle( expr, null, null, elements ); }; Sizzle.matchesSelector = function( elem, expr ) { // Set document vars if needed if ( ( elem.ownerDocument || elem ) !== document ) { setDocument( elem ); } // Make sure that attribute selectors are quoted expr = expr.replace( rattributeQuotes, &quot;=&apos;$1&apos;]&quot; ); if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp; ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp; ( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) { try { var ret = matches.call( elem, expr ); // IE 9&apos;s matchesSelector returns false on disconnected nodes if ( ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document // fragment in IE 9 elem.document &amp;&amp; elem.document.nodeType !== 11 ) { return ret; } } catch (e) {} } return Sizzle( expr, document, null, [ elem ] ).length &gt; 0; }; Sizzle.contains = function( context, elem ) { // Set document vars if needed if ( ( context.ownerDocument || context ) !== document ) { setDocument( context ); } return contains( context, elem ); }; Sizzle.attr = function( elem, name ) { // Set document vars if needed if ( ( elem.ownerDocument || elem ) !== document ) { setDocument( elem ); } var fn = Expr.attrHandle[ name.toLowerCase() ], // Don&apos;t get fooled by Object.prototype properties (jQuery #13807) val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ? fn( elem, name, !documentIsHTML ) : undefined; return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute( name ) : (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ? val.value : null; }; Sizzle.error = function( msg ) { throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg ); }; /** * Document sorting and removing duplicates * @param {ArrayLike} results */ Sizzle.uniqueSort = function( results ) { var elem, duplicates = [], j = 0, i = 0; // Unless we *know* we can detect duplicates, assume their presence hasDuplicate = !support.detectDuplicates; sortInput = !support.sortStable &amp;&amp; results.slice( 0 ); results.sort( sortOrder ); if ( hasDuplicate ) { while ( (elem = results[i++]) ) { if ( elem === results[ i ] ) { j = duplicates.push( i ); } } while ( j-- ) { results.splice( duplicates[ j ], 1 ); } } // Clear input after sorting to release objects // See https://github.com/jquery/sizzle/pull/225 sortInput = null; return results; }; /** * Utility function for retrieving the text value of an array of DOM nodes * @param {Array|Element} elem */ getText = Sizzle.getText = function( elem ) { var node, ret = &quot;&quot;, i = 0, nodeType = elem.nodeType; if ( !nodeType ) { // If no nodeType, this is expected to be an array while ( (node = elem[i++]) ) { // Do not traverse comment nodes ret += getText( node ); } } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) { // Use textContent for elements // innerText usage removed for consistency of new lines (jQuery #11153) if ( typeof elem.textContent === &quot;string&quot; ) { return elem.textContent; } else { // Traverse its children for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) { ret += getText( elem ); } } } else if ( nodeType === 3 || nodeType === 4 ) { return elem.nodeValue; } // Do not include comment or processing instruction nodes return ret; }; Expr = Sizzle.selectors = { // Can be adjusted by the user cacheLength: 50, createPseudo: markFunction, match: matchExpr, attrHandle: {}, find: {}, relative: { &quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true }, &quot; &quot;: { dir: &quot;parentNode&quot; }, &quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true }, &quot;~&quot;: { dir: &quot;previousSibling&quot; } }, preFilter: { &quot;ATTR&quot;: function( match ) { match[1] = match[1].replace( runescape, funescape ); // Move the given value to match[3] whether quoted or unquoted match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape ); if ( match[2] === &quot;~=&quot; ) { match[3] = &quot; &quot; + match[3] + &quot; &quot;; } return match.slice( 0, 4 ); }, &quot;CHILD&quot;: function( match ) { /* matches from matchExpr[&quot;CHILD&quot;] 1 type (only|nth|...) 2 what (child|of-type) 3 argument (even|odd|\d*|\d*n([+-]\d+)?|...) 4 xn-component of xn+y argument ([+-]?\d*n|) 5 sign of xn-component 6 x of xn-component 7 sign of y-component 8 y of y-component */ match[1] = match[1].toLowerCase(); if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) { // nth-* requires argument if ( !match[3] ) { Sizzle.error( match[0] ); } // numeric x and y parameters for Expr.filter.CHILD // remember that false/true cast respectively to 0/1 match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) ); match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; ); // other types prohibit arguments } else if ( match[3] ) { Sizzle.error( match[0] ); } return match; }, &quot;PSEUDO&quot;: function( match ) { var excess, unquoted = !match[6] &amp;&amp; match[2]; if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) { return null; } // Accept quoted arguments as-is if ( match[3] ) { match[2] = match[4] || match[5] || &quot;&quot;; // Strip excess characters from unquoted arguments } else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp; // Get excess from tokenize (recursively) (excess = tokenize( unquoted, true )) &amp;&amp; // advance to the next closing parenthesis (excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) { // excess is a negative index match[0] = match[0].slice( 0, excess ); match[2] = unquoted.slice( 0, excess ); } // Return only captures needed by the pseudo filter method (type and argument) return match.slice( 0, 3 ); } }, filter: { &quot;TAG&quot;: function( nodeNameSelector ) { var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase(); return nodeNameSelector === &quot;*&quot; ? function() { return true; } : function( elem ) { return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName; }; }, &quot;CLASS&quot;: function( className ) { var pattern = classCache[ className + &quot; &quot; ]; return pattern || (pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp; classCache( className, function( elem ) { return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; ); }); }, &quot;ATTR&quot;: function( name, operator, check ) { return function( elem ) { var result = Sizzle.attr( elem, name ); if ( result == null ) { return operator === &quot;!=&quot;; } if ( !operator ) { return true; } result += &quot;&quot;; return operator === &quot;=&quot; ? result === check : operator === &quot;!=&quot; ? result !== check : operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 : operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 : operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check : operator === &quot;~=&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 : operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; : false; }; }, &quot;CHILD&quot;: function( type, what, argument, first, last ) { var simple = type.slice( 0, 3 ) !== &quot;nth&quot;, forward = type.slice( -4 ) !== &quot;last&quot;, ofType = what === &quot;of-type&quot;; return first === 1 &amp;&amp; last === 0 ? // Shortcut for :nth-*(n) function( elem ) { return !!elem.parentNode; } : function( elem, context, xml ) { var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;, parent = elem.parentNode, name = ofType &amp;&amp; elem.nodeName.toLowerCase(), useCache = !xml &amp;&amp; !ofType; if ( parent ) { // :(first|last|only)-(child|of-type) if ( simple ) { while ( dir ) { node = elem; while ( (node = node[ dir ]) ) { if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) { return false; } } // Reverse direction for :only-* (if we haven&apos;t yet done so) start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;; } return true; } start = [ forward ? parent.firstChild : parent.lastChild ]; // non-xml :nth-child(...) stores cache data on `parent` if ( forward &amp;&amp; useCache ) { // Seek `elem` from a previously-cached index outerCache = parent[ expando ] || (parent[ expando ] = {}); cache = outerCache[ type ] || []; nodeIndex = cache[0] === dirruns &amp;&amp; cache[1]; diff = cache[0] === dirruns &amp;&amp; cache[2]; node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ]; while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || // Fallback to seeking `elem` from the start (diff = nodeIndex = 0) || start.pop()) ) { // When found, cache indexes on `parent` and break if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) { outerCache[ type ] = [ dirruns, nodeIndex, diff ]; break; } } // Use previously-cached element index if available } else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) { diff = cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...) } else { // Use the same loop as above to seek `elem` from the start while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || (diff = nodeIndex = 0) || start.pop()) ) { if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) { // Cache the index of each encountered element if ( useCache ) { (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ]; } if ( node === elem ) { break; } } } } // Incorporate the offset, then check against cycle size diff -= last; return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 ); } }; }, &quot;PSEUDO&quot;: function( pseudo, argument ) { // pseudo-class names are case-insensitive // http://www.w3.org/TR/selectors/#pseudo-classes // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters // Remember that setFilters inherits from pseudos var args, fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] || Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo ); // The user may use createPseudo to indicate that // arguments are needed to create the filter function // just as Sizzle does if ( fn[ expando ] ) { return fn( argument ); } // But maintain support for old signatures if ( fn.length &gt; 1 ) { args = [ pseudo, pseudo, &quot;&quot;, argument ]; return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ? markFunction(function( seed, matches ) { var idx, matched = fn( seed, argument ), i = matched.length; while ( i-- ) { idx = indexOf( seed, matched[i] ); seed[ idx ] = !( matches[ idx ] = matched[i] ); } }) : function( elem ) { return fn( elem, 0, args ); }; } return fn; } }, pseudos: { // Potentially complex pseudos &quot;not&quot;: markFunction(function( selector ) { // Trim the selector passed to compile // to avoid treating leading and trailing // spaces as combinators var input = [], results = [], matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) ); return matcher[ expando ] ? markFunction(function( seed, matches, context, xml ) { var elem, unmatched = matcher( seed, null, xml, [] ), i = seed.length; // Match elements unmatched by `matcher` while ( i-- ) { if ( (elem = unmatched[i]) ) { seed[i] = !(matches[i] = elem); } } }) : function( elem, context, xml ) { input[0] = elem; matcher( input, null, xml, results ); // Don&apos;t keep the element (issue #299) input[0] = null; return !results.pop(); }; }), &quot;has&quot;: markFunction(function( selector ) { return function( elem ) { return Sizzle( selector, elem ).length &gt; 0; }; }), &quot;contains&quot;: markFunction(function( text ) { text = text.replace( runescape, funescape ); return function( elem ) { return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1; }; }), // &quot;Whether an element is represented by a :lang() selector // is based solely on the element&apos;s language value // being equal to the identifier C, // or beginning with the identifier C immediately followed by &quot;-&quot;. // The matching of C against the element&apos;s language value is performed case-insensitively. // The identifier C does not have to be a valid language name.&quot; // http://www.w3.org/TR/selectors/#lang-pseudo &quot;lang&quot;: markFunction( function( lang ) { // lang value must be a valid identifier if ( !ridentifier.test(lang || &quot;&quot;) ) { Sizzle.error( &quot;unsupported lang: &quot; + lang ); } lang = lang.replace( runescape, funescape ).toLowerCase(); return function( elem ) { var elemLang; do { if ( (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) { elemLang = elemLang.toLowerCase(); return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0; } } while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 ); return false; }; }), // Miscellaneous &quot;target&quot;: function( elem ) { var hash = window.location &amp;&amp; window.location.hash; return hash &amp;&amp; hash.slice( 1 ) === elem.id; }, &quot;root&quot;: function( elem ) { return elem === docElem; }, &quot;focus&quot;: function( elem ) { return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex); }, // Boolean properties &quot;enabled&quot;: function( elem ) { return elem.disabled === false; }, &quot;disabled&quot;: function( elem ) { return elem.disabled === true; }, &quot;checked&quot;: function( elem ) { // In CSS3, :checked should return both checked and selected elements // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked var nodeName = elem.nodeName.toLowerCase(); return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected); }, &quot;selected&quot;: function( elem ) { // Accessing this property makes selected-by-default // options in Safari work properly if ( elem.parentNode ) { elem.parentNode.selectedIndex; } return elem.selected === true; }, // Contents &quot;empty&quot;: function( elem ) { // http://www.w3.org/TR/selectors/#empty-pseudo // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5), // but not by others (comment: 8; processing instruction: 7; etc.) // nodeType &lt; 6 works because attributes (2) do not appear as children for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) { if ( elem.nodeType &lt; 6 ) { return false; } } return true; }, &quot;parent&quot;: function( elem ) { return !Expr.pseudos[&quot;empty&quot;]( elem ); }, // Element/input types &quot;header&quot;: function( elem ) { return rheader.test( elem.nodeName ); }, &quot;input&quot;: function( elem ) { return rinputs.test( elem.nodeName ); }, &quot;button&quot;: function( elem ) { var name = elem.nodeName.toLowerCase(); return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;; }, &quot;text&quot;: function( elem ) { var attr; return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; elem.type === &quot;text&quot; &amp;&amp; // Support: IE&lt;8 // New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot; ( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; ); }, // Position-in-collection &quot;first&quot;: createPositionalPseudo(function() { return [ 0 ]; }), &quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) { return [ length - 1 ]; }), &quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) { return [ argument &lt; 0 ? argument + length : argument ]; }), &quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) { var i = 0; for ( ; i &lt; length; i += 2 ) { matchIndexes.push( i ); } return matchIndexes; }), &quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) { var i = 1; for ( ; i &lt; length; i += 2 ) { matchIndexes.push( i ); } return matchIndexes; }), &quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) { var i = argument &lt; 0 ? argument + length : argument; for ( ; --i &gt;= 0; ) { matchIndexes.push( i ); } return matchIndexes; }), &quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) { var i = argument &lt; 0 ? argument + length : argument; for ( ; ++i &lt; length; ) { matchIndexes.push( i ); } return matchIndexes; }) } }; Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;]; // Add button/input type pseudos for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) { Expr.pseudos[ i ] = createInputPseudo( i ); } for ( i in { submit: true, reset: true } ) { Expr.pseudos[ i ] = createButtonPseudo( i ); } // Easy API for creating new setFilters function setFilters() {} setFilters.prototype = Expr.filters = Expr.pseudos; Expr.setFilters = new setFilters(); tokenize = Sizzle.tokenize = function( selector, parseOnly ) { var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[ selector + &quot; &quot; ]; if ( cached ) { return parseOnly ? 0 : cached.slice( 0 ); } soFar = selector; groups = []; preFilters = Expr.preFilter; while ( soFar ) { // Comma and first run if ( !matched || (match = rcomma.exec( soFar )) ) { if ( match ) { // Don&apos;t consume trailing commas as valid soFar = soFar.slice( match[0].length ) || soFar; } groups.push( (tokens = []) ); } matched = false; // Combinators if ( (match = rcombinators.exec( soFar )) ) { matched = match.shift(); tokens.push({ value: matched, // Cast descendant combinators to space type: match[0].replace( rtrim, &quot; &quot; ) }); soFar = soFar.slice( matched.length ); } // Filters for ( type in Expr.filter ) { if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] || (match = preFilters[ type ]( match ))) ) { matched = match.shift(); tokens.push({ value: matched, type: type, matches: match }); soFar = soFar.slice( matched.length ); } } if ( !matched ) { break; } } // Return the length of the invalid excess // if we&apos;re just parsing // Otherwise, throw an error or return tokens return parseOnly ? soFar.length : soFar ? Sizzle.error( selector ) : // Cache the tokens tokenCache( selector, groups ).slice( 0 ); }; function toSelector( tokens ) { var i = 0, len = tokens.length, selector = &quot;&quot;; for ( ; i &lt; len; i++ ) { selector += tokens[i].value; } return selector; } function addCombinator( matcher, combinator, base ) { var dir = combinator.dir, checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;, doneName = done++; return combinator.first ? // Check against closest ancestor/preceding element function( elem, context, xml ) { while ( (elem = elem[ dir ]) ) { if ( elem.nodeType === 1 || checkNonElements ) { return matcher( elem, context, xml ); } } } : // Check against all ancestor/preceding elements function( elem, context, xml ) { var oldCache, outerCache, newCache = [ dirruns, doneName ]; // We can&apos;t set arbitrary data on XML nodes, so they don&apos;t benefit from dir caching if ( xml ) { while ( (elem = elem[ dir ]) ) { if ( elem.nodeType === 1 || checkNonElements ) { if ( matcher( elem, context, xml ) ) { return true; } } } } else { while ( (elem = elem[ dir ]) ) { if ( elem.nodeType === 1 || checkNonElements ) { outerCache = elem[ expando ] || (elem[ expando ] = {}); if ( (oldCache = outerCache[ dir ]) &amp;&amp; oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) { // Assign to newCache so results back-propagate to previous elements return (newCache[ 2 ] = oldCache[ 2 ]); } else { // Reuse newcache so results back-propagate to previous elements outerCache[ dir ] = newCache; // A match means we&apos;re done; a fail means we have to keep checking if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) { return true; } } } } } }; } function elementMatcher( matchers ) { return matchers.length &gt; 1 ? function( elem, context, xml ) { var i = matchers.length; while ( i-- ) { if ( !matchers[i]( elem, context, xml ) ) { return false; } } return true; } : matchers[0]; } function multipleContexts( selector, contexts, results ) { var i = 0, len = contexts.length; for ( ; i &lt; len; i++ ) { Sizzle( selector, contexts[i], results ); } return results; } function condense( unmatched, map, filter, context, xml ) { var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null; for ( ; i &lt; len; i++ ) { if ( (elem = unmatched[i]) ) { if ( !filter || filter( elem, context, xml ) ) { newUnmatched.push( elem ); if ( mapped ) { map.push( i ); } } } } return newUnmatched; } function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) { if ( postFilter &amp;&amp; !postFilter[ expando ] ) { postFilter = setMatcher( postFilter ); } if ( postFinder &amp;&amp; !postFinder[ expando ] ) { postFinder = setMatcher( postFinder, postSelector ); } return markFunction(function( seed, results, context, xml ) { var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ), // Prefilter to get matcher input, preserving a map for seed-results synchronization matcherIn = preFilter &amp;&amp; ( seed || !selector ) ? condense( elems, preMap, preFilter, context, xml ) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results, postFinder || ( seed ? preFilter : preexisting || postFilter ) ? // ...intermediate processing is necessary [] : // ...otherwise use results directly results : matcherIn; // Find primary matches if ( matcher ) { matcher( matcherIn, matcherOut, context, xml ); } // Apply postFilter if ( postFilter ) { temp = condense( matcherOut, postMap ); postFilter( temp, [], context, xml ); // Un-match failing elements by moving them back to matcherIn i = temp.length; while ( i-- ) { if ( (elem = temp[i]) ) { matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem); } } } if ( seed ) { if ( postFinder || preFilter ) { if ( postFinder ) { // Get the final matcherOut by condensing this intermediate into postFinder contexts temp = []; i = matcherOut.length; while ( i-- ) { if ( (elem = matcherOut[i]) ) { // Restore matcherIn since elem is not yet a final match temp.push( (matcherIn[i] = elem) ); } } postFinder( null, (matcherOut = []), temp, xml ); } // Move matched elements from seed to results to keep them synchronized i = matcherOut.length; while ( i-- ) { if ( (elem = matcherOut[i]) &amp;&amp; (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) { seed[temp] = !(results[temp] = elem); } } } // Add elements to results, through postFinder if defined } else { matcherOut = condense( matcherOut === results ? matcherOut.splice( preexisting, matcherOut.length ) : matcherOut ); if ( postFinder ) { postFinder( null, results, matcherOut, xml ); } else { push.apply( results, matcherOut ); } } }); } function matcherFromTokens( tokens ) { var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[ tokens[0].type ], implicitRelative = leadingRelative || Expr.relative[&quot; &quot;], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s) matchContext = addCombinator( function( elem ) { return elem === checkContext; }, implicitRelative, true ), matchAnyContext = addCombinator( function( elem ) { return indexOf( checkContext, elem ) &gt; -1; }, implicitRelative, true ), matchers = [ function( elem, context, xml ) { var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || ( (checkContext = context).nodeType ? matchContext( elem, context, xml ) : matchAnyContext( elem, context, xml ) ); // Avoid hanging onto element (issue #299) checkContext = null; return ret; } ]; for ( ; i &lt; len; i++ ) { if ( (matcher = Expr.relative[ tokens[i].type ]) ) { matchers = [ addCombinator(elementMatcher( matchers ), matcher) ]; } else { matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches ); // Return special upon seeing a positional matcher if ( matcher[ expando ] ) { // Find the next relative operator (if any) for proper handling j = ++i; for ( ; j &lt; len; j++ ) { if ( Expr.relative[ tokens[j].type ] ) { break; } } return setMatcher( i &gt; 1 &amp;&amp; elementMatcher( matchers ), i &gt; 1 &amp;&amp; toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*` tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; }) ).replace( rtrim, &quot;$1&quot; ), matcher, i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ), j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ), j &lt; len &amp;&amp; toSelector( tokens ) ); } matchers.push( matcher ); } } return elementMatcher( matchers ); } function matcherFromGroupMatchers( elementMatchers, setMatchers ) { var bySet = setMatchers.length &gt; 0, byElement = elementMatchers.length &gt; 0, superMatcher = function( seed, context, xml, results, outermost ) { var elem, j, matcher, matchedCount = 0, i = &quot;0&quot;, unmatched = seed &amp;&amp; [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ), // Use integer dirruns iff this is the outermost matcher dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1), len = elems.length; if ( outermost ) { outermostContext = context !== document &amp;&amp; context; } // Add elements passing elementMatchers directly to results // Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below // Support: IE&lt;9, Safari // Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) { if ( byElement &amp;&amp; elem ) { j = 0; while ( (matcher = elementMatchers[j++]) ) { if ( matcher( elem, context, xml ) ) { results.push( elem ); break; } } if ( outermost ) { dirruns = dirrunsUnique; } } // Track unmatched elements for set filters if ( bySet ) { // They will have gone through all possible matchers if ( (elem = !matcher &amp;&amp; elem) ) { matchedCount--; } // Lengthen the array for every element, matched or not if ( seed ) { unmatched.push( elem ); } } } // Apply set filters to unmatched elements matchedCount += i; if ( bySet &amp;&amp; i !== matchedCount ) { j = 0; while ( (matcher = setMatchers[j++]) ) { matcher( unmatched, setMatched, context, xml ); } if ( seed ) { // Reintegrate element matches to eliminate the need for sorting if ( matchedCount &gt; 0 ) { while ( i-- ) { if ( !(unmatched[i] || setMatched[i]) ) { setMatched[i] = pop.call( results ); } } } // Discard index placeholder values to get only actual matches setMatched = condense( setMatched ); } // Add matches to results push.apply( results, setMatched ); // Seedless set matches succeeding multiple successful matchers stipulate sorting if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp; ( matchedCount + setMatchers.length ) &gt; 1 ) { Sizzle.uniqueSort( results ); } } // Override manipulation of globals by nested matchers if ( outermost ) { dirruns = dirrunsUnique; outermostContext = contextBackup; } return unmatched; }; return bySet ? markFunction( superMatcher ) : superMatcher; } compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) { var i, setMatchers = [], elementMatchers = [], cached = compilerCache[ selector + &quot; &quot; ]; if ( !cached ) { // Generate a function of recursive functions that can be used to check each element if ( !match ) { match = tokenize( selector ); } i = match.length; while ( i-- ) { cached = matcherFromTokens( match[i] ); if ( cached[ expando ] ) { setMatchers.push( cached ); } else { elementMatchers.push( cached ); } } // Cache the compiled function cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) ); // Save selector and tokenization cached.selector = selector; } return cached; }; /** * A low-level selection function that works with Sizzle&apos;s compiled * selector functions * @param {String|Function} selector A selector or a pre-compiled * selector function built with Sizzle.compile * @param {Element} context * @param {Array} [results] * @param {Array} [seed] A set of elements to match against */ select = Sizzle.select = function( selector, context, results, seed ) { var i, tokens, token, type, find, compiled = typeof selector === &quot;function&quot; &amp;&amp; selector, match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) ); results = results || []; // Try to minimize operations if there is no seed and only one group if ( match.length === 1 ) { // Take a shortcut and set the context if the root selector is an ID tokens = match[0] = match[0].slice( 0 ); if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp; support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) { context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0]; if ( !context ) { return results; // Precompiled matchers will still verify ancestry, so step up a level } else if ( compiled ) { context = context.parentNode; } selector = selector.slice( tokens.shift().value.length ); } // Fetch a seed set for right-to-left matching i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length; while ( i-- ) { token = tokens[i]; // Abort if we hit a combinator if ( Expr.relative[ (type = token.type) ] ) { break; } if ( (find = Expr.find[ type ]) ) { // Search, expanding context for leading sibling combinators if ( (seed = find( token.matches[0].replace( runescape, funescape ), rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context )) ) { // If seed is empty or no tokens remain, we can return early tokens.splice( i, 1 ); selector = seed.length &amp;&amp; toSelector( tokens ); if ( !selector ) { push.apply( results, seed ); return results; } break; } } } } // Compile and execute a filtering function if one is not provided // Provide `match` to avoid retokenization if we modified the selector above ( compiled || compile( selector, match ) )( seed, context, !documentIsHTML, results, rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context ); return results; }; // One-time assignments // Sort stability support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando; // Support: Chrome 14-35+ // Always assume duplicates if they aren&apos;t passed to the comparison function support.detectDuplicates = !!hasDuplicate; // Initialize against the default document setDocument(); // Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27) // Detached nodes confoundingly follow *each other* support.sortDetached = assert(function( div1 ) { // Should return 1, but returns 4 (following) return div1.compareDocumentPosition( document.createElement(&quot;div&quot;) ) &amp; 1; }); // Support: IE&lt;8 // Prevent attribute/property &quot;interpolation&quot; // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx if ( !assert(function( div ) { div.innerHTML = &quot;&lt;a href=&apos;#&apos;&gt;&lt;/a&gt;&quot;; return div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ; }) ) { addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) { if ( !isXML ) { return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 ); } }); } // Support: IE&lt;9 // Use defaultValue in place of getAttribute(&quot;value&quot;) if ( !support.attributes || !assert(function( div ) { div.innerHTML = &quot;&lt;input/&gt;&quot;; div.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; ); return div.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;; }) ) { addHandle( &quot;value&quot;, function( elem, name, isXML ) { if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) { return elem.defaultValue; } }); } // Support: IE&lt;9 // Use getAttributeNode to fetch booleans when getAttribute lies if ( !assert(function( div ) { return div.getAttribute(&quot;disabled&quot;) == null; }) ) { addHandle( booleans, function( elem, name, isXML ) { var val; if ( !isXML ) { return elem[ name ] === true ? name.toLowerCase() : (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ? val.value : null; } }); } return Sizzle; })( window ); jQuery.find = Sizzle; jQuery.expr = Sizzle.selectors; jQuery.expr[&quot;:&quot;] = jQuery.expr.pseudos; jQuery.unique = Sizzle.uniqueSort; jQuery.text = Sizzle.getText; jQuery.isXMLDoc = Sizzle.isXML; jQuery.contains = Sizzle.contains; var rneedsContext = jQuery.expr.match.needsContext; var rsingleTag = (/^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/); var risSimple = /^.[^:#\[\.,]*$/; // Implement the identical functionality for filter and not function winnow( elements, qualifier, not ) { if ( jQuery.isFunction( qualifier ) ) { return jQuery.grep( elements, function( elem, i ) { /* jshint -W018 */ return !!qualifier.call( elem, i, elem ) !== not; }); } if ( qualifier.nodeType ) { return jQuery.grep( elements, function( elem ) { return ( elem === qualifier ) !== not; }); } if ( typeof qualifier === &quot;string&quot; ) { if ( risSimple.test( qualifier ) ) { return jQuery.filter( qualifier, elements, not ); } qualifier = jQuery.filter( qualifier, elements ); } return jQuery.grep( elements, function( elem ) { return ( jQuery.inArray( elem, qualifier ) &gt;= 0 ) !== not; }); } jQuery.filter = function( expr, elems, not ) { var elem = elems[ 0 ]; if ( not ) { expr = &quot;:not(&quot; + expr + &quot;)&quot;; } return elems.length === 1 &amp;&amp; elem.nodeType === 1 ? jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] : jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) { return elem.nodeType === 1; })); }; jQuery.fn.extend({ find: function( selector ) { var i, ret = [], self = this, len = self.length; if ( typeof selector !== &quot;string&quot; ) { return this.pushStack( jQuery( selector ).filter(function() { for ( i = 0; i &lt; len; i++ ) { if ( jQuery.contains( self[ i ], this ) ) { return true; } } }) ); } for ( i = 0; i &lt; len; i++ ) { jQuery.find( selector, self[ i ], ret ); } // Needed because $( selector, context ) becomes $( context ).find( selector ) ret = this.pushStack( len &gt; 1 ? jQuery.unique( ret ) : ret ); ret.selector = this.selector ? this.selector + &quot; &quot; + selector : selector; return ret; }, filter: function( selector ) { return this.pushStack( winnow(this, selector || [], false) ); }, not: function( selector ) { return this.pushStack( winnow(this, selector || [], true) ); }, is: function( selector ) { return !!winnow( this, // If this is a positional/relative selector, check membership in the returned set // so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&apos;t return true for a doc with two &quot;p&quot;. typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ? jQuery( selector ) : selector || [], false ).length; } }); // Initialize a jQuery object // A central reference to the root jQuery(document) var rootjQuery, // Use the correct document accordingly with window argument (sandbox) document = window.document, // A simple way to check for HTML strings // Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521) // Strict HTML recognition (#11290: must start with &lt;) rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/, init = jQuery.fn.init = function( selector, context ) { var match, elem; // HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false) if ( !selector ) { return this; } // Handle HTML strings if ( typeof selector === &quot;string&quot; ) { if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) { // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; } else { match = rquickExpr.exec( selector ); } // Match html or make sure no context is specified for #id if ( match &amp;&amp; (match[1] || !context) ) { // HANDLE: $(html) -&gt; $(array) if ( match[1] ) { context = context instanceof jQuery ? context[0] : context; // scripts is true for back-compat // Intentionally let the error be thrown if parseHTML is not present jQuery.merge( this, jQuery.parseHTML( match[1], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true ) ); // HANDLE: $(html, props) if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) { for ( match in context ) { // Properties of context are called as methods if possible if ( jQuery.isFunction( this[ match ] ) ) { this[ match ]( context[ match ] ); // ...and otherwise set as attributes } else { this.attr( match, context[ match ] ); } } } return this; // HANDLE: $(#id) } else { elem = document.getElementById( match[2] ); // Check parentNode to catch when Blackberry 4.6 returns // nodes that are no longer in the document #6963 if ( elem &amp;&amp; elem.parentNode ) { // Handle the case where IE and Opera return items // by name instead of ID if ( elem.id !== match[2] ) { return rootjQuery.find( selector ); } // Otherwise, we inject the element directly into the jQuery object this.length = 1; this[0] = elem; } this.context = document; this.selector = selector; return this; } // HANDLE: $(expr, $(...)) } else if ( !context || context.jquery ) { return ( context || rootjQuery ).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) } else { return this.constructor( context ).find( selector ); } // HANDLE: $(DOMElement) } else if ( selector.nodeType ) { this.context = this[0] = selector; this.length = 1; return this; // HANDLE: $(function) // Shortcut for document ready } else if ( jQuery.isFunction( selector ) ) { return typeof rootjQuery.ready !== &quot;undefined&quot; ? rootjQuery.ready( selector ) : // Execute immediately if ready is not present selector( jQuery ); } if ( selector.selector !== undefined ) { this.selector = selector.selector; this.context = selector.context; } return jQuery.makeArray( selector, this ); }; // Give the init function the jQuery prototype for later instantiation init.prototype = jQuery.fn; // Initialize central reference rootjQuery = jQuery( document ); var rparentsprev = /^(?:parents|prev(?:Until|All))/, // methods guaranteed to produce a unique set when starting from a unique set guaranteedUnique = { children: true, contents: true, next: true, prev: true }; jQuery.extend({ dir: function( elem, dir, until ) { var matched = [], cur = elem[ dir ]; while ( cur &amp;&amp; cur.nodeType !== 9 &amp;&amp; (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) { if ( cur.nodeType === 1 ) { matched.push( cur ); } cur = cur[dir]; } return matched; }, sibling: function( n, elem ) { var r = []; for ( ; n; n = n.nextSibling ) { if ( n.nodeType === 1 &amp;&amp; n !== elem ) { r.push( n ); } } return r; } }); jQuery.fn.extend({ has: function( target ) { var i, targets = jQuery( target, this ), len = targets.length; return this.filter(function() { for ( i = 0; i &lt; len; i++ ) { if ( jQuery.contains( this, targets[i] ) ) { return true; } } }); }, closest: function( selectors, context ) { var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test( selectors ) || typeof selectors !== &quot;string&quot; ? jQuery( selectors, context || this.context ) : 0; for ( ; i &lt; l; i++ ) { for ( cur = this[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) { // Always skip document fragments if ( cur.nodeType &lt; 11 &amp;&amp; (pos ? pos.index(cur) &gt; -1 : // Don&apos;t pass non-elements to Sizzle cur.nodeType === 1 &amp;&amp; jQuery.find.matchesSelector(cur, selectors)) ) { matched.push( cur ); break; } } } return this.pushStack( matched.length &gt; 1 ? jQuery.unique( matched ) : matched ); }, // Determine the position of an element within // the matched set of elements index: function( elem ) { // No argument, return index in parent if ( !elem ) { return ( this[0] &amp;&amp; this[0].parentNode ) ? this.first().prevAll().length : -1; } // index in selector if ( typeof elem === &quot;string&quot; ) { return jQuery.inArray( this[0], jQuery( elem ) ); } // Locate the position of the desired element return jQuery.inArray( // If it receives a jQuery object, the first element is used elem.jquery ? elem[0] : elem, this ); }, add: function( selector, context ) { return this.pushStack( jQuery.unique( jQuery.merge( this.get(), jQuery( selector, context ) ) ) ); }, addBack: function( selector ) { return this.add( selector == null ? this.prevObject : this.prevObject.filter(selector) ); } }); function sibling( cur, dir ) { do { cur = cur[ dir ]; } while ( cur &amp;&amp; cur.nodeType !== 1 ); return cur; } jQuery.each({ parent: function( elem ) { var parent = elem.parentNode; return parent &amp;&amp; parent.nodeType !== 11 ? parent : null; }, parents: function( elem ) { return jQuery.dir( elem, &quot;parentNode&quot; ); }, parentsUntil: function( elem, i, until ) { return jQuery.dir( elem, &quot;parentNode&quot;, until ); }, next: function( elem ) { return sibling( elem, &quot;nextSibling&quot; ); }, prev: function( elem ) { return sibling( elem, &quot;previousSibling&quot; ); }, nextAll: function( elem ) { return jQuery.dir( elem, &quot;nextSibling&quot; ); }, prevAll: function( elem ) { return jQuery.dir( elem, &quot;previousSibling&quot; ); }, nextUntil: function( elem, i, until ) { return jQuery.dir( elem, &quot;nextSibling&quot;, until ); }, prevUntil: function( elem, i, until ) { return jQuery.dir( elem, &quot;previousSibling&quot;, until ); }, siblings: function( elem ) { return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem ); }, children: function( elem ) { return jQuery.sibling( elem.firstChild ); }, contents: function( elem ) { return jQuery.nodeName( elem, &quot;iframe&quot; ) ? elem.contentDocument || elem.contentWindow.document : jQuery.merge( [], elem.childNodes ); } }, function( name, fn ) { jQuery.fn[ name ] = function( until, selector ) { var ret = jQuery.map( this, fn, until ); if ( name.slice( -5 ) !== &quot;Until&quot; ) { selector = until; } if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) { ret = jQuery.filter( selector, ret ); } if ( this.length &gt; 1 ) { // Remove duplicates if ( !guaranteedUnique[ name ] ) { ret = jQuery.unique( ret ); } // Reverse order for parents* and prev-derivatives if ( rparentsprev.test( name ) ) { ret = ret.reverse(); } } return this.pushStack( ret ); }; }); var rnotwhite = (/\S+/g); // String to Object options format cache var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache function createOptions( options ) { var object = optionsCache[ options ] = {}; jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) { object[ flag ] = true; }); return object; } /* * Create a callback list using the following parameters: * * options: an optional list of space-separated options that will change how * the callback list behaves or a more traditional option object * * By default a callback list will act like an event callback list and can be * &quot;fired&quot; multiple times. * * Possible options: * * once: will ensure the callback list can only be fired once (like a Deferred) * * memory: will keep track of previous values and will call any callback added * after the list has been fired right away with the latest &quot;memorized&quot; * values (like a Deferred) * * unique: will ensure a callback can only be added once (no duplicate in the list) * * stopOnFalse: interrupt callings when a callback returns false * */ jQuery.Callbacks = function( options ) { // Convert options from String-formatted to Object-formatted if needed // (we check in cache first) options = typeof options === &quot;string&quot; ? ( optionsCache[ options ] || createOptions( options ) ) : jQuery.extend( {}, options ); var // Flag to know if list is currently firing firing, // Last fire value (for non-forgettable lists) memory, // Flag to know if list was already fired fired, // End of the loop when firing firingLength, // Index of currently firing callback (modified by remove if needed) firingIndex, // First callback to fire (used internally by add and fireWith) firingStart, // Actual callback list list = [], // Stack of fire calls for repeatable lists stack = !options.once &amp;&amp; [], // Fire callbacks fire = function( data ) { memory = options.memory &amp;&amp; data; fired = true; firingIndex = firingStart || 0; firingStart = 0; firingLength = list.length; firing = true; for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) { if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) { memory = false; // To prevent further calls using add break; } } firing = false; if ( list ) { if ( stack ) { if ( stack.length ) { fire( stack.shift() ); } } else if ( memory ) { list = []; } else { self.disable(); } } }, // Actual Callbacks object self = { // Add a callback or a collection of callbacks to the list add: function() { if ( list ) { // First, we save the current length var start = list.length; (function add( args ) { jQuery.each( args, function( _, arg ) { var type = jQuery.type( arg ); if ( type === &quot;function&quot; ) { if ( !options.unique || !self.has( arg ) ) { list.push( arg ); } } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) { // Inspect recursively add( arg ); } }); })( arguments ); // Do we need to add the callbacks to the // current firing batch? if ( firing ) { firingLength = list.length; // With memory, if we&apos;re not firing then // we should call right away } else if ( memory ) { firingStart = start; fire( memory ); } } return this; }, // Remove a callback from the list remove: function() { if ( list ) { jQuery.each( arguments, function( _, arg ) { var index; while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) { list.splice( index, 1 ); // Handle firing indexes if ( firing ) { if ( index &lt;= firingLength ) { firingLength--; } if ( index &lt;= firingIndex ) { firingIndex--; } } } }); } return this; }, // Check if a given callback is in the list. // If no argument is given, return whether or not list has callbacks attached. has: function( fn ) { return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length ); }, // Remove all callbacks from the list empty: function() { list = []; firingLength = 0; return this; }, // Have the list do nothing anymore disable: function() { list = stack = memory = undefined; return this; }, // Is it disabled? disabled: function() { return !list; }, // Lock the list in its current state lock: function() { stack = undefined; if ( !memory ) { self.disable(); } return this; }, // Is it locked? locked: function() { return !stack; }, // Call all callbacks with the given context and arguments fireWith: function( context, args ) { if ( list &amp;&amp; ( !fired || stack ) ) { args = args || []; args = [ context, args.slice ? args.slice() : args ]; if ( firing ) { stack.push( args ); } else { fire( args ); } } return this; }, // Call all the callbacks with the given arguments fire: function() { self.fireWith( this, arguments ); return this; }, // To know if the callbacks have already been called at least once fired: function() { return !!fired; } }; return self; }; jQuery.extend({ Deferred: function( func ) { var tuples = [ // action, add listener, listener list, final state [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ], [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ], [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ] ], state = &quot;pending&quot;, promise = { state: function() { return state; }, always: function() { deferred.done( arguments ).fail( arguments ); return this; }, then: function( /* fnDone, fnFail, fnProgress */ ) { var fns = arguments; return jQuery.Deferred(function( newDefer ) { jQuery.each( tuples, function( i, tuple ) { var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ]; // deferred[ done | fail | progress ] for forwarding actions to newDefer deferred[ tuple[1] ](function() { var returned = fn &amp;&amp; fn.apply( this, arguments ); if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) { returned.promise() .done( newDefer.resolve ) .fail( newDefer.reject ) .progress( newDefer.notify ); } else { newDefer[ tuple[ 0 ] + &quot;With&quot; ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments ); } }); }); fns = null; }).promise(); }, // Get a promise for this deferred // If obj is provided, the promise aspect is added to the object promise: function( obj ) { return obj != null ? jQuery.extend( obj, promise ) : promise; } }, deferred = {}; // Keep pipe for back-compat promise.pipe = promise.then; // Add list-specific methods jQuery.each( tuples, function( i, tuple ) { var list = tuple[ 2 ], stateString = tuple[ 3 ]; // promise[ done | fail | progress ] = list.add promise[ tuple[1] ] = list.add; // Handle state if ( stateString ) { list.add(function() { // state = [ resolved | rejected ] state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock ); } // deferred[ resolve | reject | notify ] deferred[ tuple[0] ] = function() { deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments ); return this; }; deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith; }); // Make the deferred a promise promise.promise( deferred ); // Call given func if any if ( func ) { func.call( deferred, deferred ); } // All done! return deferred; }, // Deferred helper when: function( subordinate /* , ..., subordinateN */ ) { var i = 0, resolveValues = slice.call( arguments ), length = resolveValues.length, // the count of uncompleted subordinates remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that. deferred = remaining === 1 ? subordinate : jQuery.Deferred(), // Update function for both resolve and progress values updateFunc = function( i, contexts, values ) { return function( value ) { contexts[ i ] = this; values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value; if ( values === progressValues ) { deferred.notifyWith( contexts, values ); } else if ( !(--remaining) ) { deferred.resolveWith( contexts, values ); } }; }, progressValues, progressContexts, resolveContexts; // add listeners to Deferred subordinates; treat others as resolved if ( length &gt; 1 ) { progressValues = new Array( length ); progressContexts = new Array( length ); resolveContexts = new Array( length ); for ( ; i &lt; length; i++ ) { if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) { resolveValues[ i ].promise() .done( updateFunc( i, resolveContexts, resolveValues ) ) .fail( deferred.reject ) .progress( updateFunc( i, progressContexts, progressValues ) ); } else { --remaining; } } } // if we&apos;re not waiting on anything, resolve the master if ( !remaining ) { deferred.resolveWith( resolveContexts, resolveValues ); } return deferred.promise(); } }); // The deferred used on DOM ready var readyList; jQuery.fn.ready = function( fn ) { // Add the callback jQuery.ready.promise().done( fn ); return this; }; jQuery.extend({ // Is the DOM ready to be used? Set to true once it occurs. isReady: false, // A counter to track how many items to wait for before // the ready event fires. See #6781 readyWait: 1, // Hold (or release) the ready event holdReady: function( hold ) { if ( hold ) { jQuery.readyWait++; } else { jQuery.ready( true ); } }, // Handle when the DOM is ready ready: function( wait ) { // Abort if there are pending holds or we&apos;re already ready if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) { return; } // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443). if ( !document.body ) { return setTimeout( jQuery.ready ); } // Remember that the DOM is ready jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) { return; } // If there are functions bound, to execute readyList.resolveWith( document, [ jQuery ] ); // Trigger any bound ready events if ( jQuery.fn.triggerHandler ) { jQuery( document ).triggerHandler( &quot;ready&quot; ); jQuery( document ).off( &quot;ready&quot; ); } } }); /** * Clean-up method for dom ready events */ function detach() { if ( document.addEventListener ) { document.removeEventListener( &quot;DOMContentLoaded&quot;, completed, false ); window.removeEventListener( &quot;load&quot;, completed, false ); } else { document.detachEvent( &quot;onreadystatechange&quot;, completed ); window.detachEvent( &quot;onload&quot;, completed ); } } /** * The ready event handler and self cleanup method */ function completed() { // readyState === &quot;complete&quot; is good enough for us to call the dom ready in oldIE if ( document.addEventListener || event.type === &quot;load&quot; || document.readyState === &quot;complete&quot; ) { detach(); jQuery.ready(); } } jQuery.ready.promise = function( obj ) { if ( !readyList ) { readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred. // we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15 if ( document.readyState === &quot;complete&quot; ) { // Handle it asynchronously to allow scripts the opportunity to delay ready setTimeout( jQuery.ready ); // Standards-based browsers support DOMContentLoaded } else if ( document.addEventListener ) { // Use the handy event callback document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false ); // A fallback to window.onload, that will always work window.addEventListener( &quot;load&quot;, completed, false ); // If IE event model is used } else { // Ensure firing before onload, maybe late but safe also for iframes document.attachEvent( &quot;onreadystatechange&quot;, completed ); // A fallback to window.onload, that will always work window.attachEvent( &quot;onload&quot;, completed ); // If IE and not a frame // continually check to see if the document is ready var top = false; try { top = window.frameElement == null &amp;&amp; document.documentElement; } catch(e) {} if ( top &amp;&amp; top.doScroll ) { (function doScrollCheck() { if ( !jQuery.isReady ) { try { // Use the trick by Diego Perini // http://javascript.nwbox.com/IEContentLoaded/ top.doScroll(&quot;left&quot;); } catch(e) { return setTimeout( doScrollCheck, 50 ); } // detach all dom ready events detach(); // and execute any waiting functions jQuery.ready(); } })(); } } } return readyList.promise( obj ); }; var strundefined = typeof undefined; // Support: IE&lt;9 // Iteration over object&apos;s inherited properties before its own var i; for ( i in jQuery( support ) ) { break; } support.ownLast = i !== &quot;0&quot;; // Note: most support tests are defined in their respective modules. // false until the test is run support.inlineBlockNeedsLayout = false; // Execute ASAP in case we need to set body.style.zoom jQuery(function() { // Minified: var a,b,c,d var val, div, body, container; body = document.getElementsByTagName( &quot;body&quot; )[ 0 ]; if ( !body || !body.style ) { // Return for frameset docs that don&apos;t have a body return; } // Setup div = document.createElement( &quot;div&quot; ); container = document.createElement( &quot;div&quot; ); container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;; body.appendChild( container ).appendChild( div ); if ( typeof div.style.zoom !== strundefined ) { // Support: IE&lt;8 // Check if natively block-level elements act like inline-block // elements when setting their display to &apos;inline&apos; and giving // them layout div.style.cssText = &quot;display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1&quot;; support.inlineBlockNeedsLayout = val = div.offsetWidth === 3; if ( val ) { // Prevent IE 6 from affecting layout for positioned elements #11048 // Prevent IE from shrinking the body in IE 7 mode #12869 // Support: IE&lt;8 body.style.zoom = 1; } } body.removeChild( container ); }); (function() { var div = document.createElement( &quot;div&quot; ); // Execute the test only if not already executed in another module. if (support.deleteExpando == null) { // Support: IE&lt;9 support.deleteExpando = true; try { delete div.test; } catch( e ) { support.deleteExpando = false; } } // Null elements to avoid leaks in IE. div = null; })(); /** * Determines whether an object can have data */ jQuery.acceptData = function( elem ) { var noData = jQuery.noData[ (elem.nodeName + &quot; &quot;).toLowerCase() ], nodeType = +elem.nodeType || 1; // Do not set data on non-element DOM nodes because it will not be cleared (#8335). return nodeType !== 1 &amp;&amp; nodeType !== 9 ? false : // Nodes accept data unless otherwise specified; rejection can be conditional !noData || noData !== true &amp;&amp; elem.getAttribute(&quot;classid&quot;) === noData; }; var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g; function dataAttr( elem, key, data ) { // If nothing was found internally, try to fetch any // data from the HTML5 data-* attribute if ( data === undefined &amp;&amp; elem.nodeType === 1 ) { var name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase(); data = elem.getAttribute( name ); if ( typeof data === &quot;string&quot; ) { try { data = data === &quot;true&quot; ? true : data === &quot;false&quot; ? false : data === &quot;null&quot; ? null : // Only convert to a number if it doesn&apos;t change the string +data + &quot;&quot; === data ? +data : rbrace.test( data ) ? jQuery.parseJSON( data ) : data; } catch( e ) {} // Make sure we set the data so it isn&apos;t changed later jQuery.data( elem, key, data ); } else { data = undefined; } } return data; } // checks a cache object for emptiness function isEmptyDataObject( obj ) { var name; for ( name in obj ) { // if the public data object is empty, the private is still empty if ( name === &quot;data&quot; &amp;&amp; jQuery.isEmptyObject( obj[name] ) ) { continue; } if ( name !== &quot;toJSON&quot; ) { return false; } } return true; } function internalData( elem, name, data, pvt /* Internal Use Only */ ) { if ( !jQuery.acceptData( elem ) ) { return; } var ret, thisCache, internalKey = jQuery.expando, // We have to handle DOM nodes and JS objects differently because IE6-7 // can&apos;t GC object references properly across the DOM-JS boundary isNode = elem.nodeType, // Only DOM nodes need the global jQuery cache; JS object data is // attached directly to the object so GC can occur automatically cache = isNode ? jQuery.cache : elem, // Only defining an ID for JS objects if its cache already exists allows // the code to shortcut on the same path as a DOM node with no cache id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey; // Avoid doing any more work than we need to when trying to get data on an // object that has no data at all if ( (!id || !cache[id] || (!pvt &amp;&amp; !cache[id].data)) &amp;&amp; data === undefined &amp;&amp; typeof name === &quot;string&quot; ) { return; } if ( !id ) { // Only DOM nodes need a new unique ID for each element since their data // ends up in the global cache if ( isNode ) { id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++; } else { id = internalKey; } } if ( !cache[ id ] ) { // Avoid exposing jQuery metadata on plain JS objects when the object // is serialized using JSON.stringify cache[ id ] = isNode ? {} : { toJSON: jQuery.noop }; } // An object can be passed to jQuery.data instead of a key/value pair; this gets // shallow copied over onto the existing cache if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) { if ( pvt ) { cache[ id ] = jQuery.extend( cache[ id ], name ); } else { cache[ id ].data = jQuery.extend( cache[ id ].data, name ); } } thisCache = cache[ id ]; // jQuery data() is stored in a separate object inside the object&apos;s internal data // cache in order to avoid key collisions between internal data and user-defined // data. if ( !pvt ) { if ( !thisCache.data ) { thisCache.data = {}; } thisCache = thisCache.data; } if ( data !== undefined ) { thisCache[ jQuery.camelCase( name ) ] = data; } // Check for both converted-to-camel and non-converted data property names // If a data property was specified if ( typeof name === &quot;string&quot; ) { // First Try to find as-is property data ret = thisCache[ name ]; // Test for null|undefined property data if ( ret == null ) { // Try to find the camelCased property ret = thisCache[ jQuery.camelCase( name ) ]; } } else { ret = thisCache; } return ret; } function internalRemoveData( elem, name, pvt ) { if ( !jQuery.acceptData( elem ) ) { return; } var thisCache, i, isNode = elem.nodeType, // See jQuery.data for more information cache = isNode ? jQuery.cache : elem, id = isNode ? elem[ jQuery.expando ] : jQuery.expando; // If there is already no cache entry for this object, there is no // purpose in continuing if ( !cache[ id ] ) { return; } if ( name ) { thisCache = pvt ? cache[ id ] : cache[ id ].data; if ( thisCache ) { // Support array or space separated string names for data keys if ( !jQuery.isArray( name ) ) { // try the string as a key before any manipulation if ( name in thisCache ) { name = [ name ]; } else { // split the camel cased version by spaces unless a key with the spaces exists name = jQuery.camelCase( name ); if ( name in thisCache ) { name = [ name ]; } else { name = name.split(&quot; &quot;); } } } else { // If &quot;name&quot; is an array of keys... // When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature, // keys will be converted to camelCase. // Since there is no way to tell _how_ a key was added, remove // both plain key and camelCase key. #12786 // This will only penalize the array argument path. name = name.concat( jQuery.map( name, jQuery.camelCase ) ); } i = name.length; while ( i-- ) { delete thisCache[ name[i] ]; } // If there is no data left in the cache, we want to continue // and let the cache object itself get destroyed if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) { return; } } } // See jQuery.data for more information if ( !pvt ) { delete cache[ id ].data; // Don&apos;t destroy the parent cache unless the internal data object // had been the only thing left in it if ( !isEmptyDataObject( cache[ id ] ) ) { return; } } // Destroy the cache if ( isNode ) { jQuery.cleanData( [ elem ], true ); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080) /* jshint eqeqeq: false */ } else if ( support.deleteExpando || cache != cache.window ) { /* jshint eqeqeq: true */ delete cache[ id ]; // When all else fails, null } else { cache[ id ] = null; } } jQuery.extend({ cache: {}, // The following elements (space-suffixed to avoid Object.prototype collisions) // throw uncatchable exceptions if you attempt to set expando properties noData: { &quot;applet &quot;: true, &quot;embed &quot;: true, // ...but Flash objects (which have this classid) *can* handle expandos &quot;object &quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot; }, hasData: function( elem ) { elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ]; return !!elem &amp;&amp; !isEmptyDataObject( elem ); }, data: function( elem, name, data ) { return internalData( elem, name, data ); }, removeData: function( elem, name ) { return internalRemoveData( elem, name ); }, // For internal use only. _data: function( elem, name, data ) { return internalData( elem, name, data, true ); }, _removeData: function( elem, name ) { return internalRemoveData( elem, name, true ); } }); jQuery.fn.extend({ data: function( key, value ) { var i, name, data, elem = this[0], attrs = elem &amp;&amp; elem.attributes; // Special expections of .data basically thwart jQuery.access, // so implement the relevant behavior ourselves // Gets all values if ( key === undefined ) { if ( this.length ) { data = jQuery.data( elem ); if ( elem.nodeType === 1 &amp;&amp; !jQuery._data( elem, &quot;parsedAttrs&quot; ) ) { i = attrs.length; while ( i-- ) { // Support: IE11+ // The attrs elements can be null (#14894) if ( attrs[ i ] ) { name = attrs[ i ].name; if ( name.indexOf( &quot;data-&quot; ) === 0 ) { name = jQuery.camelCase( name.slice(5) ); dataAttr( elem, name, data[ name ] ); } } } jQuery._data( elem, &quot;parsedAttrs&quot;, true ); } } return data; } // Sets multiple values if ( typeof key === &quot;object&quot; ) { return this.each(function() { jQuery.data( this, key ); }); } return arguments.length &gt; 1 ? // Sets one value this.each(function() { jQuery.data( this, key, value ); }) : // Gets one value // Try to fetch any internally stored data first elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined; }, removeData: function( key ) { return this.each(function() { jQuery.removeData( this, key ); }); } }); jQuery.extend({ queue: function( elem, type, data ) { var queue; if ( elem ) { type = ( type || &quot;fx&quot; ) + &quot;queue&quot;; queue = jQuery._data( elem, type ); // Speed up dequeue by getting out quickly if this is just a lookup if ( data ) { if ( !queue || jQuery.isArray(data) ) { queue = jQuery._data( elem, type, jQuery.makeArray(data) ); } else { queue.push( data ); } } return queue || []; } }, dequeue: function( elem, type ) { type = type || &quot;fx&quot;; var queue = jQuery.queue( elem, type ), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks( elem, type ), next = function() { jQuery.dequeue( elem, type ); }; // If the fx queue is dequeued, always remove the progress sentinel if ( fn === &quot;inprogress&quot; ) { fn = queue.shift(); startLength--; } if ( fn ) { // Add a progress sentinel to prevent the fx queue from being // automatically dequeued if ( type === &quot;fx&quot; ) { queue.unshift( &quot;inprogress&quot; ); } // clear up the last queue stop function delete hooks.stop; fn.call( elem, next, hooks ); } if ( !startLength &amp;&amp; hooks ) { hooks.empty.fire(); } }, // not intended for public consumption - generates a queueHooks object, or returns the current one _queueHooks: function( elem, type ) { var key = type + &quot;queueHooks&quot;; return jQuery._data( elem, key ) || jQuery._data( elem, key, { empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() { jQuery._removeData( elem, type + &quot;queue&quot; ); jQuery._removeData( elem, key ); }) }); } }); jQuery.fn.extend({ queue: function( type, data ) { var setter = 2; if ( typeof type !== &quot;string&quot; ) { data = type; type = &quot;fx&quot;; setter--; } if ( arguments.length &lt; setter ) { return jQuery.queue( this[0], type ); } return data === undefined ? this : this.each(function() { var queue = jQuery.queue( this, type, data ); // ensure a hooks for this queue jQuery._queueHooks( this, type ); if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) { jQuery.dequeue( this, type ); } }); }, dequeue: function( type ) { return this.each(function() { jQuery.dequeue( this, type ); }); }, clearQueue: function( type ) { return this.queue( type || &quot;fx&quot;, [] ); }, // Get a promise resolved when queues of a certain type // are emptied (fx is the type by default) promise: function( type, obj ) { var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() { if ( !( --count ) ) { defer.resolveWith( elements, [ elements ] ); } }; if ( typeof type !== &quot;string&quot; ) { obj = type; type = undefined; } type = type || &quot;fx&quot;; while ( i-- ) { tmp = jQuery._data( elements[ i ], type + &quot;queueHooks&quot; ); if ( tmp &amp;&amp; tmp.empty ) { count++; tmp.empty.add( resolve ); } } resolve(); return defer.promise( obj ); } }); var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source; var cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ]; var isHidden = function( elem, el ) { // isHidden might be called from jQuery#filter function; // in that case, element will be second argument elem = el || elem; return jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot; || !jQuery.contains( elem.ownerDocument, elem ); }; // Multifunctional method to get and set values of a collection // The value/s can optionally be executed if it&apos;s a function var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) { var i = 0, length = elems.length, bulk = key == null; // Sets many values if ( jQuery.type( key ) === &quot;object&quot; ) { chainable = true; for ( i in key ) { jQuery.access( elems, fn, i, key[i], true, emptyGet, raw ); } // Sets one value } else if ( value !== undefined ) { chainable = true; if ( !jQuery.isFunction( value ) ) { raw = true; } if ( bulk ) { // Bulk operations run against the entire set if ( raw ) { fn.call( elems, value ); fn = null; // ...except when executing function values } else { bulk = fn; fn = function( elem, key, value ) { return bulk.call( jQuery( elem ), value ); }; } } if ( fn ) { for ( ; i &lt; length; i++ ) { fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) ); } } } return chainable ? elems : // Gets bulk ? fn.call( elems ) : length ? fn( elems[0], key ) : emptyGet; }; var rcheckableType = (/^(?:checkbox|radio)$/i); (function() { // Minified: var a,b,c var input = document.createElement( &quot;input&quot; ), div = document.createElement( &quot;div&quot; ), fragment = document.createDocumentFragment(); // Setup div.innerHTML = &quot; &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&apos;/a&apos;&gt;a&lt;/a&gt;&lt;input type=&apos;checkbox&apos;/&gt;&quot;; // IE strips leading whitespace when .innerHTML is used support.leadingWhitespace = div.firstChild.nodeType === 3; // Make sure that tbody elements aren&apos;t automatically inserted // IE will insert them into empty tables support.tbody = !div.getElementsByTagName( &quot;tbody&quot; ).length; // Make sure that link elements get serialized correctly by innerHTML // This requires a wrapper element in IE support.htmlSerialize = !!div.getElementsByTagName( &quot;link&quot; ).length; // Makes sure cloning an html5 element does not cause problems // Where outerHTML is undefined, this still works support.html5Clone = document.createElement( &quot;nav&quot; ).cloneNode( true ).outerHTML !== &quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;; // Check if a disconnected checkbox will retain its checked // value of true after appended to the DOM (IE6/7) input.type = &quot;checkbox&quot;; input.checked = true; fragment.appendChild( input ); support.appendChecked = input.checked; // Make sure textarea (and checkbox) defaultValue is properly cloned // Support: IE6-IE11+ div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;; support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue; // #11217 - WebKit loses check when the name is after the checked attribute fragment.appendChild( div ); div.innerHTML = &quot;&lt;input type=&apos;radio&apos; checked=&apos;checked&apos; name=&apos;t&apos;/&gt;&quot;; // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3 // old WebKit doesn&apos;t clone checked state correctly in fragments support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked; // Support: IE&lt;9 // Opera does not clone events (and typeof div.attachEvent === undefined). // IE9-10 clones events bound via attachEvent, but they don&apos;t trigger with .click() support.noCloneEvent = true; if ( div.attachEvent ) { div.attachEvent( &quot;onclick&quot;, function() { support.noCloneEvent = false; }); div.cloneNode( true ).click(); } // Execute the test only if not already executed in another module. if (support.deleteExpando == null) { // Support: IE&lt;9 support.deleteExpando = true; try { delete div.test; } catch( e ) { support.deleteExpando = false; } } })(); (function() { var i, eventName, div = document.createElement( &quot;div&quot; ); // Support: IE&lt;9 (lack submit/change bubble), Firefox 23+ (lack focusin event) for ( i in { submit: true, change: true, focusin: true }) { eventName = &quot;on&quot; + i; if ( !(support[ i + &quot;Bubbles&quot; ] = eventName in window) ) { // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP) div.setAttribute( eventName, &quot;t&quot; ); support[ i + &quot;Bubbles&quot; ] = div.attributes[ eventName ].expando === false; } } // Null elements to avoid leaks in IE. div = null; })(); var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/; function returnTrue() { return true; } function returnFalse() { return false; } function safeActiveElement() { try { return document.activeElement; } catch ( err ) { } } /* * Helper functions for managing events -- not part of the public interface. * Props to Dean Edwards&apos; addEvent library for many of the ideas. */ jQuery.event = { global: {}, add: function( elem, types, handler, data, selector ) { var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data( elem ); // Don&apos;t attach events to noData or text/comment nodes (but allow plain objects) if ( !elemData ) { return; } // Caller can pass in an object of custom data in lieu of the handler if ( handler.handler ) { handleObjIn = handler; handler = handleObjIn.handler; selector = handleObjIn.selector; } // Make sure that the handler has a unique ID, used to find/remove it later if ( !handler.guid ) { handler.guid = jQuery.guid++; } // Init the element&apos;s event structure and main handler, if this is the first if ( !(events = elemData.events) ) { events = elemData.events = {}; } if ( !(eventHandle = elemData.handle) ) { eventHandle = elemData.handle = function( e ) { // Discard the second event of a jQuery.event.trigger() and // when an event is called after a page has unloaded return typeof jQuery !== strundefined &amp;&amp; (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply( eventHandle.elem, arguments ) : undefined; }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events eventHandle.elem = elem; } // Handle multiple events separated by a space types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ]; t = types.length; while ( t-- ) { tmp = rtypenamespace.exec( types[t] ) || []; type = origType = tmp[1]; namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort(); // There *must* be a type, no attaching namespace-only handlers if ( !type ) { continue; } // If event changes its type, use the special event handlers for the changed type special = jQuery.event.special[ type ] || {}; // If selector defined, determine special event api type, otherwise given type type = ( selector ? special.delegateType : special.bindType ) || type; // Update special based on newly reset type special = jQuery.event.special[ type ] || {}; // handleObj is passed to all event handlers handleObj = jQuery.extend({ type: type, origType: origType, data: data, handler: handler, guid: handler.guid, selector: selector, needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ), namespace: namespaces.join(&quot;.&quot;) }, handleObjIn ); // Init the event handler queue if we&apos;re the first if ( !(handlers = events[ type ]) ) { handlers = events[ type ] = []; handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) { // Bind the global event handler to the element if ( elem.addEventListener ) { elem.addEventListener( type, eventHandle, false ); } else if ( elem.attachEvent ) { elem.attachEvent( &quot;on&quot; + type, eventHandle ); } } } if ( special.add ) { special.add.call( elem, handleObj ); if ( !handleObj.handler.guid ) { handleObj.handler.guid = handler.guid; } } // Add to the element&apos;s handler list, delegates in front if ( selector ) { handlers.splice( handlers.delegateCount++, 0, handleObj ); } else { handlers.push( handleObj ); } // Keep track of which events have ever been used, for event optimization jQuery.event.global[ type ] = true; } // Nullify elem to prevent memory leaks in IE elem = null; }, // Detach an event or set of events from an element remove: function( elem, types, handler, selector, mappedTypes ) { var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem ); if ( !elemData || !(events = elemData.events) ) { return; } // Once for each type.namespace in types; type may be omitted types = ( types || &quot;&quot; ).match( rnotwhite ) || [ &quot;&quot; ]; t = types.length; while ( t-- ) { tmp = rtypenamespace.exec( types[t] ) || []; type = origType = tmp[1]; namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort(); // Unbind all events (on this namespace, if provided) for the element if ( !type ) { for ( type in events ) { jQuery.event.remove( elem, type + types[ t ], handler, selector, true ); } continue; } special = jQuery.event.special[ type ] || {}; type = ( selector ? special.delegateType : special.bindType ) || type; handlers = events[ type ] || []; tmp = tmp[2] &amp;&amp; new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; ); // Remove matching events origCount = j = handlers.length; while ( j-- ) { handleObj = handlers[ j ]; if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp; ( !handler || handler.guid === handleObj.guid ) &amp;&amp; ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp; ( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) { handlers.splice( j, 1 ); if ( handleObj.selector ) { handlers.delegateCount--; } if ( special.remove ) { special.remove.call( elem, handleObj ); } } } // Remove generic event handler if we removed something and no more handlers exist // (avoids potential for endless recursion during removal of special event handlers) if ( origCount &amp;&amp; !handlers.length ) { if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) { jQuery.removeEvent( elem, type, elemData.handle ); } delete events[ type ]; } } // Remove the expando if it&apos;s no longer used if ( jQuery.isEmptyObject( events ) ) { delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty // so use it instead of delete jQuery._removeData( elem, &quot;events&quot; ); } }, trigger: function( event, data, elem, onlyHandlers ) { var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [ elem || document ], type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event, namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split(&quot;.&quot;) : []; cur = tmp = elem = elem || document; // Don&apos;t do events on text and comment nodes if ( elem.nodeType === 3 || elem.nodeType === 8 ) { return; } // focus/blur morphs to focusin/out; ensure we&apos;re not firing them right now if ( rfocusMorph.test( type + jQuery.event.triggered ) ) { return; } if ( type.indexOf(&quot;.&quot;) &gt;= 0 ) { // Namespaced trigger; create a regexp to match event type in handle() namespaces = type.split(&quot;.&quot;); type = namespaces.shift(); namespaces.sort(); } ontype = type.indexOf(&quot;:&quot;) &lt; 0 &amp;&amp; &quot;on&quot; + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string event = event[ jQuery.expando ] ? event : new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event ); // Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true) event.isTrigger = onlyHandlers ? 2 : 3; event.namespace = namespaces.join(&quot;.&quot;); event.namespace_re = event.namespace ? new RegExp( &quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot; ) : null; // Clean up the event in case it is being reused event.result = undefined; if ( !event.target ) { event.target = elem; } // Clone any incoming data and prepend the event, creating the handler arg list data = data == null ? [ event ] : jQuery.makeArray( data, [ event ] ); // Allow special events to draw outside the lines special = jQuery.event.special[ type ] || {}; if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) { return; } // Determine event propagation path in advance, per W3C events spec (#9951) // Bubble up to document, then to window; watch for a global ownerDocument var (#9724) if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) { bubbleType = special.delegateType || type; if ( !rfocusMorph.test( bubbleType + type ) ) { cur = cur.parentNode; } for ( ; cur; cur = cur.parentNode ) { eventPath.push( cur ); tmp = cur; } // Only add window if we got to document (e.g., not plain obj or detached DOM) if ( tmp === (elem.ownerDocument || document) ) { eventPath.push( tmp.defaultView || tmp.parentWindow || window ); } } // Fire handlers on the event path i = 0; while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) { event.type = i &gt; 1 ? bubbleType : special.bindType || type; // jQuery handler handle = ( jQuery._data( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; jQuery._data( cur, &quot;handle&quot; ); if ( handle ) { handle.apply( cur, data ); } // Native handler handle = ontype &amp;&amp; cur[ ontype ]; if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) { event.result = handle.apply( cur, data ); if ( event.result === false ) { event.preventDefault(); } } } event.type = type; // If nobody prevented the default action, do it now if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) { if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp; jQuery.acceptData( elem ) ) { // Call a native DOM method on the target with the same name name as the event. // Can&apos;t use an .isFunction() check here because IE6/7 fails that test. // Don&apos;t do default actions on window, that&apos;s where global variables be (#6170) if ( ontype &amp;&amp; elem[ type ] &amp;&amp; !jQuery.isWindow( elem ) ) { // Don&apos;t re-trigger an onFOO event when we call its FOO() method tmp = elem[ ontype ]; if ( tmp ) { elem[ ontype ] = null; } // Prevent re-triggering of the same event, since we already bubbled it above jQuery.event.triggered = type; try { elem[ type ](); } catch ( e ) { // IE&lt;9 dies on focus/blur to hidden element (#1486,#12518) // only reproducible on winXP IE8 native, not IE9 in IE8 mode } jQuery.event.triggered = undefined; if ( tmp ) { elem[ ontype ] = tmp; } } } } return event.result; }, dispatch: function( event ) { // Make a writable jQuery.Event from the native event object event = jQuery.event.fix( event ); var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call( arguments ), handlers = ( jQuery._data( this, &quot;events&quot; ) || {} )[ event.type ] || [], special = jQuery.event.special[ event.type ] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event args[0] = event; event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) { return; } // Determine handlers handlerQueue = jQuery.event.handlers.call( this, event, handlers ); // Run delegates first; they may want to stop propagation beneath us i = 0; while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) { event.currentTarget = matched.elem; j = 0; while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) { // Triggered event must either 1) have no namespace, or // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace). if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) { event.handleObj = handleObj; event.data = handleObj.data; ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler ) .apply( matched.elem, args ); if ( ret !== undefined ) { if ( (event.result = ret) === false ) { event.preventDefault(); event.stopPropagation(); } } } } } // Call the postDispatch hook for the mapped type if ( special.postDispatch ) { special.postDispatch.call( this, event ); } return event.result; }, handlers: function( event, handlers ) { var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target; // Find delegate handlers // Black-hole SVG &lt;use&gt; instance trees (#13180) // Avoid non-left-click bubbling in Firefox (#3861) if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== &quot;click&quot;) ) { /* jshint eqeqeq: false */ for ( ; cur != this; cur = cur.parentNode || this ) { /* jshint eqeqeq: true */ // Don&apos;t check non-elements (#13208) // Don&apos;t process clicks on disabled elements (#6911, #8165, #11382, #11764) if ( cur.nodeType === 1 &amp;&amp; (cur.disabled !== true || event.type !== &quot;click&quot;) ) { matches = []; for ( i = 0; i &lt; delegateCount; i++ ) { handleObj = handlers[ i ]; // Don&apos;t conflict with Object.prototype properties (#13203) sel = handleObj.selector + &quot; &quot;; if ( matches[ sel ] === undefined ) { matches[ sel ] = handleObj.needsContext ? jQuery( sel, this ).index( cur ) &gt;= 0 : jQuery.find( sel, this, null, [ cur ] ).length; } if ( matches[ sel ] ) { matches.push( handleObj ); } } if ( matches.length ) { handlerQueue.push({ elem: cur, handlers: matches }); } } } } // Add the remaining (directly-bound) handlers if ( delegateCount &lt; handlers.length ) { handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) }); } return handlerQueue; }, fix: function( event ) { if ( event[ jQuery.expando ] ) { return event; } // Create a writable copy of the event object and normalize some properties var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[ type ]; if ( !fixHook ) { this.fixHooks[ type ] = fixHook = rmouseEvent.test( type ) ? this.mouseHooks : rkeyEvent.test( type ) ? this.keyHooks : {}; } copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props; event = new jQuery.Event( originalEvent ); i = copy.length; while ( i-- ) { prop = copy[ i ]; event[ prop ] = originalEvent[ prop ]; } // Support: IE&lt;9 // Fix target property (#1925) if ( !event.target ) { event.target = originalEvent.srcElement || document; } // Support: Chrome 23+, Safari? // Target should not be a text node (#504, #13143) if ( event.target.nodeType === 3 ) { event.target = event.target.parentNode; } // Support: IE&lt;9 // For mouse/key events, metaKey==false if it&apos;s undefined (#3368, #11328) event.metaKey = !!event.metaKey; return fixHook.filter ? fixHook.filter( event, originalEvent ) : event; }, // Includes some event props shared by KeyEvent and MouseEvent props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;), fixHooks: {}, keyHooks: { props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;), filter: function( event, original ) { // Add which for key events if ( event.which == null ) { event.which = original.charCode != null ? original.charCode : original.keyCode; } return event; } }, mouseHooks: { props: &quot;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;), filter: function( event, original ) { var body, eventDoc, doc, button = original.button, fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available if ( event.pageX == null &amp;&amp; original.clientX != null ) { eventDoc = event.target.ownerDocument || document; doc = eventDoc.documentElement; body = eventDoc.body; event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 ); event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0 ) - ( doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0 ); } // Add relatedTarget, if necessary if ( !event.relatedTarget &amp;&amp; fromElement ) { event.relatedTarget = fromElement === event.target ? original.toElement : fromElement; } // Add which for click: 1 === left; 2 === middle; 3 === right // Note: button is not normalized, so don&apos;t use it if ( !event.which &amp;&amp; button !== undefined ) { event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) ); } return event; } }, special: { load: { // Prevent triggered image.load events from bubbling to window.load noBubble: true }, focus: { // Fire native event if possible so blur/focus sequence is correct trigger: function() { if ( this !== safeActiveElement() &amp;&amp; this.focus ) { try { this.focus(); return false; } catch ( e ) { // Support: IE&lt;9 // If we error on focus to hidden element (#1486, #12518), // let .trigger() run the handlers } } }, delegateType: &quot;focusin&quot; }, blur: { trigger: function() { if ( this === safeActiveElement() &amp;&amp; this.blur ) { this.blur(); return false; } }, delegateType: &quot;focusout&quot; }, click: { // For checkbox, fire native event so checked state will be right trigger: function() { if ( jQuery.nodeName( this, &quot;input&quot; ) &amp;&amp; this.type === &quot;checkbox&quot; &amp;&amp; this.click ) { this.click(); return false; } }, // For cross-browser consistency, don&apos;t fire native .click() on links _default: function( event ) { return jQuery.nodeName( event.target, &quot;a&quot; ); } }, beforeunload: { postDispatch: function( event ) { // Support: Firefox 20+ // Firefox doesn&apos;t alert if the returnValue field is not set. if ( event.result !== undefined &amp;&amp; event.originalEvent ) { event.originalEvent.returnValue = event.result; } } } }, simulate: function( type, elem, event, bubble ) { // Piggyback on a donor event to simulate a different one. // Fake originalEvent to avoid donor&apos;s stopPropagation, but if the // simulated event prevents default then we do the same on the donor. var e = jQuery.extend( new jQuery.Event(), event, { type: type, isSimulated: true, originalEvent: {} } ); if ( bubble ) { jQuery.event.trigger( e, null, elem ); } else { jQuery.event.dispatch.call( elem, e ); } if ( e.isDefaultPrevented() ) { event.preventDefault(); } } }; jQuery.removeEvent = document.removeEventListener ? function( elem, type, handle ) { if ( elem.removeEventListener ) { elem.removeEventListener( type, handle, false ); } } : function( elem, type, handle ) { var name = &quot;on&quot; + type; if ( elem.detachEvent ) { // #8545, #7054, preventing memory leaks for custom events in IE6-8 // detachEvent needed property on element, by name of that event, to properly expose it to GC if ( typeof elem[ name ] === strundefined ) { elem[ name ] = null; } elem.detachEvent( name, handle ); } }; jQuery.Event = function( src, props ) { // Allow instantiation without the &apos;new&apos; keyword if ( !(this instanceof jQuery.Event) ) { return new jQuery.Event( src, props ); } // Event object if ( src &amp;&amp; src.type ) { this.originalEvent = src; this.type = src.type; // Events bubbling up the document may have been marked as prevented // by a handler lower down the tree; reflect the correct value. this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &amp;&amp; // Support: IE &lt; 9, Android &lt; 4.0 src.returnValue === false ? returnTrue : returnFalse; // Event type } else { this.type = src; } // Put explicitly provided properties onto the event object if ( props ) { jQuery.extend( this, props ); } // Create a timestamp if incoming event doesn&apos;t have one this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now(); // Mark it as fixed this[ jQuery.expando ] = true; }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html jQuery.Event.prototype = { isDefaultPrevented: returnFalse, isPropagationStopped: returnFalse, isImmediatePropagationStopped: returnFalse, preventDefault: function() { var e = this.originalEvent; this.isDefaultPrevented = returnTrue; if ( !e ) { return; } // If preventDefault exists, run it on the original event if ( e.preventDefault ) { e.preventDefault(); // Support: IE // Otherwise set the returnValue property of the original event to false } else { e.returnValue = false; } }, stopPropagation: function() { var e = this.originalEvent; this.isPropagationStopped = returnTrue; if ( !e ) { return; } // If stopPropagation exists, run it on the original event if ( e.stopPropagation ) { e.stopPropagation(); } // Support: IE // Set the cancelBubble property of the original event to true e.cancelBubble = true; }, stopImmediatePropagation: function() { var e = this.originalEvent; this.isImmediatePropagationStopped = returnTrue; if ( e &amp;&amp; e.stopImmediatePropagation ) { e.stopImmediatePropagation(); } this.stopPropagation(); } }; // Create mouseenter/leave events using mouseover/out and event-time checks jQuery.each({ mouseenter: &quot;mouseover&quot;, mouseleave: &quot;mouseout&quot;, pointerenter: &quot;pointerover&quot;, pointerleave: &quot;pointerout&quot; }, function( orig, fix ) { jQuery.event.special[ orig ] = { delegateType: fix, bindType: fix, handle: function( event ) { var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj; // For mousenter/leave call the handler if related is outside the target. // NB: No relatedTarget if the mouse left/entered the browser window if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) { event.type = handleObj.origType; ret = handleObj.handler.apply( this, arguments ); event.type = fix; } return ret; } }; }); // IE submit delegation if ( !support.submitBubbles ) { jQuery.event.special.submit = { setup: function() { // Only need this for delegated form submit events if ( jQuery.nodeName( this, &quot;form&quot; ) ) { return false; } // Lazy-add a submit handler when a descendant form may potentially be submitted jQuery.event.add( this, &quot;click._submit keypress._submit&quot;, function( e ) { // Node name check avoids a VML-related crash in IE (#9807) var elem = e.target, form = jQuery.nodeName( elem, &quot;input&quot; ) || jQuery.nodeName( elem, &quot;button&quot; ) ? elem.form : undefined; if ( form &amp;&amp; !jQuery._data( form, &quot;submitBubbles&quot; ) ) { jQuery.event.add( form, &quot;submit._submit&quot;, function( event ) { event._submit_bubble = true; }); jQuery._data( form, &quot;submitBubbles&quot;, true ); } }); // return undefined since we don&apos;t need an event listener }, postDispatch: function( event ) { // If form was submitted by the user, bubble the event up the tree if ( event._submit_bubble ) { delete event._submit_bubble; if ( this.parentNode &amp;&amp; !event.isTrigger ) { jQuery.event.simulate( &quot;submit&quot;, this.parentNode, event, true ); } } }, teardown: function() { // Only need this for delegated form submit events if ( jQuery.nodeName( this, &quot;form&quot; ) ) { return false; } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above jQuery.event.remove( this, &quot;._submit&quot; ); } }; } // IE change delegation and checkbox/radio fix if ( !support.changeBubbles ) { jQuery.event.special.change = { setup: function() { if ( rformElems.test( this.nodeName ) ) { // IE doesn&apos;t fire change on a check/radio until blur; trigger it on click // after a propertychange. Eat the blur-change in special.change.handle. // This still fires onchange a second time for check/radio after blur. if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) { jQuery.event.add( this, &quot;propertychange._change&quot;, function( event ) { if ( event.originalEvent.propertyName === &quot;checked&quot; ) { this._just_changed = true; } }); jQuery.event.add( this, &quot;click._change&quot;, function( event ) { if ( this._just_changed &amp;&amp; !event.isTrigger ) { this._just_changed = false; } // Allow triggered, simulated change events (#11500) jQuery.event.simulate( &quot;change&quot;, this, event, true ); }); } return false; } // Delegated event; lazy-add a change handler on descendant inputs jQuery.event.add( this, &quot;beforeactivate._change&quot;, function( e ) { var elem = e.target; if ( rformElems.test( elem.nodeName ) &amp;&amp; !jQuery._data( elem, &quot;changeBubbles&quot; ) ) { jQuery.event.add( elem, &quot;change._change&quot;, function( event ) { if ( this.parentNode &amp;&amp; !event.isSimulated &amp;&amp; !event.isTrigger ) { jQuery.event.simulate( &quot;change&quot;, this.parentNode, event, true ); } }); jQuery._data( elem, &quot;changeBubbles&quot;, true ); } }); }, handle: function( event ) { var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== &quot;radio&quot; &amp;&amp; elem.type !== &quot;checkbox&quot;) ) { return event.handleObj.handler.apply( this, arguments ); } }, teardown: function() { jQuery.event.remove( this, &quot;._change&quot; ); return !rformElems.test( this.nodeName ); } }; } // Create &quot;bubbling&quot; focus and blur events if ( !support.focusinBubbles ) { jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) { // Attach a single capturing handler on the document while someone wants focusin/focusout var handler = function( event ) { jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true ); }; jQuery.event.special[ fix ] = { setup: function() { var doc = this.ownerDocument || this, attaches = jQuery._data( doc, fix ); if ( !attaches ) { doc.addEventListener( orig, handler, true ); } jQuery._data( doc, fix, ( attaches || 0 ) + 1 ); }, teardown: function() { var doc = this.ownerDocument || this, attaches = jQuery._data( doc, fix ) - 1; if ( !attaches ) { doc.removeEventListener( orig, handler, true ); jQuery._removeData( doc, fix ); } else { jQuery._data( doc, fix, attaches ); } } }; }); } jQuery.fn.extend({ on: function( types, selector, data, fn, /*INTERNAL*/ one ) { var type, origFn; // Types can be a map of types/handlers if ( typeof types === &quot;object&quot; ) { // ( types-Object, selector, data ) if ( typeof selector !== &quot;string&quot; ) { // ( types-Object, data ) data = data || selector; selector = undefined; } for ( type in types ) { this.on( type, selector, data, types[ type ], one ); } return this; } if ( data == null &amp;&amp; fn == null ) { // ( types, fn ) fn = selector; data = selector = undefined; } else if ( fn == null ) { if ( typeof selector === &quot;string&quot; ) { // ( types, selector, fn ) fn = data; data = undefined; } else { // ( types, data, fn ) fn = data; data = selector; selector = undefined; } } if ( fn === false ) { fn = returnFalse; } else if ( !fn ) { return this; } if ( one === 1 ) { origFn = fn; fn = function( event ) { // Can use an empty set, since event contains the info jQuery().off( event ); return origFn.apply( this, arguments ); }; // Use same guid so caller can remove using origFn fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ ); } return this.each( function() { jQuery.event.add( this, types, fn, data, selector ); }); }, one: function( types, selector, data, fn ) { return this.on( types, selector, data, fn, 1 ); }, off: function( types, selector, fn ) { var handleObj, type; if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) { // ( event ) dispatched jQuery.Event handleObj = types.handleObj; jQuery( types.delegateTarget ).off( handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler ); return this; } if ( typeof types === &quot;object&quot; ) { // ( types-object [, selector] ) for ( type in types ) { this.off( type, selector, types[ type ] ); } return this; } if ( selector === false || typeof selector === &quot;function&quot; ) { // ( types [, fn] ) fn = selector; selector = undefined; } if ( fn === false ) { fn = returnFalse; } return this.each(function() { jQuery.event.remove( this, types, fn, selector ); }); }, trigger: function( type, data ) { return this.each(function() { jQuery.event.trigger( type, data, this ); }); }, triggerHandler: function( type, data ) { var elem = this[0]; if ( elem ) { return jQuery.event.trigger( type, data, elem, true ); } } }); function createSafeFragment( document ) { var list = nodeNames.split( &quot;|&quot; ), safeFrag = document.createDocumentFragment(); if ( safeFrag.createElement ) { while ( list.length ) { safeFrag.createElement( list.pop() ); } } return safeFrag; } var nodeNames = &quot;abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|&quot; + &quot;header|hgroup|mark|meter|nav|output|progress|section|summary|time|video&quot;, rinlinejQuery = / jQuery\d+=&quot;(?:null|\d+)&quot;/g, rnoshimcache = new RegExp(&quot;&lt;(?:&quot; + nodeNames + &quot;)[\\s/&gt;]&quot;, &quot;i&quot;), rleadingWhitespace = /^\s+/, rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi, rtagName = /&lt;([\w:]+)/, rtbody = /&lt;tbody/i, rhtml = /&lt;|&amp;#?\w+;/, rnoInnerhtml = /&lt;(?:script|style|link)/i, // checked=&quot;checked&quot; or checked rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g, // We have to close these tags to support XHTML (#13200) wrapMap = { option: [ 1, &quot;&lt;select multiple=&apos;multiple&apos;&gt;&quot;, &quot;&lt;/select&gt;&quot; ], legend: [ 1, &quot;&lt;fieldset&gt;&quot;, &quot;&lt;/fieldset&gt;&quot; ], area: [ 1, &quot;&lt;map&gt;&quot;, &quot;&lt;/map&gt;&quot; ], param: [ 1, &quot;&lt;object&gt;&quot;, &quot;&lt;/object&gt;&quot; ], thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ], tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ], col: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ], td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ], // IE6-8 can&apos;t serialize link, script, style, or any html5 (NoScope) tags, // unless wrapped in a div with non-breaking characters in front of it. _default: support.htmlSerialize ? [ 0, &quot;&quot;, &quot;&quot; ] : [ 1, &quot;X&lt;div&gt;&quot;, &quot;&lt;/div&gt;&quot; ] }, safeFragment = createSafeFragment( document ), fragmentDiv = safeFragment.appendChild( document.createElement(&quot;div&quot;) ); wrapMap.optgroup = wrapMap.option; wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead; wrapMap.th = wrapMap.td; function getAll( context, tag ) { var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || &quot;*&quot; ) : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || &quot;*&quot; ) : undefined; if ( !found ) { for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) { if ( !tag || jQuery.nodeName( elem, tag ) ) { found.push( elem ); } else { jQuery.merge( found, getAll( elem, tag ) ); } } } return tag === undefined || tag &amp;&amp; jQuery.nodeName( context, tag ) ? jQuery.merge( [ context ], found ) : found; } // Used in buildFragment, fixes the defaultChecked property function fixDefaultChecked( elem ) { if ( rcheckableType.test( elem.type ) ) { elem.defaultChecked = elem.checked; } } // Support: IE&lt;8 // Manipulating tables requires a tbody function manipulationTarget( elem, content ) { return jQuery.nodeName( elem, &quot;table&quot; ) &amp;&amp; jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ? elem.getElementsByTagName(&quot;tbody&quot;)[0] || elem.appendChild( elem.ownerDocument.createElement(&quot;tbody&quot;) ) : elem; } // Replace/restore the type attribute of script elements for safe DOM manipulation function disableScript( elem ) { elem.type = (jQuery.find.attr( elem, &quot;type&quot; ) !== null) + &quot;/&quot; + elem.type; return elem; } function restoreScript( elem ) { var match = rscriptTypeMasked.exec( elem.type ); if ( match ) { elem.type = match[1]; } else { elem.removeAttribute(&quot;type&quot;); } return elem; } // Mark scripts as having already been evaluated function setGlobalEval( elems, refElements ) { var elem, i = 0; for ( ; (elem = elems[i]) != null; i++ ) { jQuery._data( elem, &quot;globalEval&quot;, !refElements || jQuery._data( refElements[i], &quot;globalEval&quot; ) ); } } function cloneCopyEvent( src, dest ) { if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) { return; } var type, i, l, oldData = jQuery._data( src ), curData = jQuery._data( dest, oldData ), events = oldData.events; if ( events ) { delete curData.handle; curData.events = {}; for ( type in events ) { for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) { jQuery.event.add( dest, type, events[ type ][ i ] ); } } } // make the cloned public data object a copy from the original if ( curData.data ) { curData.data = jQuery.extend( {}, curData.data ); } } function fixCloneNodeIssues( src, dest ) { var nodeName, e, data; // We do not need to do anything for non-Elements if ( dest.nodeType !== 1 ) { return; } nodeName = dest.nodeName.toLowerCase(); // IE6-8 copies events bound via attachEvent when using cloneNode. if ( !support.noCloneEvent &amp;&amp; dest[ jQuery.expando ] ) { data = jQuery._data( dest ); for ( e in data.events ) { jQuery.removeEvent( dest, e, data.handle ); } // Event data gets referenced instead of copied if the expando gets copied too dest.removeAttribute( jQuery.expando ); } // IE blanks contents when cloning scripts, and tries to evaluate newly-set text if ( nodeName === &quot;script&quot; &amp;&amp; dest.text !== src.text ) { disableScript( dest ).text = src.text; restoreScript( dest ); // IE6-10 improperly clones children of object elements using classid. // IE10 throws NoModificationAllowedError if parent is null, #12132. } else if ( nodeName === &quot;object&quot; ) { if ( dest.parentNode ) { dest.outerHTML = src.outerHTML; } // This path appears unavoidable for IE9. When cloning an object // element in IE9, the outerHTML strategy above is not sufficient. // If the src has innerHTML and the destination does not, // copy the src.innerHTML into the dest.innerHTML. #10324 if ( support.html5Clone &amp;&amp; ( src.innerHTML &amp;&amp; !jQuery.trim(dest.innerHTML) ) ) { dest.innerHTML = src.innerHTML; } } else if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) { // IE6-8 fails to persist the checked state of a cloned checkbox // or radio button. Worse, IE6-7 fail to give the cloned element // a checked appearance if the defaultChecked value isn&apos;t also set dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned // checkbox/radio button to an empty string instead of &quot;on&quot; if ( dest.value !== src.value ) { dest.value = src.value; } // IE6-8 fails to return the selected option to the default selected // state when cloning options } else if ( nodeName === &quot;option&quot; ) { dest.defaultSelected = dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when // cloning other types of input fields } else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) { dest.defaultValue = src.defaultValue; } } jQuery.extend({ clone: function( elem, dataAndEvents, deepDataAndEvents ) { var destElements, node, clone, i, srcElements, inPage = jQuery.contains( elem.ownerDocument, elem ); if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( &quot;&lt;&quot; + elem.nodeName + &quot;&gt;&quot; ) ) { clone = elem.cloneNode( true ); // IE&lt;=8 does not properly clone detached, unknown element nodes } else { fragmentDiv.innerHTML = elem.outerHTML; fragmentDiv.removeChild( clone = fragmentDiv.firstChild ); } if ( (!support.noCloneEvent || !support.noCloneChecked) &amp;&amp; (elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem) ) { // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2 destElements = getAll( clone ); srcElements = getAll( elem ); // Fix all IE cloning issues for ( i = 0; (node = srcElements[i]) != null; ++i ) { // Ensure that the destination node is not null; Fixes #9587 if ( destElements[i] ) { fixCloneNodeIssues( node, destElements[i] ); } } } // Copy the events from the original to the clone if ( dataAndEvents ) { if ( deepDataAndEvents ) { srcElements = srcElements || getAll( elem ); destElements = destElements || getAll( clone ); for ( i = 0; (node = srcElements[i]) != null; i++ ) { cloneCopyEvent( node, destElements[i] ); } } else { cloneCopyEvent( elem, clone ); } } // Preserve script evaluation history destElements = getAll( clone, &quot;script&quot; ); if ( destElements.length &gt; 0 ) { setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) ); } destElements = srcElements = node = null; // Return the cloned set return clone; }, buildFragment: function( elems, context, scripts, selection ) { var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, // Ensure a safe fragment safe = createSafeFragment( context ), nodes = [], i = 0; for ( ; i &lt; l; i++ ) { elem = elems[ i ]; if ( elem || elem === 0 ) { // Add nodes directly if ( jQuery.type( elem ) === &quot;object&quot; ) { jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem ); // Convert non-html into a text node } else if ( !rhtml.test( elem ) ) { nodes.push( context.createTextNode( elem ) ); // Convert html into DOM nodes } else { tmp = tmp || safe.appendChild( context.createElement(&quot;div&quot;) ); // Deserialize a standard representation tag = (rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ])[ 1 ].toLowerCase(); wrap = wrapMap[ tag ] || wrapMap._default; tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; ) + wrap[2]; // Descend through wrappers to the right content j = wrap[0]; while ( j-- ) { tmp = tmp.lastChild; } // Manually add leading whitespace removed by IE if ( !support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) { nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) ); } // Remove IE&apos;s autoinserted &lt;tbody&gt; from table fragments if ( !support.tbody ) { // String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt; elem = tag === &quot;table&quot; &amp;&amp; !rtbody.test( elem ) ? tmp.firstChild : // String was a bare &lt;thead&gt; or &lt;tfoot&gt; wrap[1] === &quot;&lt;table&gt;&quot; &amp;&amp; !rtbody.test( elem ) ? tmp : 0; j = elem &amp;&amp; elem.childNodes.length; while ( j-- ) { if ( jQuery.nodeName( (tbody = elem.childNodes[j]), &quot;tbody&quot; ) &amp;&amp; !tbody.childNodes.length ) { elem.removeChild( tbody ); } } } jQuery.merge( nodes, tmp.childNodes ); // Fix #12392 for WebKit and IE &gt; 9 tmp.textContent = &quot;&quot;; // Fix #12392 for oldIE while ( tmp.firstChild ) { tmp.removeChild( tmp.firstChild ); } // Remember the top-level container for proper cleanup tmp = safe.lastChild; } } } // Fix #11356: Clear elements from fragment if ( tmp ) { safe.removeChild( tmp ); } // Reset defaultChecked for any radios and checkboxes // about to be appended to the DOM in IE 6/7 (#8060) if ( !support.appendChecked ) { jQuery.grep( getAll( nodes, &quot;input&quot; ), fixDefaultChecked ); } i = 0; while ( (elem = nodes[ i++ ]) ) { // #4087 - If origin and destination elements are the same, and this is // that element, do not do anything if ( selection &amp;&amp; jQuery.inArray( elem, selection ) !== -1 ) { continue; } contains = jQuery.contains( elem.ownerDocument, elem ); // Append to fragment tmp = getAll( safe.appendChild( elem ), &quot;script&quot; ); // Preserve script evaluation history if ( contains ) { setGlobalEval( tmp ); } // Capture executables if ( scripts ) { j = 0; while ( (elem = tmp[ j++ ]) ) { if ( rscriptType.test( elem.type || &quot;&quot; ) ) { scripts.push( elem ); } } } } tmp = null; return safe; }, cleanData: function( elems, /* internal */ acceptData ) { var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special; for ( ; (elem = elems[i]) != null; i++ ) { if ( acceptData || jQuery.acceptData( elem ) ) { id = elem[ internalKey ]; data = id &amp;&amp; cache[ id ]; if ( data ) { if ( data.events ) { for ( type in data.events ) { if ( special[ type ] ) { jQuery.event.remove( elem, type ); // This is a shortcut to avoid jQuery.event.remove&apos;s overhead } else { jQuery.removeEvent( elem, type, data.handle ); } } } // Remove cache only if it was not already removed by jQuery.event.remove if ( cache[ id ] ) { delete cache[ id ]; // IE does not allow us to delete expando properties from nodes, // nor does it have a removeAttribute function on Document nodes; // we must handle all of these cases if ( deleteExpando ) { delete elem[ internalKey ]; } else if ( typeof elem.removeAttribute !== strundefined ) { elem.removeAttribute( internalKey ); } else { elem[ internalKey ] = null; } deletedIds.push( id ); } } } } } }); jQuery.fn.extend({ text: function( value ) { return access( this, function( value ) { return value === undefined ? jQuery.text( this ) : this.empty().append( ( this[0] &amp;&amp; this[0].ownerDocument || document ).createTextNode( value ) ); }, null, value, arguments.length ); }, append: function() { return this.domManip( arguments, function( elem ) { if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) { var target = manipulationTarget( this, elem ); target.appendChild( elem ); } }); }, prepend: function() { return this.domManip( arguments, function( elem ) { if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) { var target = manipulationTarget( this, elem ); target.insertBefore( elem, target.firstChild ); } }); }, before: function() { return this.domManip( arguments, function( elem ) { if ( this.parentNode ) { this.parentNode.insertBefore( elem, this ); } }); }, after: function() { return this.domManip( arguments, function( elem ) { if ( this.parentNode ) { this.parentNode.insertBefore( elem, this.nextSibling ); } }); }, remove: function( selector, keepData /* Internal Use Only */ ) { var elem, elems = selector ? jQuery.filter( selector, this ) : this, i = 0; for ( ; (elem = elems[i]) != null; i++ ) { if ( !keepData &amp;&amp; elem.nodeType === 1 ) { jQuery.cleanData( getAll( elem ) ); } if ( elem.parentNode ) { if ( keepData &amp;&amp; jQuery.contains( elem.ownerDocument, elem ) ) { setGlobalEval( getAll( elem, &quot;script&quot; ) ); } elem.parentNode.removeChild( elem ); } } return this; }, empty: function() { var elem, i = 0; for ( ; (elem = this[i]) != null; i++ ) { // Remove element nodes and prevent memory leaks if ( elem.nodeType === 1 ) { jQuery.cleanData( getAll( elem, false ) ); } // Remove any remaining nodes while ( elem.firstChild ) { elem.removeChild( elem.firstChild ); } // If this is a select, ensure that it displays empty (#12336) // Support: IE&lt;9 if ( elem.options &amp;&amp; jQuery.nodeName( elem, &quot;select&quot; ) ) { elem.options.length = 0; } } return this; }, clone: function( dataAndEvents, deepDataAndEvents ) { dataAndEvents = dataAndEvents == null ? false : dataAndEvents; deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents; return this.map(function() { return jQuery.clone( this, dataAndEvents, deepDataAndEvents ); }); }, html: function( value ) { return access( this, function( value ) { var elem = this[ 0 ] || {}, i = 0, l = this.length; if ( value === undefined ) { return elem.nodeType === 1 ? elem.innerHTML.replace( rinlinejQuery, &quot;&quot; ) : undefined; } // See if we can take a shortcut and just use innerHTML if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp; ( support.htmlSerialize || !rnoshimcache.test( value ) ) &amp;&amp; ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp; !wrapMap[ (rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ])[ 1 ].toLowerCase() ] ) { value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; ); try { for (; i &lt; l; i++ ) { // Remove element nodes and prevent memory leaks elem = this[i] || {}; if ( elem.nodeType === 1 ) { jQuery.cleanData( getAll( elem, false ) ); elem.innerHTML = value; } } elem = 0; // If using innerHTML throws an exception, use the fallback method } catch(e) {} } if ( elem ) { this.empty().append( value ); } }, null, value, arguments.length ); }, replaceWith: function() { var arg = arguments[ 0 ]; // Make the changes, replacing each context element with the new content this.domManip( arguments, function( elem ) { arg = this.parentNode; jQuery.cleanData( getAll( this ) ); if ( arg ) { arg.replaceChild( elem, this ); } }); // Force removal if there was no new content (e.g., from empty arguments) return arg &amp;&amp; (arg.length || arg.nodeType) ? this : this.remove(); }, detach: function( selector ) { return this.remove( selector, true ); }, domManip: function( args, callback ) { // Flatten any nested arrays args = concat.apply( [], args ); var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction( value ); // We can&apos;t cloneNode fragments that contain checked, in WebKit if ( isFunction || ( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp; !support.checkClone &amp;&amp; rchecked.test( value ) ) ) { return this.each(function( index ) { var self = set.eq( index ); if ( isFunction ) { args[0] = value.call( this, index, self.html() ); } self.domManip( args, callback ); }); } if ( l ) { fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this ); first = fragment.firstChild; if ( fragment.childNodes.length === 1 ) { fragment = first; } if ( first ) { scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript ); hasScripts = scripts.length; // Use the original fragment for the last item instead of the first because it can end up // being emptied incorrectly in certain situations (#8070). for ( ; i &lt; l; i++ ) { node = fragment; if ( i !== iNoClone ) { node = jQuery.clone( node, true, true ); // Keep references to cloned scripts for later restoration if ( hasScripts ) { jQuery.merge( scripts, getAll( node, &quot;script&quot; ) ); } } callback.call( this[i], node, i ); } if ( hasScripts ) { doc = scripts[ scripts.length - 1 ].ownerDocument; // Reenable scripts jQuery.map( scripts, restoreScript ); // Evaluate executable scripts on first document insertion for ( i = 0; i &lt; hasScripts; i++ ) { node = scripts[ i ]; if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp; !jQuery._data( node, &quot;globalEval&quot; ) &amp;&amp; jQuery.contains( doc, node ) ) { if ( node.src ) { // Optional AJAX dependency, but won&apos;t run scripts if not present if ( jQuery._evalUrl ) { jQuery._evalUrl( node.src ); } } else { jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || &quot;&quot; ).replace( rcleanScript, &quot;&quot; ) ); } } } } // Fix #11809: Avoid leaking memory fragment = first = null; } } return this; } }); jQuery.each({ appendTo: &quot;append&quot;, prependTo: &quot;prepend&quot;, insertBefore: &quot;before&quot;, insertAfter: &quot;after&quot;, replaceAll: &quot;replaceWith&quot; }, function( name, original ) { jQuery.fn[ name ] = function( selector ) { var elems, i = 0, ret = [], insert = jQuery( selector ), last = insert.length - 1; for ( ; i &lt;= last; i++ ) { elems = i === last ? this : this.clone(true); jQuery( insert[i] )[ original ]( elems ); // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get() push.apply( ret, elems.get() ); } return this.pushStack( ret ); }; }); var iframe, elemdisplay = {}; /** * Retrieve the actual display of a element * @param {String} name nodeName of the element * @param {Object} doc Document object */ // Called only from within defaultDisplay function actualDisplay( name, doc ) { var style, elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ), // getDefaultComputedStyle might be reliably used only on attached element display = window.getDefaultComputedStyle &amp;&amp; ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ? // Use of this method is a temporary fix (more like optmization) until something better comes along, // since it was removed from specification and supported only in FF style.display : jQuery.css( elem[ 0 ], &quot;display&quot; ); // We don&apos;t have any data stored on the element, // so use &quot;detach&quot; method as fast way to get rid of the element elem.detach(); return display; } /** * Try to determine the default display value of an element * @param {String} nodeName */ function defaultDisplay( nodeName ) { var doc = document, display = elemdisplay[ nodeName ]; if ( !display ) { display = actualDisplay( nodeName, doc ); // If the simple way fails, read from inside an iframe if ( display === &quot;none&quot; || !display ) { // Use the already-created iframe if possible iframe = (iframe || jQuery( &quot;&lt;iframe frameborder=&apos;0&apos; width=&apos;0&apos; height=&apos;0&apos;/&gt;&quot; )).appendTo( doc.documentElement ); // Always write a new HTML skeleton so Webkit and Firefox don&apos;t choke on reuse doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document; // Support: IE doc.write(); doc.close(); display = actualDisplay( nodeName, doc ); iframe.detach(); } // Store the correct default display elemdisplay[ nodeName ] = display; } return display; } (function() { var shrinkWrapBlocksVal; support.shrinkWrapBlocks = function() { if ( shrinkWrapBlocksVal != null ) { return shrinkWrapBlocksVal; } // Will be changed later if needed. shrinkWrapBlocksVal = false; // Minified: var b,c,d var div, body, container; body = document.getElementsByTagName( &quot;body&quot; )[ 0 ]; if ( !body || !body.style ) { // Test fired too early or in an unsupported environment, exit. return; } // Setup div = document.createElement( &quot;div&quot; ); container = document.createElement( &quot;div&quot; ); container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;; body.appendChild( container ).appendChild( div ); // Support: IE6 // Check if elements with layout shrink-wrap their children if ( typeof div.style.zoom !== strundefined ) { // Reset CSS: box-sizing; display; margin; border div.style.cssText = // Support: Firefox&lt;29, Android 2.3 // Vendor-prefix box-sizing &quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; + &quot;box-sizing:content-box;display:block;margin:0;border:0;&quot; + &quot;padding:1px;width:1px;zoom:1&quot;; div.appendChild( document.createElement( &quot;div&quot; ) ).style.width = &quot;5px&quot;; shrinkWrapBlocksVal = div.offsetWidth !== 3; } body.removeChild( container ); return shrinkWrapBlocksVal; }; })(); var rmargin = (/^margin/); var rnumnonpx = new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; ); var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/; if ( window.getComputedStyle ) { getStyles = function( elem ) { // Support: IE&lt;=11+, Firefox&lt;=30+ (#15098, #14150) // IE throws on elements created in popups // FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot; if ( elem.ownerDocument.defaultView.opener ) { return elem.ownerDocument.defaultView.getComputedStyle( elem, null ); } return window.getComputedStyle( elem, null ); }; curCSS = function( elem, name, computed ) { var width, minWidth, maxWidth, ret, style = elem.style; computed = computed || getStyles( elem ); // getPropertyValue is only needed for .css(&apos;filter&apos;) in IE9, see #12537 ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined; if ( computed ) { if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) { ret = jQuery.style( elem, name ); } // A tribute to the &quot;awesome hack by Dean Edwards&quot; // Chrome &lt; 17 and Safari 5.0 uses &quot;computed value&quot; instead of &quot;used value&quot; for margin-right // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values if ( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) { // Remember the original values width = style.width; minWidth = style.minWidth; maxWidth = style.maxWidth; // Put in the new values to get a computed value out style.minWidth = style.maxWidth = style.width = ret; ret = computed.width; // Revert the changed values style.width = width; style.minWidth = minWidth; style.maxWidth = maxWidth; } } // Support: IE // IE returns zIndex value as an integer. return ret === undefined ? ret : ret + &quot;&quot;; }; } else if ( document.documentElement.currentStyle ) { getStyles = function( elem ) { return elem.currentStyle; }; curCSS = function( elem, name, computed ) { var left, rs, rsLeft, ret, style = elem.style; computed = computed || getStyles( elem ); ret = computed ? computed[ name ] : undefined; // Avoid setting ret to empty string here // so we don&apos;t default to auto if ( ret == null &amp;&amp; style &amp;&amp; style[ name ] ) { ret = style[ name ]; } // From the awesome hack by Dean Edwards // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291 // If we&apos;re not dealing with a regular pixel number // but a number that has a weird ending, we need to convert it to pixels // but not position css attributes, as those are proportional to the parent element instead // and we can&apos;t measure the parent instead because it might trigger a &quot;stacking dolls&quot; problem if ( rnumnonpx.test( ret ) &amp;&amp; !rposition.test( name ) ) { // Remember the original values left = style.left; rs = elem.runtimeStyle; rsLeft = rs &amp;&amp; rs.left; // Put in the new values to get a computed value out if ( rsLeft ) { rs.left = elem.currentStyle.left; } style.left = name === &quot;fontSize&quot; ? &quot;1em&quot; : ret; ret = style.pixelLeft + &quot;px&quot;; // Revert the changed values style.left = left; if ( rsLeft ) { rs.left = rsLeft; } } // Support: IE // IE returns zIndex value as an integer. return ret === undefined ? ret : ret + &quot;&quot; || &quot;auto&quot;; }; } function addGetHookIf( conditionFn, hookFn ) { // Define the hook, we&apos;ll check on the first run if it&apos;s really needed. return { get: function() { var condition = conditionFn(); if ( condition == null ) { // The test was not ready at this point; screw the hook this time // but check again when needed next time. return; } if ( condition ) { // Hook not needed (or it&apos;s not possible to use it due to missing dependency), // remove it. // Since there are no other hooks for marginRight, remove the whole object. delete this.get; return; } // Hook needed; redefine it so that the support test is not executed again. return (this.get = hookFn).apply( this, arguments ); } }; } (function() { // Minified: var b,c,d,e,f,g, h,i var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal; // Setup div = document.createElement( &quot;div&quot; ); div.innerHTML = &quot; &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&apos;/a&apos;&gt;a&lt;/a&gt;&lt;input type=&apos;checkbox&apos;/&gt;&quot;; a = div.getElementsByTagName( &quot;a&quot; )[ 0 ]; style = a &amp;&amp; a.style; // Finish early in limited (non-browser) environments if ( !style ) { return; } style.cssText = &quot;float:left;opacity:.5&quot;; // Support: IE&lt;9 // Make sure that element opacity exists (as opposed to filter) support.opacity = style.opacity === &quot;0.5&quot;; // Verify style float existence // (IE uses styleFloat instead of cssFloat) support.cssFloat = !!style.cssFloat; div.style.backgroundClip = &quot;content-box&quot;; div.cloneNode( true ).style.backgroundClip = &quot;&quot;; support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;; // Support: Firefox&lt;29, Android 2.3 // Vendor-prefix box-sizing support.boxSizing = style.boxSizing === &quot;&quot; || style.MozBoxSizing === &quot;&quot; || style.WebkitBoxSizing === &quot;&quot;; jQuery.extend(support, { reliableHiddenOffsets: function() { if ( reliableHiddenOffsetsVal == null ) { computeStyleTests(); } return reliableHiddenOffsetsVal; }, boxSizingReliable: function() { if ( boxSizingReliableVal == null ) { computeStyleTests(); } return boxSizingReliableVal; }, pixelPosition: function() { if ( pixelPositionVal == null ) { computeStyleTests(); } return pixelPositionVal; }, // Support: Android 2.3 reliableMarginRight: function() { if ( reliableMarginRightVal == null ) { computeStyleTests(); } return reliableMarginRightVal; } }); function computeStyleTests() { // Minified: var b,c,d,j var div, body, container, contents; body = document.getElementsByTagName( &quot;body&quot; )[ 0 ]; if ( !body || !body.style ) { // Test fired too early or in an unsupported environment, exit. return; } // Setup div = document.createElement( &quot;div&quot; ); container = document.createElement( &quot;div&quot; ); container.style.cssText = &quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;; body.appendChild( container ).appendChild( div ); div.style.cssText = // Support: Firefox&lt;29, Android 2.3 // Vendor-prefix box-sizing &quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&quot; + &quot;box-sizing:border-box;display:block;margin-top:1%;top:1%;&quot; + &quot;border:1px;padding:1px;width:4px;position:absolute&quot;; // Support: IE&lt;9 // Assume reasonable values in the absence of getComputedStyle pixelPositionVal = boxSizingReliableVal = false; reliableMarginRightVal = true; // Check for getComputedStyle so that this code is not run in IE&lt;9. if ( window.getComputedStyle ) { pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== &quot;1%&quot;; boxSizingReliableVal = ( window.getComputedStyle( div, null ) || { width: &quot;4px&quot; } ).width === &quot;4px&quot;; // Support: Android 2.3 // Div with explicit width and no margin-right incorrectly // gets computed margin-right based on width of container (#3333) // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right contents = div.appendChild( document.createElement( &quot;div&quot; ) ); // Reset CSS: box-sizing; display; margin; border; padding contents.style.cssText = div.style.cssText = // Support: Firefox&lt;29, Android 2.3 // Vendor-prefix box-sizing &quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; + &quot;box-sizing:content-box;display:block;margin:0;border:0;padding:0&quot;; contents.style.marginRight = contents.style.width = &quot;0&quot;; div.style.width = &quot;1px&quot;; reliableMarginRightVal = !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight ); div.removeChild( contents ); } // Support: IE8 // Check if table cells still have offsetWidth/Height when they are set // to display:none and there are still other visible table cells in a // table row; if so, offsetWidth/Height are not reliable for use when // determining if an element has been hidden directly using // display:none (it is still safe to use offsets if a parent element is // hidden; don safety goggles and see bug #4512 for more information). div.innerHTML = &quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;; contents = div.getElementsByTagName( &quot;td&quot; ); contents[ 0 ].style.cssText = &quot;margin:0;border:0;padding:0;display:none&quot;; reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0; if ( reliableHiddenOffsetsVal ) { contents[ 0 ].style.display = &quot;&quot;; contents[ 1 ].style.display = &quot;none&quot;; reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0; } body.removeChild( container ); } })(); // A method for quickly swapping in/out CSS properties to get correct calculations. jQuery.swap = function( elem, options, callback, args ) { var ret, name, old = {}; // Remember the old values, and insert the new ones for ( name in options ) { old[ name ] = elem.style[ name ]; elem.style[ name ] = options[ name ]; } ret = callback.apply( elem, args || [] ); // Revert the old values for ( name in options ) { elem.style[ name ] = old[ name ]; } return ret; }; var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, // swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot; // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp( &quot;^(&quot; + pnum + &quot;)(.*)$&quot;, &quot;i&quot; ), rrelNum = new RegExp( &quot;^([+-])=(&quot; + pnum + &quot;)&quot;, &quot;i&quot; ), cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; }, cssNormalTransform = { letterSpacing: &quot;0&quot;, fontWeight: &quot;400&quot; }, cssPrefixes = [ &quot;Webkit&quot;, &quot;O&quot;, &quot;Moz&quot;, &quot;ms&quot; ]; // return a css property mapped to a potentially vendor prefixed property function vendorPropName( style, name ) { // shortcut for names that are not vendor prefixed if ( name in style ) { return name; } // check for vendor prefixed names var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; while ( i-- ) { name = cssPrefixes[ i ] + capName; if ( name in style ) { return name; } } return origName; } function showHide( elements, show ) { var display, elem, hidden, values = [], index = 0, length = elements.length; for ( ; index &lt; length; index++ ) { elem = elements[ index ]; if ( !elem.style ) { continue; } values[ index ] = jQuery._data( elem, &quot;olddisplay&quot; ); display = elem.style.display; if ( show ) { // Reset the inline display of this element to learn if it is // being hidden by cascaded rules or not if ( !values[ index ] &amp;&amp; display === &quot;none&quot; ) { elem.style.display = &quot;&quot;; } // Set elements which have been overridden with display: none // in a stylesheet to whatever the default browser style is // for such an element if ( elem.style.display === &quot;&quot; &amp;&amp; isHidden( elem ) ) { values[ index ] = jQuery._data( elem, &quot;olddisplay&quot;, defaultDisplay(elem.nodeName) ); } } else { hidden = isHidden( elem ); if ( display &amp;&amp; display !== &quot;none&quot; || !hidden ) { jQuery._data( elem, &quot;olddisplay&quot;, hidden ? display : jQuery.css( elem, &quot;display&quot; ) ); } } } // Set the display of most of the elements in a second loop // to avoid the constant reflow for ( index = 0; index &lt; length; index++ ) { elem = elements[ index ]; if ( !elem.style ) { continue; } if ( !show || elem.style.display === &quot;none&quot; || elem.style.display === &quot;&quot; ) { elem.style.display = show ? values[ index ] || &quot;&quot; : &quot;none&quot;; } } return elements; } function setPositiveNumber( elem, value, subtract ) { var matches = rnumsplit.exec( value ); return matches ? // Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || &quot;px&quot; ) : value; } function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) { var i = extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ? // If we already have the right measurement, avoid augmentation 4 : // Otherwise initialize for horizontal or vertical properties name === &quot;width&quot; ? 1 : 0, val = 0; for ( ; i &lt; 4; i += 2 ) { // both box models exclude margin, so add it if we want it if ( extra === &quot;margin&quot; ) { val += jQuery.css( elem, extra + cssExpand[ i ], true, styles ); } if ( isBorderBox ) { // border-box includes padding, so remove it if we want content if ( extra === &quot;content&quot; ) { val -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles ); } // at this point, extra isn&apos;t border nor margin, so remove border if ( extra !== &quot;margin&quot; ) { val -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles ); } } else { // at this point, extra isn&apos;t content, so add padding val += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles ); // at this point, extra isn&apos;t content nor padding, so add border if ( extra !== &quot;padding&quot; ) { val += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles ); } } } return val; } function getWidthOrHeight( elem, name, extra ) { // Start with offset property, which is equivalent to the border-box value var valueIsBorderBox = true, val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight, styles = getStyles( elem ), isBorderBox = support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;; // some non-html elements return undefined for offsetWidth, so check for null/undefined // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285 // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668 if ( val &lt;= 0 || val == null ) { // Fall back to computed then uncomputed css if necessary val = curCSS( elem, name, styles ); if ( val &lt; 0 || val == null ) { val = elem.style[ name ]; } // Computed unit is not pixels. Stop here and return. if ( rnumnonpx.test(val) ) { return val; } // we need the check for style in case a browser which returns unreliable values // for getComputedStyle silently falls back to the reliable elem.style valueIsBorderBox = isBorderBox &amp;&amp; ( support.boxSizingReliable() || val === elem.style[ name ] ); // Normalize &quot;&quot;, auto, and prepare for extra val = parseFloat( val ) || 0; } // use the active box-sizing model to add/subtract irrelevant styles return ( val + augmentWidthOrHeight( elem, name, extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ), valueIsBorderBox, styles ) ) + &quot;px&quot;; } jQuery.extend({ // Add in style property hooks for overriding the default // behavior of getting and setting a style property cssHooks: { opacity: { get: function( elem, computed ) { if ( computed ) { // We should always get a number back from opacity var ret = curCSS( elem, &quot;opacity&quot; ); return ret === &quot;&quot; ? &quot;1&quot; : ret; } } } }, // Don&apos;t automatically add &quot;px&quot; to these possibly-unitless properties cssNumber: { &quot;columnCount&quot;: true, &quot;fillOpacity&quot;: true, &quot;flexGrow&quot;: true, &quot;flexShrink&quot;: true, &quot;fontWeight&quot;: true, &quot;lineHeight&quot;: true, &quot;opacity&quot;: true, &quot;order&quot;: true, &quot;orphans&quot;: true, &quot;widows&quot;: true, &quot;zIndex&quot;: true, &quot;zoom&quot;: true }, // Add in properties whose names you wish to fix before // setting or getting the value cssProps: { // normalize float css property &quot;float&quot;: support.cssFloat ? &quot;cssFloat&quot; : &quot;styleFloat&quot; }, // Get and set the style property on a DOM Node style: function( elem, name, value, extra ) { // Don&apos;t set styles on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) { return; } // Make sure that we&apos;re working with the right name var ret, type, hooks, origName = jQuery.camelCase( name ), style = elem.style; name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) ); // gets hook for the prefixed version // followed by the unprefixed version hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]; // Check if we&apos;re setting a value if ( value !== undefined ) { type = typeof value; // convert relative number strings (+= or -=) to relative numbers. #7345 if ( type === &quot;string&quot; &amp;&amp; (ret = rrelNum.exec( value )) ) { value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) ); // Fixes bug #9237 type = &quot;number&quot;; } // Make sure that null and NaN values aren&apos;t set. See: #7116 if ( value == null || value !== value ) { return; } // If a number was passed in, add &apos;px&apos; to the (except for certain CSS properties) if ( type === &quot;number&quot; &amp;&amp; !jQuery.cssNumber[ origName ] ) { value += &quot;px&quot;; } // Fixes #8908, it can be done more correctly by specifing setters in cssHooks, // but it would mean to define eight (for every problematic property) identical functions if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf(&quot;background&quot;) === 0 ) { style[ name ] = &quot;inherit&quot;; } // If a hook was provided, use that value, otherwise just set the specified value if ( !hooks || !(&quot;set&quot; in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) { // Support: IE // Swallow errors from &apos;invalid&apos; CSS values (#5509) try { style[ name ] = value; } catch(e) {} } } else { // If a hook was provided get the non-computed value from there if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) { return ret; } // Otherwise just get the value from the style object return style[ name ]; } }, css: function( elem, name, extra, styles ) { var num, val, hooks, origName = jQuery.camelCase( name ); // Make sure that we&apos;re working with the right name name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) ); // gets hook for the prefixed version // followed by the unprefixed version hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]; // If a hook was provided get the computed value from there if ( hooks &amp;&amp; &quot;get&quot; in hooks ) { val = hooks.get( elem, true, extra ); } // Otherwise, if a way to get the computed value exists, use that if ( val === undefined ) { val = curCSS( elem, name, styles ); } //convert &quot;normal&quot; to computed value if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) { val = cssNormalTransform[ name ]; } // Return, converting to number if forced or a qualifier was provided and val looks numeric if ( extra === &quot;&quot; || extra ) { num = parseFloat( val ); return extra === true || jQuery.isNumeric( num ) ? num || 0 : val; } return val; } }); jQuery.each([ &quot;height&quot;, &quot;width&quot; ], function( i, name ) { jQuery.cssHooks[ name ] = { get: function( elem, computed, extra ) { if ( computed ) { // certain elements can have dimension info if we invisibly show them // however, it must have a current display style that would benefit from this return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp; elem.offsetWidth === 0 ? jQuery.swap( elem, cssShow, function() { return getWidthOrHeight( elem, name, extra ); }) : getWidthOrHeight( elem, name, extra ); } }, set: function( elem, value, extra ) { var styles = extra &amp;&amp; getStyles( elem ); return setPositiveNumber( elem, value, extra ? augmentWidthOrHeight( elem, name, extra, support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;, styles ) : 0 ); } }; }); if ( !support.opacity ) { jQuery.cssHooks.opacity = { get: function( elem, computed ) { // IE uses filters for opacity return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ? ( 0.01 * parseFloat( RegExp.$1 ) ) + &quot;&quot; : computed ? &quot;1&quot; : &quot;&quot;; }, set: function( elem, value ) { var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric( value ) ? &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;, filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;; // IE has trouble with opacity if it does not have layout // Force it by setting the zoom level style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652 // if value === &quot;&quot;, then remove inline opacity #12685 if ( ( value &gt;= 1 || value === &quot;&quot; ) &amp;&amp; jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; &amp;&amp; style.removeAttribute ) { // Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave &quot;filter:&quot; in the cssText // if &quot;filter:&quot; is present at all, clearType is disabled, we want to avoid this // style.removeAttribute is IE Only, but so apparently is this code path... style.removeAttribute( &quot;filter&quot; ); // if there is no filter style applied in a css rule or unset inline opacity, we are done if ( value === &quot;&quot; || currentStyle &amp;&amp; !currentStyle.filter ) { return; } } // otherwise, set new filter values style.filter = ralpha.test( filter ) ? filter.replace( ralpha, opacity ) : filter + &quot; &quot; + opacity; } }; } jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight, function( elem, computed ) { if ( computed ) { // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right // Work around by temporarily setting element display to inline-block return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; }, curCSS, [ elem, &quot;marginRight&quot; ] ); } } ); // These hooks are used by animate to expand properties jQuery.each({ margin: &quot;&quot;, padding: &quot;&quot;, border: &quot;Width&quot; }, function( prefix, suffix ) { jQuery.cssHooks[ prefix + suffix ] = { expand: function( value ) { var i = 0, expanded = {}, // assumes a single number if not a string parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ]; for ( ; i &lt; 4; i++ ) { expanded[ prefix + cssExpand[ i ] + suffix ] = parts[ i ] || parts[ i - 2 ] || parts[ 0 ]; } return expanded; } }; if ( !rmargin.test( prefix ) ) { jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber; } }); jQuery.fn.extend({ css: function( name, value ) { return access( this, function( elem, name, value ) { var styles, len, map = {}, i = 0; if ( jQuery.isArray( name ) ) { styles = getStyles( elem ); len = name.length; for ( ; i &lt; len; i++ ) { map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles ); } return map; } return value !== undefined ? jQuery.style( elem, name, value ) : jQuery.css( elem, name ); }, name, value, arguments.length &gt; 1 ); }, show: function() { return showHide( this, true ); }, hide: function() { return showHide( this ); }, toggle: function( state ) { if ( typeof state === &quot;boolean&quot; ) { return state ? this.show() : this.hide(); } return this.each(function() { if ( isHidden( this ) ) { jQuery( this ).show(); } else { jQuery( this ).hide(); } }); } }); function Tween( elem, options, prop, end, easing ) { return new Tween.prototype.init( elem, options, prop, end, easing ); } jQuery.Tween = Tween; Tween.prototype = { constructor: Tween, init: function( elem, options, prop, end, easing, unit ) { this.elem = elem; this.prop = prop; this.easing = easing || &quot;swing&quot;; this.options = options; this.start = this.now = this.cur(); this.end = end; this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ); }, cur: function() { var hooks = Tween.propHooks[ this.prop ]; return hooks &amp;&amp; hooks.get ? hooks.get( this ) : Tween.propHooks._default.get( this ); }, run: function( percent ) { var eased, hooks = Tween.propHooks[ this.prop ]; if ( this.options.duration ) { this.pos = eased = jQuery.easing[ this.easing ]( percent, this.options.duration * percent, 0, 1, this.options.duration ); } else { this.pos = eased = percent; } this.now = ( this.end - this.start ) * eased + this.start; if ( this.options.step ) { this.options.step.call( this.elem, this.now, this ); } if ( hooks &amp;&amp; hooks.set ) { hooks.set( this ); } else { Tween.propHooks._default.set( this ); } return this; } }; Tween.prototype.init.prototype = Tween.prototype; Tween.propHooks = { _default: { get: function( tween ) { var result; if ( tween.elem[ tween.prop ] != null &amp;&amp; (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) { return tween.elem[ tween.prop ]; } // passing an empty string as a 3rd parameter to .css will automatically // attempt a parseFloat and fallback to a string if the parse fails // so, simple values such as &quot;10px&quot; are parsed to Float. // complex values such as &quot;rotate(1rad)&quot; are returned as is. result = jQuery.css( tween.elem, tween.prop, &quot;&quot; ); // Empty strings, null, undefined and &quot;auto&quot; are converted to 0. return !result || result === &quot;auto&quot; ? 0 : result; }, set: function( tween ) { // use step hook for back compat - use cssHook if its there - use .style if its // available and use plain properties where available if ( jQuery.fx.step[ tween.prop ] ) { jQuery.fx.step[ tween.prop ]( tween ); } else if ( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) { jQuery.style( tween.elem, tween.prop, tween.now + tween.unit ); } else { tween.elem[ tween.prop ] = tween.now; } } } }; // Support: IE &lt;=9 // Panic based approach to setting things on disconnected nodes Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = { set: function( tween ) { if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) { tween.elem[ tween.prop ] = tween.now; } } }; jQuery.easing = { linear: function( p ) { return p; }, swing: function( p ) { return 0.5 - Math.cos( p * Math.PI ) / 2; } }; jQuery.fx = Tween.prototype.init; // Back Compat &lt;1.8 extension point jQuery.fx.step = {}; var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; ), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = { &quot;*&quot;: [ function( prop, value ) { var tween = this.createTween( prop, value ), target = tween.cur(), parts = rfxnum.exec( value ), unit = parts &amp;&amp; parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ), // Starting value computation is required for potential unit mismatches start = ( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +target ) &amp;&amp; rfxnum.exec( jQuery.css( tween.elem, prop ) ), scale = 1, maxIterations = 20; if ( start &amp;&amp; start[ 3 ] !== unit ) { // Trust units reported by jQuery.css unit = unit || start[ 3 ]; // Make sure we update the tween properties later on parts = parts || []; // Iteratively approximate from a nonzero starting point start = +target || 1; do { // If previous iteration zeroed out, double until we get *something* // Use a string for doubling factor so we don&apos;t accidentally see scale as unchanged below scale = scale || &quot;.5&quot;; // Adjust and apply start = start / scale; jQuery.style( tween.elem, prop, start + unit ); // Update scale, tolerating zero or NaN from tween.cur() // And breaking the loop if scale is unchanged or perfect, or if we&apos;ve just had enough } while ( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations ); } // Update tween properties if ( parts ) { start = tween.start = +start || +target || 0; tween.unit = unit; // If a +=/-= token was provided, we&apos;re doing a relative animation tween.end = parts[ 1 ] ? start + ( parts[ 1 ] + 1 ) * parts[ 2 ] : +parts[ 2 ]; } return tween; } ] }; // Animations created synchronously will run synchronously function createFxNow() { setTimeout(function() { fxNow = undefined; }); return ( fxNow = jQuery.now() ); } // Generate parameters to create a standard animation function genFx( type, includeWidth ) { var which, attrs = { height: type }, i = 0; // if we include width, step value is 1 to do all cssExpand values, // if we don&apos;t include width, step value is 2 to skip over Left and Right includeWidth = includeWidth ? 1 : 0; for ( ; i &lt; 4 ; i += 2 - includeWidth ) { which = cssExpand[ i ]; attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type; } if ( includeWidth ) { attrs.opacity = attrs.width = type; } return attrs; } function createTween( value, prop, animation ) { var tween, collection = ( tweeners[ prop ] || [] ).concat( tweeners[ &quot;*&quot; ] ), index = 0, length = collection.length; for ( ; index &lt; length; index++ ) { if ( (tween = collection[ index ].call( animation, prop, value )) ) { // we&apos;re done with this property return tween; } } } function defaultPrefilter( elem, props, opts ) { /* jshint validthis: true */ var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType &amp;&amp; isHidden( elem ), dataShow = jQuery._data( elem, &quot;fxshow&quot; ); // handle queue: false promises if ( !opts.queue ) { hooks = jQuery._queueHooks( elem, &quot;fx&quot; ); if ( hooks.unqueued == null ) { hooks.unqueued = 0; oldfire = hooks.empty.fire; hooks.empty.fire = function() { if ( !hooks.unqueued ) { oldfire(); } }; } hooks.unqueued++; anim.always(function() { // doing this makes sure that the complete handler will be called // before this completes anim.always(function() { hooks.unqueued--; if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) { hooks.empty.fire(); } }); }); } // height/width overflow pass if ( elem.nodeType === 1 &amp;&amp; ( &quot;height&quot; in props || &quot;width&quot; in props ) ) { // Make sure that nothing sneaks out // Record all 3 overflow attributes because IE does not // change the overflow attribute when overflowX and // overflowY are set to the same value opts.overflow = [ style.overflow, style.overflowX, style.overflowY ]; // Set display property to inline-block for height/width // animations on inline elements that are having width/height animated display = jQuery.css( elem, &quot;display&quot; ); // Test default display if display is currently &quot;none&quot; checkDisplay = display === &quot;none&quot; ? jQuery._data( elem, &quot;olddisplay&quot; ) || defaultDisplay( elem.nodeName ) : display; if ( checkDisplay === &quot;inline&quot; &amp;&amp; jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) { // inline-level elements accept inline-block; // block-level elements need to be inline with layout if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === &quot;inline&quot; ) { style.display = &quot;inline-block&quot;; } else { style.zoom = 1; } } } if ( opts.overflow ) { style.overflow = &quot;hidden&quot;; if ( !support.shrinkWrapBlocks() ) { anim.always(function() { style.overflow = opts.overflow[ 0 ]; style.overflowX = opts.overflow[ 1 ]; style.overflowY = opts.overflow[ 2 ]; }); } } // show/hide pass for ( prop in props ) { value = props[ prop ]; if ( rfxtypes.exec( value ) ) { delete props[ prop ]; toggle = toggle || value === &quot;toggle&quot;; if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) { // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) { hidden = true; } else { continue; } } orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop ); // Any non-fx value stops us from restoring the original display value } else { display = undefined; } } if ( !jQuery.isEmptyObject( orig ) ) { if ( dataShow ) { if ( &quot;hidden&quot; in dataShow ) { hidden = dataShow.hidden; } } else { dataShow = jQuery._data( elem, &quot;fxshow&quot;, {} ); } // store state if its toggle - enables .stop().toggle() to &quot;reverse&quot; if ( toggle ) { dataShow.hidden = !hidden; } if ( hidden ) { jQuery( elem ).show(); } else { anim.done(function() { jQuery( elem ).hide(); }); } anim.done(function() { var prop; jQuery._removeData( elem, &quot;fxshow&quot; ); for ( prop in orig ) { jQuery.style( elem, prop, orig[ prop ] ); } }); for ( prop in orig ) { tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim ); if ( !( prop in dataShow ) ) { dataShow[ prop ] = tween.start; if ( hidden ) { tween.end = tween.start; tween.start = prop === &quot;width&quot; || prop === &quot;height&quot; ? 1 : 0; } } } // If this is a noop like .hide().hide(), restore an overwritten display value } else if ( (display === &quot;none&quot; ? defaultDisplay( elem.nodeName ) : display) === &quot;inline&quot; ) { style.display = display; } } function propFilter( props, specialEasing ) { var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass for ( index in props ) { name = jQuery.camelCase( index ); easing = specialEasing[ name ]; value = props[ index ]; if ( jQuery.isArray( value ) ) { easing = value[ 1 ]; value = props[ index ] = value[ 0 ]; } if ( index !== name ) { props[ name ] = value; delete props[ index ]; } hooks = jQuery.cssHooks[ name ]; if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) { value = hooks.expand( value ); delete props[ name ]; // not quite $.extend, this wont overwrite keys already present. // also - reusing &apos;index&apos; from above because we have the correct &quot;name&quot; for ( index in value ) { if ( !( index in props ) ) { props[ index ] = value[ index ]; specialEasing[ index ] = easing; } } } else { specialEasing[ name ] = easing; } } } function Animation( elem, properties, options ) { var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always( function() { // don&apos;t match elem in the :animated selector delete tick.elem; }), tick = function() { if ( stopped ) { return false; } var currentTime = fxNow || createFxNow(), remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ), // archaic crash bug won&apos;t allow us to use 1 - ( 0.5 || 0 ) (#12497) temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; for ( ; index &lt; length ; index++ ) { animation.tweens[ index ].run( percent ); } deferred.notifyWith( elem, [ animation, percent, remaining ]); if ( percent &lt; 1 &amp;&amp; length ) { return remaining; } else { deferred.resolveWith( elem, [ animation ] ); return false; } }, animation = deferred.promise({ elem: elem, props: jQuery.extend( {}, properties ), opts: jQuery.extend( true, { specialEasing: {} }, options ), originalProperties: properties, originalOptions: options, startTime: fxNow || createFxNow(), duration: options.duration, tweens: [], createTween: function( prop, end ) { var tween = jQuery.Tween( elem, animation.opts, prop, end, animation.opts.specialEasing[ prop ] || animation.opts.easing ); animation.tweens.push( tween ); return tween; }, stop: function( gotoEnd ) { var index = 0, // if we are going to the end, we want to run all the tweens // otherwise we skip this part length = gotoEnd ? animation.tweens.length : 0; if ( stopped ) { return this; } stopped = true; for ( ; index &lt; length ; index++ ) { animation.tweens[ index ].run( 1 ); } // resolve when we played the last frame // otherwise, reject if ( gotoEnd ) { deferred.resolveWith( elem, [ animation, gotoEnd ] ); } else { deferred.rejectWith( elem, [ animation, gotoEnd ] ); } return this; } }), props = animation.props; propFilter( props, animation.opts.specialEasing ); for ( ; index &lt; length ; index++ ) { result = animationPrefilters[ index ].call( animation, elem, props, animation.opts ); if ( result ) { return result; } } jQuery.map( props, createTween, animation ); if ( jQuery.isFunction( animation.opts.start ) ) { animation.opts.start.call( elem, animation ); } jQuery.fx.timer( jQuery.extend( tick, { elem: elem, anim: animation, queue: animation.opts.queue }) ); // attach callbacks from options return animation.progress( animation.opts.progress ) .done( animation.opts.done, animation.opts.complete ) .fail( animation.opts.fail ) .always( animation.opts.always ); } jQuery.Animation = jQuery.extend( Animation, { tweener: function( props, callback ) { if ( jQuery.isFunction( props ) ) { callback = props; props = [ &quot;*&quot; ]; } else { props = props.split(&quot; &quot;); } var prop, index = 0, length = props.length; for ( ; index &lt; length ; index++ ) { prop = props[ index ]; tweeners[ prop ] = tweeners[ prop ] || []; tweeners[ prop ].unshift( callback ); } }, prefilter: function( callback, prepend ) { if ( prepend ) { animationPrefilters.unshift( callback ); } else { animationPrefilters.push( callback ); } } }); jQuery.speed = function( speed, easing, fn ) { var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : { complete: fn || !fn &amp;&amp; easing || jQuery.isFunction( speed ) &amp;&amp; speed, duration: speed, easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing }; opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &quot;number&quot; ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot; if ( opt.queue == null || opt.queue === true ) { opt.queue = &quot;fx&quot;; } // Queueing opt.old = opt.complete; opt.complete = function() { if ( jQuery.isFunction( opt.old ) ) { opt.old.call( this ); } if ( opt.queue ) { jQuery.dequeue( this, opt.queue ); } }; return opt; }; jQuery.fn.extend({ fadeTo: function( speed, to, easing, callback ) { // show any hidden elements after setting opacity to 0 return this.filter( isHidden ).css( &quot;opacity&quot;, 0 ).show() // animate to the value specified .end().animate({ opacity: to }, speed, easing, callback ); }, animate: function( prop, speed, easing, callback ) { var empty = jQuery.isEmptyObject( prop ), optall = jQuery.speed( speed, easing, callback ), doAnimation = function() { // Operate on a copy of prop so per-property easing won&apos;t be lost var anim = Animation( this, jQuery.extend( {}, prop ), optall ); // Empty animations, or finishing resolves immediately if ( empty || jQuery._data( this, &quot;finish&quot; ) ) { anim.stop( true ); } }; doAnimation.finish = doAnimation; return empty || optall.queue === false ? this.each( doAnimation ) : this.queue( optall.queue, doAnimation ); }, stop: function( type, clearQueue, gotoEnd ) { var stopQueue = function( hooks ) { var stop = hooks.stop; delete hooks.stop; stop( gotoEnd ); }; if ( typeof type !== &quot;string&quot; ) { gotoEnd = clearQueue; clearQueue = type; type = undefined; } if ( clearQueue &amp;&amp; type !== false ) { this.queue( type || &quot;fx&quot;, [] ); } return this.each(function() { var dequeue = true, index = type != null &amp;&amp; type + &quot;queueHooks&quot;, timers = jQuery.timers, data = jQuery._data( this ); if ( index ) { if ( data[ index ] &amp;&amp; data[ index ].stop ) { stopQueue( data[ index ] ); } } else { for ( index in data ) { if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) { stopQueue( data[ index ] ); } } } for ( index = timers.length; index--; ) { if ( timers[ index ].elem === this &amp;&amp; (type == null || timers[ index ].queue === type) ) { timers[ index ].anim.stop( gotoEnd ); dequeue = false; timers.splice( index, 1 ); } } // start the next in the queue if the last step wasn&apos;t forced // timers currently will call their complete callbacks, which will dequeue // but only if they were gotoEnd if ( dequeue || !gotoEnd ) { jQuery.dequeue( this, type ); } }); }, finish: function( type ) { if ( type !== false ) { type = type || &quot;fx&quot;; } return this.each(function() { var index, data = jQuery._data( this ), queue = data[ type + &quot;queue&quot; ], hooks = data[ type + &quot;queueHooks&quot; ], timers = jQuery.timers, length = queue ? queue.length : 0; // enable finishing flag on private data data.finish = true; // empty the queue first jQuery.queue( this, type, [] ); if ( hooks &amp;&amp; hooks.stop ) { hooks.stop.call( this, true ); } // look for any active animations, and finish them for ( index = timers.length; index--; ) { if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) { timers[ index ].anim.stop( true ); timers.splice( index, 1 ); } } // look for any animations in the old queue and finish them for ( index = 0; index &lt; length; index++ ) { if ( queue[ index ] &amp;&amp; queue[ index ].finish ) { queue[ index ].finish.call( this ); } } // turn off finishing flag delete data.finish; }); } }); jQuery.each([ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) { var cssFn = jQuery.fn[ name ]; jQuery.fn[ name ] = function( speed, easing, callback ) { return speed == null || typeof speed === &quot;boolean&quot; ? cssFn.apply( this, arguments ) : this.animate( genFx( name, true ), speed, easing, callback ); }; }); // Generate shortcuts for custom animations jQuery.each({ slideDown: genFx(&quot;show&quot;), slideUp: genFx(&quot;hide&quot;), slideToggle: genFx(&quot;toggle&quot;), fadeIn: { opacity: &quot;show&quot; }, fadeOut: { opacity: &quot;hide&quot; }, fadeToggle: { opacity: &quot;toggle&quot; } }, function( name, props ) { jQuery.fn[ name ] = function( speed, easing, callback ) { return this.animate( props, speed, easing, callback ); }; }); jQuery.timers = []; jQuery.fx.tick = function() { var timer, timers = jQuery.timers, i = 0; fxNow = jQuery.now(); for ( ; i &lt; timers.length; i++ ) { timer = timers[ i ]; // Checks the timer has not already been removed if ( !timer() &amp;&amp; timers[ i ] === timer ) { timers.splice( i--, 1 ); } } if ( !timers.length ) { jQuery.fx.stop(); } fxNow = undefined; }; jQuery.fx.timer = function( timer ) { jQuery.timers.push( timer ); if ( timer() ) { jQuery.fx.start(); } else { jQuery.timers.pop(); } }; jQuery.fx.interval = 13; jQuery.fx.start = function() { if ( !timerId ) { timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval ); } }; jQuery.fx.stop = function() { clearInterval( timerId ); timerId = null; }; jQuery.fx.speeds = { slow: 600, fast: 200, // Default speed _default: 400 }; // Based off of the plugin by Clint Helfers, with permission. // http://blindsignals.com/index.php/2009/07/jquery-delay/ jQuery.fn.delay = function( time, type ) { time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time; type = type || &quot;fx&quot;; return this.queue( type, function( next, hooks ) { var timeout = setTimeout( next, time ); hooks.stop = function() { clearTimeout( timeout ); }; }); }; (function() { // Minified: var a,b,c,d,e var input, div, select, a, opt; // Setup div = document.createElement( &quot;div&quot; ); div.setAttribute( &quot;className&quot;, &quot;t&quot; ); div.innerHTML = &quot; &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&apos;/a&apos;&gt;a&lt;/a&gt;&lt;input type=&apos;checkbox&apos;/&gt;&quot;; a = div.getElementsByTagName(&quot;a&quot;)[ 0 ]; // First batch of tests. select = document.createElement(&quot;select&quot;); opt = select.appendChild( document.createElement(&quot;option&quot;) ); input = div.getElementsByTagName(&quot;input&quot;)[ 0 ]; a.style.cssText = &quot;top:1px&quot;; // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7) support.getSetAttribute = div.className !== &quot;t&quot;; // Get the style information from getAttribute // (IE uses .cssText instead) support.style = /top/.test( a.getAttribute(&quot;style&quot;) ); // Make sure that URLs aren&apos;t manipulated // (IE normalizes it by default) support.hrefNormalized = a.getAttribute(&quot;href&quot;) === &quot;/a&quot;; // Check the default checkbox/radio value (&quot;&quot; on WebKit; &quot;on&quot; elsewhere) support.checkOn = !!input.value; // Make sure that a selected-by-default option has a working selected property. // (WebKit defaults to false instead of true, IE too, if it&apos;s in an optgroup) support.optSelected = opt.selected; // Tests for enctype support on a form (#6743) support.enctype = !!document.createElement(&quot;form&quot;).enctype; // Make sure that the options inside disabled selects aren&apos;t marked as disabled // (WebKit marks them as disabled) select.disabled = true; support.optDisabled = !opt.disabled; // Support: IE8 only // Check if we can trust getAttribute(&quot;value&quot;) input = document.createElement( &quot;input&quot; ); input.setAttribute( &quot;value&quot;, &quot;&quot; ); support.input = input.getAttribute( &quot;value&quot; ) === &quot;&quot;; // Check if an input maintains its value after becoming a radio input.value = &quot;t&quot;; input.setAttribute( &quot;type&quot;, &quot;radio&quot; ); support.radioValue = input.value === &quot;t&quot;; })(); var rreturn = /\r/g; jQuery.fn.extend({ val: function( value ) { var hooks, ret, isFunction, elem = this[0]; if ( !arguments.length ) { if ( elem ) { hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ]; if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) { return ret; } ret = elem.value; return typeof ret === &quot;string&quot; ? // handle most common string cases ret.replace(rreturn, &quot;&quot;) : // handle cases where value is null/undef or number ret == null ? &quot;&quot; : ret; } return; } isFunction = jQuery.isFunction( value ); return this.each(function( i ) { var val; if ( this.nodeType !== 1 ) { return; } if ( isFunction ) { val = value.call( this, i, jQuery( this ).val() ); } else { val = value; } // Treat null/undefined as &quot;&quot;; convert numbers to string if ( val == null ) { val = &quot;&quot;; } else if ( typeof val === &quot;number&quot; ) { val += &quot;&quot;; } else if ( jQuery.isArray( val ) ) { val = jQuery.map( val, function( value ) { return value == null ? &quot;&quot; : value + &quot;&quot;; }); } hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ]; // If set returns undefined, fall back to normal setting if ( !hooks || !(&quot;set&quot; in hooks) || hooks.set( this, val, &quot;value&quot; ) === undefined ) { this.value = val; } }); } }); jQuery.extend({ valHooks: { option: { get: function( elem ) { var val = jQuery.find.attr( elem, &quot;value&quot; ); return val != null ? val : // Support: IE10-11+ // option.text throws exceptions (#14686, #14858) jQuery.trim( jQuery.text( elem ) ); } }, select: { get: function( elem ) { var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === &quot;select-one&quot; || index &lt; 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index &lt; 0 ? max : one ? index : 0; // Loop through all the selected options for ( ; i &lt; max; i++ ) { option = options[ i ]; // oldIE doesn&apos;t update selected after form reset (#2551) if ( ( option.selected || i === index ) &amp;&amp; // Don&apos;t return options that are disabled or in a disabled optgroup ( support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null ) &amp;&amp; ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) { // Get the specific value for the option value = jQuery( option ).val(); // We don&apos;t need an array for one selects if ( one ) { return value; } // Multi-Selects return an array values.push( value ); } } return values; }, set: function( elem, value ) { var optionSet, option, options = elem.options, values = jQuery.makeArray( value ), i = options.length; while ( i-- ) { option = options[ i ]; if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt;= 0 ) { // Support: IE6 // When new option element is added to select box we need to // force reflow of newly added node in order to workaround delay // of initialization properties try { option.selected = optionSet = true; } catch ( _ ) { // Will be executed only in IE6 option.scrollHeight; } } else { option.selected = false; } } // Force browsers to behave consistently when non-matching value is set if ( !optionSet ) { elem.selectedIndex = -1; } return options; } } } }); // Radios and checkboxes getter/setter jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() { jQuery.valHooks[ this ] = { set: function( elem, value ) { if ( jQuery.isArray( value ) ) { return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 ); } } }; if ( !support.checkOn ) { jQuery.valHooks[ this ].get = function( elem ) { // Support: Webkit // &quot;&quot; is returned instead of &quot;on&quot; if a value isn&apos;t specified return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value; }; } }); var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input; jQuery.fn.extend({ attr: function( name, value ) { return access( this, jQuery.attr, name, value, arguments.length &gt; 1 ); }, removeAttr: function( name ) { return this.each(function() { jQuery.removeAttr( this, name ); }); } }); jQuery.extend({ attr: function( elem, name, value ) { var hooks, ret, nType = elem.nodeType; // don&apos;t get/set attributes on text, comment and attribute nodes if ( !elem || nType === 3 || nType === 8 || nType === 2 ) { return; } // Fallback to prop when attributes are not supported if ( typeof elem.getAttribute === strundefined ) { return jQuery.prop( elem, name, value ); } // All attributes are lowercase // Grab necessary hook if one is defined if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) { name = name.toLowerCase(); hooks = jQuery.attrHooks[ name ] || ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook ); } if ( value !== undefined ) { if ( value === null ) { jQuery.removeAttr( elem, name ); } else if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) { return ret; } else { elem.setAttribute( name, value + &quot;&quot; ); return value; } } else if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) { return ret; } else { ret = jQuery.find.attr( elem, name ); // Non-existent attributes return null, we normalize to undefined return ret == null ? undefined : ret; } }, removeAttr: function( elem, value ) { var name, propName, i = 0, attrNames = value &amp;&amp; value.match( rnotwhite ); if ( attrNames &amp;&amp; elem.nodeType === 1 ) { while ( (name = attrNames[i++]) ) { propName = jQuery.propFix[ name ] || name; // Boolean attributes get special treatment (#10870) if ( jQuery.expr.match.bool.test( name ) ) { // Set corresponding property to false if ( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) { elem[ propName ] = false; // Support: IE&lt;9 // Also clear defaultChecked/defaultSelected (if appropriate) } else { elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] = elem[ propName ] = false; } // See #9699 for explanation of this approach (setting first, then removal) } else { jQuery.attr( elem, name, &quot;&quot; ); } elem.removeAttribute( getSetAttribute ? name : propName ); } } }, attrHooks: { type: { set: function( elem, value ) { if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) { // Setting the type on a radio button after the value resets the value in IE6-9 // Reset value to default in case type is set after value during creation var val = elem.value; elem.setAttribute( &quot;type&quot;, value ); if ( val ) { elem.value = val; } return value; } } } } }); // Hook for boolean attributes boolHook = { set: function( elem, value, name ) { if ( value === false ) { // Remove boolean attributes when set to false jQuery.removeAttr( elem, name ); } else if ( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) { // IE&lt;8 needs the *property* name elem.setAttribute( !getSetAttribute &amp;&amp; jQuery.propFix[ name ] || name, name ); // Use defaultChecked and defaultSelected for oldIE } else { elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] = elem[ name ] = true; } return name; } }; // Retrieve booleans specially jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) { var getter = attrHandle[ name ] || jQuery.find.attr; attrHandle[ name ] = getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ? function( elem, name, isXML ) { var ret, handle; if ( !isXML ) { // Avoid an infinite loop by temporarily removing this function from the getter handle = attrHandle[ name ]; attrHandle[ name ] = ret; ret = getter( elem, name, isXML ) != null ? name.toLowerCase() : null; attrHandle[ name ] = handle; } return ret; } : function( elem, name, isXML ) { if ( !isXML ) { return elem[ jQuery.camelCase( &quot;default-&quot; + name ) ] ? name.toLowerCase() : null; } }; }); // fix oldIE attroperties if ( !getSetInput || !getSetAttribute ) { jQuery.attrHooks.value = { set: function( elem, value, name ) { if ( jQuery.nodeName( elem, &quot;input&quot; ) ) { // Does not return so that setAttribute is also used elem.defaultValue = value; } else { // Use nodeHook if defined (#1954); otherwise setAttribute is fine return nodeHook &amp;&amp; nodeHook.set( elem, value, name ); } } }; } // IE6/7 do not support getting/setting some attributes with get/setAttribute if ( !getSetAttribute ) { // Use this for any attribute in IE6/7 // This fixes almost every IE6/7 issue nodeHook = { set: function( elem, value, name ) { // Set the existing or create a new attribute node var ret = elem.getAttributeNode( name ); if ( !ret ) { elem.setAttributeNode( (ret = elem.ownerDocument.createAttribute( name )) ); } ret.value = value += &quot;&quot;; // Break association with cloned elements by also using setAttribute (#9646) if ( name === &quot;value&quot; || value === elem.getAttribute( name ) ) { return value; } } }; // Some attributes are constructed with empty-string values when not defined attrHandle.id = attrHandle.name = attrHandle.coords = function( elem, name, isXML ) { var ret; if ( !isXML ) { return (ret = elem.getAttributeNode( name )) &amp;&amp; ret.value !== &quot;&quot; ? ret.value : null; } }; // Fixing value retrieval on a button requires this module jQuery.valHooks.button = { get: function( elem, name ) { var ret = elem.getAttributeNode( name ); if ( ret &amp;&amp; ret.specified ) { return ret.value; } }, set: nodeHook.set }; // Set contenteditable to false on removals(#10429) // Setting to empty string throws an error as an invalid value jQuery.attrHooks.contenteditable = { set: function( elem, value, name ) { nodeHook.set( elem, value === &quot;&quot; ? false : value, name ); } }; // Set width and height to auto instead of 0 on empty string( Bug #8150 ) // This is for removals jQuery.each([ &quot;width&quot;, &quot;height&quot; ], function( i, name ) { jQuery.attrHooks[ name ] = { set: function( elem, value ) { if ( value === &quot;&quot; ) { elem.setAttribute( name, &quot;auto&quot; ); return value; } } }; }); } if ( !support.style ) { jQuery.attrHooks.style = { get: function( elem ) { // Return undefined in the case of empty string // Note: IE uppercases css property names, but if we were to .toLowerCase() // .cssText, that would destroy case senstitivity in URL&apos;s, like in &quot;background&quot; return elem.style.cssText || undefined; }, set: function( elem, value ) { return ( elem.style.cssText = value + &quot;&quot; ); } }; } var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i; jQuery.fn.extend({ prop: function( name, value ) { return access( this, jQuery.prop, name, value, arguments.length &gt; 1 ); }, removeProp: function( name ) { name = jQuery.propFix[ name ] || name; return this.each(function() { // try/catch handles cases where IE balks (such as removing a property on window) try { this[ name ] = undefined; delete this[ name ]; } catch( e ) {} }); } }); jQuery.extend({ propFix: { &quot;for&quot;: &quot;htmlFor&quot;, &quot;class&quot;: &quot;className&quot; }, prop: function( elem, name, value ) { var ret, hooks, notxml, nType = elem.nodeType; // don&apos;t get/set properties on text, comment and attribute nodes if ( !elem || nType === 3 || nType === 8 || nType === 2 ) { return; } notxml = nType !== 1 || !jQuery.isXMLDoc( elem ); if ( notxml ) { // Fix name and attach hooks name = jQuery.propFix[ name ] || name; hooks = jQuery.propHooks[ name ]; } if ( value !== undefined ) { return hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ? ret : ( elem[ name ] = value ); } else { return hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ? ret : elem[ name ]; } }, propHooks: { tabIndex: { get: function( elem ) { // elem.tabIndex doesn&apos;t always return the correct value when it hasn&apos;t been explicitly set // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ // Use proper attribute retrieval(#12072) var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; ); return tabindex ? parseInt( tabindex, 10 ) : rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ? 0 : -1; } } } }); // Some attributes require a special call on IE // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx if ( !support.hrefNormalized ) { // href/src property should get the full normalized URL (#10299/#12915) jQuery.each([ &quot;href&quot;, &quot;src&quot; ], function( i, name ) { jQuery.propHooks[ name ] = { get: function( elem ) { return elem.getAttribute( name, 4 ); } }; }); } // Support: Safari, IE9+ // mis-reports the default selected property of an option // Accessing the parent&apos;s selectedIndex property fixes it if ( !support.optSelected ) { jQuery.propHooks.selected = { get: function( elem ) { var parent = elem.parentNode; if ( parent ) { parent.selectedIndex; // Make sure that it also works with optgroups, see #5701 if ( parent.parentNode ) { parent.parentNode.selectedIndex; } } return null; } }; } jQuery.each([ &quot;tabIndex&quot;, &quot;readOnly&quot;, &quot;maxLength&quot;, &quot;cellSpacing&quot;, &quot;cellPadding&quot;, &quot;rowSpan&quot;, &quot;colSpan&quot;, &quot;useMap&quot;, &quot;frameBorder&quot;, &quot;contentEditable&quot; ], function() { jQuery.propFix[ this.toLowerCase() ] = this; }); // IE6/7 call enctype encoding if ( !support.enctype ) { jQuery.propFix.enctype = &quot;encoding&quot;; } var rclass = /[\t\r\n\f]/g; jQuery.fn.extend({ addClass: function( value ) { var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === &quot;string&quot; &amp;&amp; value; if ( jQuery.isFunction( value ) ) { return this.each(function( j ) { jQuery( this ).addClass( value.call( this, j, this.className ) ); }); } if ( proceed ) { // The disjunction here is for better compressibility (see removeClass) classes = ( value || &quot;&quot; ).match( rnotwhite ) || []; for ( ; i &lt; len; i++ ) { elem = this[ i ]; cur = elem.nodeType === 1 &amp;&amp; ( elem.className ? ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) : &quot; &quot; ); if ( cur ) { j = 0; while ( (clazz = classes[j++]) ) { if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) { cur += clazz + &quot; &quot;; } } // only assign if different to avoid unneeded rendering. finalValue = jQuery.trim( cur ); if ( elem.className !== finalValue ) { elem.className = finalValue; } } } } return this; }, removeClass: function( value ) { var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === &quot;string&quot; &amp;&amp; value; if ( jQuery.isFunction( value ) ) { return this.each(function( j ) { jQuery( this ).removeClass( value.call( this, j, this.className ) ); }); } if ( proceed ) { classes = ( value || &quot;&quot; ).match( rnotwhite ) || []; for ( ; i &lt; len; i++ ) { elem = this[ i ]; // This expression is here for better compressibility (see addClass) cur = elem.nodeType === 1 &amp;&amp; ( elem.className ? ( &quot; &quot; + elem.className + &quot; &quot; ).replace( rclass, &quot; &quot; ) : &quot;&quot; ); if ( cur ) { j = 0; while ( (clazz = classes[j++]) ) { // Remove *all* instances while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt;= 0 ) { cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; ); } } // only assign if different to avoid unneeded rendering. finalValue = value ? jQuery.trim( cur ) : &quot;&quot;; if ( elem.className !== finalValue ) { elem.className = finalValue; } } } } return this; }, toggleClass: function( value, stateVal ) { var type = typeof value; if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; type === &quot;string&quot; ) { return stateVal ? this.addClass( value ) : this.removeClass( value ); } if ( jQuery.isFunction( value ) ) { return this.each(function( i ) { jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal ); }); } return this.each(function() { if ( type === &quot;string&quot; ) { // toggle individual class names var className, i = 0, self = jQuery( this ), classNames = value.match( rnotwhite ) || []; while ( (className = classNames[ i++ ]) ) { // check each className given, space separated list if ( self.hasClass( className ) ) { self.removeClass( className ); } else { self.addClass( className ); } } // Toggle whole class name } else if ( type === strundefined || type === &quot;boolean&quot; ) { if ( this.className ) { // store className if set jQuery._data( this, &quot;__className__&quot;, this.className ); } // If the element has a class name or if we&apos;re passed &quot;false&quot;, // then remove the whole classname (if there was one, the above saved it). // Otherwise bring back whatever was previously saved (if anything), // falling back to the empty string if nothing was stored. this.className = this.className || value === false ? &quot;&quot; : jQuery._data( this, &quot;__className__&quot; ) || &quot;&quot;; } }); }, hasClass: function( selector ) { var className = &quot; &quot; + selector + &quot; &quot;, i = 0, l = this.length; for ( ; i &lt; l; i++ ) { if ( this[i].nodeType === 1 &amp;&amp; (&quot; &quot; + this[i].className + &quot; &quot;).replace(rclass, &quot; &quot;).indexOf( className ) &gt;= 0 ) { return true; } } return false; } }); // Return jQuery for attributes-only inclusion jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; + &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; + &quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) { // Handle event binding jQuery.fn[ name ] = function( data, fn ) { return arguments.length &gt; 0 ? this.on( name, null, data, fn ) : this.trigger( name ); }; }); jQuery.fn.extend({ hover: function( fnOver, fnOut ) { return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver ); }, bind: function( types, data, fn ) { return this.on( types, null, data, fn ); }, unbind: function( types, fn ) { return this.off( types, null, fn ); }, delegate: function( selector, types, data, fn ) { return this.on( types, selector, data, fn ); }, undelegate: function( selector, types, fn ) { // ( namespace ) or ( selector, types [, fn] ) return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn ); } }); var nonce = jQuery.now(); var rquery = (/\?/); var rvalidtokens = /(,)|(\[|{)|(}|])|&quot;(?:[^&quot;\\\r\n]|\\[&quot;\\\/bfnrt]|\\u[\da-fA-F]{4})*&quot;\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g; jQuery.parseJSON = function( data ) { // Attempt to parse using the native JSON parser first if ( window.JSON &amp;&amp; window.JSON.parse ) { // Support: Android 2.3 // Workaround failure to string-cast null input return window.JSON.parse( data + &quot;&quot; ); } var requireNonComma, depth = null, str = jQuery.trim( data + &quot;&quot; ); // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains // after removing valid tokens return str &amp;&amp; !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) { // Force termination if we see a misplaced comma if ( requireNonComma &amp;&amp; comma ) { depth = 0; } // Perform no more replacements after returning to outermost depth if ( depth === 0 ) { return token; } // Commas must not follow &quot;[&quot;, &quot;{&quot;, or &quot;,&quot; requireNonComma = open || comma; // Determine new depth // array/object open (&quot;[&quot; or &quot;{&quot;): depth += true - false (increment) // array/object close (&quot;]&quot; or &quot;}&quot;): depth += false - true (decrement) // other cases (&quot;,&quot; or primitive): depth += true - true (numeric cast) depth += !close - !open; // Remove this token return &quot;&quot;; }) ) ? ( Function( &quot;return &quot; + str ) )() : jQuery.error( &quot;Invalid JSON: &quot; + data ); }; // Cross-browser xml parsing jQuery.parseXML = function( data ) { var xml, tmp; if ( !data || typeof data !== &quot;string&quot; ) { return null; } try { if ( window.DOMParser ) { // Standard tmp = new DOMParser(); xml = tmp.parseFromString( data, &quot;text/xml&quot; ); } else { // IE xml = new ActiveXObject( &quot;Microsoft.XMLDOM&quot; ); xml.async = &quot;false&quot;; xml.loadXML( data ); } } catch( e ) { xml = undefined; } if ( !xml || !xml.documentElement || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) { jQuery.error( &quot;Invalid XML: &quot; + data ); } return xml; }; var // Document location ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&amp;])_=[^&amp;]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL // #7653, #8125, #8152: local protocol detection rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, /* Prefilters * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example) * 2) These are called: * - BEFORE asking for a transport * - AFTER param serialization (s.data is a string if s.processData is true) * 3) key is the dataType * 4) the catchall symbol &quot;*&quot; can be used * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed */ prefilters = {}, /* Transports bindings * 1) key is the dataType * 2) the catchall symbol &quot;*&quot; can be used * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed */ transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression allTypes = &quot;*/&quot;.concat(&quot;*&quot;); // #8138, IE may throw an exception when accessing // a field from window.location if document.domain has been set try { ajaxLocation = location.href; } catch( e ) { // Use the href attribute of an A element // since IE will modify it given document.location ajaxLocation = document.createElement( &quot;a&quot; ); ajaxLocation.href = &quot;&quot;; ajaxLocation = ajaxLocation.href; } // Segment location into parts ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || []; // Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport function addToPrefiltersOrTransports( structure ) { // dataTypeExpression is optional and defaults to &quot;*&quot; return function( dataTypeExpression, func ) { if ( typeof dataTypeExpression !== &quot;string&quot; ) { func = dataTypeExpression; dataTypeExpression = &quot;*&quot;; } var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || []; if ( jQuery.isFunction( func ) ) { // For each dataType in the dataTypeExpression while ( (dataType = dataTypes[i++]) ) { // Prepend if requested if ( dataType.charAt( 0 ) === &quot;+&quot; ) { dataType = dataType.slice( 1 ) || &quot;*&quot;; (structure[ dataType ] = structure[ dataType ] || []).unshift( func ); // Otherwise append } else { (structure[ dataType ] = structure[ dataType ] || []).push( func ); } } } }; } // Base inspection function for prefilters and transports function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) { var inspected = {}, seekingTransport = ( structure === transports ); function inspect( dataType ) { var selected; inspected[ dataType ] = true; jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) { var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR ); if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) { options.dataTypes.unshift( dataTypeOrTransport ); inspect( dataTypeOrTransport ); return false; } else if ( seekingTransport ) { return !( selected = dataTypeOrTransport ); } }); return selected; } return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; ); } // A special extend for ajax options // that takes &quot;flat&quot; options (not to be deep extended) // Fixes #9887 function ajaxExtend( target, src ) { var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {}; for ( key in src ) { if ( src[ key ] !== undefined ) { ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ]; } } if ( deep ) { jQuery.extend( true, target, deep ); } return target; } /* Handles responses to an ajax request: * - finds the right dataType (mediates between content-type and expected dataType) * - returns the corresponding response */ function ajaxHandleResponses( s, jqXHR, responses ) { var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process while ( dataTypes[ 0 ] === &quot;*&quot; ) { dataTypes.shift(); if ( ct === undefined ) { ct = s.mimeType || jqXHR.getResponseHeader(&quot;Content-Type&quot;); } } // Check if we&apos;re dealing with a known content-type if ( ct ) { for ( type in contents ) { if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) { dataTypes.unshift( type ); break; } } } // Check to see if we have a response for the expected dataType if ( dataTypes[ 0 ] in responses ) { finalDataType = dataTypes[ 0 ]; } else { // Try convertible dataTypes for ( type in responses ) { if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) { finalDataType = type; break; } if ( !firstDataType ) { firstDataType = type; } } // Or just use first one finalDataType = finalDataType || firstDataType; } // If we found a dataType // We add the dataType to the list if needed // and return the corresponding response if ( finalDataType ) { if ( finalDataType !== dataTypes[ 0 ] ) { dataTypes.unshift( finalDataType ); } return responses[ finalDataType ]; } } /* Chain conversions given the request and the original response * Also sets the responseXXX fields on the jqXHR instance */ function ajaxConvert( s, response, jqXHR, isSuccess ) { var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys if ( dataTypes[ 1 ] ) { for ( conv in s.converters ) { converters[ conv.toLowerCase() ] = s.converters[ conv ]; } } current = dataTypes.shift(); // Convert to each sequential dataType while ( current ) { if ( s.responseFields[ current ] ) { jqXHR[ s.responseFields[ current ] ] = response; } // Apply the dataFilter if provided if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) { response = s.dataFilter( response, s.dataType ); } prev = current; current = dataTypes.shift(); if ( current ) { // There&apos;s only work to do if current dataType is non-auto if ( current === &quot;*&quot; ) { current = prev; // Convert response if prev dataType is non-auto and differs from current } else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) { // Seek a direct converter conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ]; // If none found, seek a pair if ( !conv ) { for ( conv2 in converters ) { // If conv2 outputs current tmp = conv2.split( &quot; &quot; ); if ( tmp[ 1 ] === current ) { // If prev can be converted to accepted input conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] || converters[ &quot;* &quot; + tmp[ 0 ] ]; if ( conv ) { // Condense equivalence converters if ( conv === true ) { conv = converters[ conv2 ]; // Otherwise, insert the intermediate dataType } else if ( converters[ conv2 ] !== true ) { current = tmp[ 0 ]; dataTypes.unshift( tmp[ 1 ] ); } break; } } } } // Apply converter (if not an equivalence) if ( conv !== true ) { // Unless errors are allowed to bubble, catch and return them if ( conv &amp;&amp; s[ &quot;throws&quot; ] ) { response = conv( response ); } else { try { response = conv( response ); } catch ( e ) { return { state: &quot;parsererror&quot;, error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current }; } } } } } } return { state: &quot;success&quot;, data: response }; } jQuery.extend({ // Counter for holding the number of active queries active: 0, // Last-Modified header cache for next request lastModified: {}, etag: {}, ajaxSettings: { url: ajaxLocation, type: &quot;GET&quot;, isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ), global: true, processData: true, async: true, contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, /* timeout: 0, data: null, dataType: null, username: null, password: null, cache: null, throws: false, traditional: false, headers: {}, */ accepts: { &quot;*&quot;: allTypes, text: &quot;text/plain&quot;, html: &quot;text/html&quot;, xml: &quot;application/xml, text/xml&quot;, json: &quot;application/json, text/javascript&quot; }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: &quot;responseXML&quot;, text: &quot;responseText&quot;, json: &quot;responseJSON&quot; }, // Data converters // Keys separate source (or catchall &quot;*&quot;) and destination types with a single space converters: { // Convert anything to text &quot;* text&quot;: String, // Text to html (true = no transformation) &quot;text html&quot;: true, // Evaluate text as a json expression &quot;text json&quot;: jQuery.parseJSON, // Parse text as xml &quot;text xml&quot;: jQuery.parseXML }, // For options that shouldn&apos;t be deep extended: // you can add your own custom options here if // and when you create one that shouldn&apos;t be // deep extended (see ajaxExtend) flatOptions: { url: true, context: true } }, // Creates a full fledged settings object into target // with both ajaxSettings and settings fields. // If target is omitted, writes into ajaxSettings. ajaxSetup: function( target, settings ) { return settings ? // Building a settings object ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) : // Extending ajaxSettings ajaxExtend( jQuery.ajaxSettings, target ); }, ajaxPrefilter: addToPrefiltersOrTransports( prefilters ), ajaxTransport: addToPrefiltersOrTransports( transports ), // Main method ajax: function( url, options ) { // If url is an object, simulate pre-1.5 signature if ( typeof url === &quot;object&quot; ) { options = url; url = undefined; } // Force options to be an object options = options || {}; var // Cross-domain detection vars parts, // Loop variable i, // URL without anti-cache param cacheURL, // Response headers as string responseHeadersString, // timeout handle timeoutTimer, // To know if global events are to be dispatched fireGlobals, transport, // Response headers responseHeaders, // Create the final options object s = jQuery.ajaxSetup( {}, options ), // Callbacks context callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ? jQuery( callbackContext ) : jQuery.event, // Deferreds deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks(&quot;once memory&quot;), // Status-dependent callbacks statusCode = s.statusCode || {}, // Headers (they are sent all at once) requestHeaders = {}, requestHeadersNames = {}, // The jqXHR state state = 0, // Default abort message strAbort = &quot;canceled&quot;, // Fake xhr jqXHR = { readyState: 0, // Builds headers hashtable if needed getResponseHeader: function( key ) { var match; if ( state === 2 ) { if ( !responseHeaders ) { responseHeaders = {}; while ( (match = rheaders.exec( responseHeadersString )) ) { responseHeaders[ match[1].toLowerCase() ] = match[ 2 ]; } } match = responseHeaders[ key.toLowerCase() ]; } return match == null ? null : match; }, // Raw string getAllResponseHeaders: function() { return state === 2 ? responseHeadersString : null; }, // Caches the header setRequestHeader: function( name, value ) { var lname = name.toLowerCase(); if ( !state ) { name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name; requestHeaders[ name ] = value; } return this; }, // Overrides response content-type header overrideMimeType: function( type ) { if ( !state ) { s.mimeType = type; } return this; }, // Status-dependent callbacks statusCode: function( map ) { var code; if ( map ) { if ( state &lt; 2 ) { for ( code in map ) { // Lazy-add the new callback in a way that preserves old ones statusCode[ code ] = [ statusCode[ code ], map[ code ] ]; } } else { // Execute the appropriate callbacks jqXHR.always( map[ jqXHR.status ] ); } } return this; }, // Cancel the request abort: function( statusText ) { var finalText = statusText || strAbort; if ( transport ) { transport.abort( finalText ); } done( 0, finalText ); return this; } }; // Attach deferreds deferred.promise( jqXHR ).complete = completeDeferred.add; jqXHR.success = jqXHR.done; jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion) // Add protocol if not provided (#5866: IE7 issue with protocol-less urls) // Handle falsy url in the settings object (#10093: consistency with old signature) // We also use the url parameter if available s.url = ( ( url || s.url || ajaxLocation ) + &quot;&quot; ).replace( rhash, &quot;&quot; ).replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; ); // Alias method option to type as per ticket #12004 s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().match( rnotwhite ) || [ &quot;&quot; ]; // A cross-domain request is in order when we have a protocol:host:port mismatch if ( s.crossDomain == null ) { parts = rurl.exec( s.url.toLowerCase() ); s.crossDomain = !!( parts &amp;&amp; ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] || ( parts[ 3 ] || ( parts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) !== ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot; ) ) ) ); } // Convert data if not already a string if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) { s.data = jQuery.param( s.data, s.traditional ); } // Apply prefilters inspectPrefiltersOrTransports( prefilters, s, options, jqXHR ); // If request was aborted inside a prefilter, stop there if ( state === 2 ) { return jqXHR; } // We can fire global events as of now if asked to // Don&apos;t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118) fireGlobals = jQuery.event &amp;&amp; s.global; // Watch for a new set of requests if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) { jQuery.event.trigger(&quot;ajaxStart&quot;); } // Uppercase the type s.type = s.type.toUpperCase(); // Determine if request has content s.hasContent = !rnoContent.test( s.type ); // Save the URL in case we&apos;re toying with the If-Modified-Since // and/or If-None-Match header later on cacheURL = s.url; // More options handling for requests with no content if ( !s.hasContent ) { // If data is available, append data to url if ( s.data ) { cacheURL = ( s.url += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data ); // #9682: remove data so that it&apos;s not used in an eventual retry delete s.data; } // Add anti-cache in url if needed if ( s.cache === false ) { s.url = rts.test( cacheURL ) ? // If there is already a &apos;_&apos; parameter, set its value cacheURL.replace( rts, &quot;$1_=&quot; + nonce++ ) : // Otherwise add one to the end cacheURL + ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + nonce++; } } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. if ( s.ifModified ) { if ( jQuery.lastModified[ cacheURL ] ) { jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] ); } if ( jQuery.etag[ cacheURL ] ) { jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] ); } } // Set the correct header, if data is being sent if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) { jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType ); } // Set the Accepts header for the server, depending on the dataType jqXHR.setRequestHeader( &quot;Accept&quot;, s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ? s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) : s.accepts[ &quot;*&quot; ] ); // Check for headers option for ( i in s.headers ) { jqXHR.setRequestHeader( i, s.headers[ i ] ); } // Allow custom headers/mimetypes and early abort if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) { // Abort if not done already and return return jqXHR.abort(); } // aborting is no longer a cancellation strAbort = &quot;abort&quot;; // Install callbacks on deferreds for ( i in { success: 1, error: 1, complete: 1 } ) { jqXHR[ i ]( s[ i ] ); } // Get transport transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR ); // If no transport, we auto-abort if ( !transport ) { done( -1, &quot;No Transport&quot; ); } else { jqXHR.readyState = 1; // Send global event if ( fireGlobals ) { globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] ); } // Timeout if ( s.async &amp;&amp; s.timeout &gt; 0 ) { timeoutTimer = setTimeout(function() { jqXHR.abort(&quot;timeout&quot;); }, s.timeout ); } try { state = 1; transport.send( requestHeaders, done ); } catch ( e ) { // Propagate exception as error if not done if ( state &lt; 2 ) { done( -1, e ); // Simply rethrow otherwise } else { throw e; } } } // Callback for when everything is done function done( status, nativeStatusText, responses, headers ) { var isSuccess, success, error, response, modified, statusText = nativeStatusText; // Called once if ( state === 2 ) { return; } // State is &quot;done&quot; now state = 2; // Clear timeout if it exists if ( timeoutTimer ) { clearTimeout( timeoutTimer ); } // Dereference transport for early garbage collection // (no matter how long the jqXHR object will be used) transport = undefined; // Cache response headers responseHeadersString = headers || &quot;&quot;; // Set readyState jqXHR.readyState = status &gt; 0 ? 4 : 0; // Determine if successful isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304; // Get response data if ( responses ) { response = ajaxHandleResponses( s, jqXHR, responses ); } // Convert no matter what (that way responseXXX fields are always set) response = ajaxConvert( s, response, jqXHR, isSuccess ); // If successful, handle type chaining if ( isSuccess ) { // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. if ( s.ifModified ) { modified = jqXHR.getResponseHeader(&quot;Last-Modified&quot;); if ( modified ) { jQuery.lastModified[ cacheURL ] = modified; } modified = jqXHR.getResponseHeader(&quot;etag&quot;); if ( modified ) { jQuery.etag[ cacheURL ] = modified; } } // if no content if ( status === 204 || s.type === &quot;HEAD&quot; ) { statusText = &quot;nocontent&quot;; // if not modified } else if ( status === 304 ) { statusText = &quot;notmodified&quot;; // If we have data, let&apos;s convert it } else { statusText = response.state; success = response.data; error = response.error; isSuccess = !error; } } else { // We extract error from statusText // then normalize statusText and status for non-aborts error = statusText; if ( status || !statusText ) { statusText = &quot;error&quot;; if ( status &lt; 0 ) { status = 0; } } } // Set data for the fake xhr object jqXHR.status = status; jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;; // Success/Error if ( isSuccess ) { try { // 容错，不同场景下success状态不可预知 if (success &amp;&amp; success.submitToken &amp;&amp; success.submitCode) { window.X_Anti_Forge_Token = success.submitToken; // 自动更新X_Anti_Forge_Token window.X_Anti_Forge_Code = success.submitCode; // 自动更新X_Anti_Forge_Code } } catch (e) {} deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] ); } else { deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] ); } // Status-dependent callbacks jqXHR.statusCode( statusCode ); statusCode = undefined; if ( fireGlobals ) { globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;, [ jqXHR, s, isSuccess ? success : error ] ); } // Complete completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] ); if ( fireGlobals ) { globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] ); // Handle the global AJAX counter if ( !( --jQuery.active ) ) { jQuery.event.trigger(&quot;ajaxStop&quot;); } } } return jqXHR; }, getJSON: function( url, data, callback ) { return jQuery.get( url, data, callback, &quot;json&quot; ); }, getScript: function( url, callback ) { return jQuery.get( url, undefined, callback, &quot;script&quot; ); } }); jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) { jQuery[ method ] = function( url, data, callback, type ) { // shift arguments if data argument was omitted if ( jQuery.isFunction( data ) ) { type = type || callback; callback = data; data = undefined; } return jQuery.ajax({ url: url, type: method, dataType: type, data: data, success: callback }); }; }); jQuery._evalUrl = function( url ) { return jQuery.ajax({ url: url, type: &quot;GET&quot;, dataType: &quot;script&quot;, async: false, global: false, &quot;throws&quot;: true }); }; jQuery.fn.extend({ wrapAll: function( html ) { if ( jQuery.isFunction( html ) ) { return this.each(function(i) { jQuery(this).wrapAll( html.call(this, i) ); }); } if ( this[0] ) { // The elements to wrap the target around var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true); if ( this[0].parentNode ) { wrap.insertBefore( this[0] ); } wrap.map(function() { var elem = this; while ( elem.firstChild &amp;&amp; elem.firstChild.nodeType === 1 ) { elem = elem.firstChild; } return elem; }).append( this ); } return this; }, wrapInner: function( html ) { if ( jQuery.isFunction( html ) ) { return this.each(function(i) { jQuery(this).wrapInner( html.call(this, i) ); }); } return this.each(function() { var self = jQuery( this ), contents = self.contents(); if ( contents.length ) { contents.wrapAll( html ); } else { self.append( html ); } }); }, wrap: function( html ) { var isFunction = jQuery.isFunction( html ); return this.each(function(i) { jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html ); }); }, unwrap: function() { return this.parent().each(function() { if ( !jQuery.nodeName( this, &quot;body&quot; ) ) { jQuery( this ).replaceWith( this.childNodes ); } }).end(); } }); jQuery.expr.filters.hidden = function( elem ) { // Support: Opera &lt;= 12.12 // Opera reports offsetWidths and offsetHeights less than zero on some elements return elem.offsetWidth &lt;= 0 &amp;&amp; elem.offsetHeight &lt;= 0 || (!support.reliableHiddenOffsets() &amp;&amp; ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem, &quot;display&quot; )) === &quot;none&quot;); }; jQuery.expr.filters.visible = function( elem ) { return !jQuery.expr.filters.hidden( elem ); }; var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i; function buildParams( prefix, obj, traditional, add ) { var name; if ( jQuery.isArray( obj ) ) { // Serialize array item. jQuery.each( obj, function( i, v ) { if ( traditional || rbracket.test( prefix ) ) { // Treat each array item as a scalar. add( prefix, v ); } else { // Item is non-scalar (array or object), encode its numeric index. buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add ); } }); } else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) { // Serialize object item. for ( name in obj ) { buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add ); } } else { // Serialize scalar item. add( prefix, obj ); } } // Serialize an array of form elements or a set of // key/values into a query string jQuery.param = function( a, traditional ) { var prefix, s = [], add = function( key, value ) { // If value is a function, invoke it and return its value value = jQuery.isFunction( value ) ? value() : ( value == null ? &quot;&quot; : value ); s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value ); }; // Set traditional to true for jQuery &lt;= 1.3.2 behavior. if ( traditional === undefined ) { traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional; } // If an array was passed in, assume that it is an array of form elements. if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) { // Serialize the form elements jQuery.each( a, function() { add( this.name, this.value ); }); } else { // If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older // did it), otherwise encode params recursively. for ( prefix in a ) { buildParams( prefix, a[ prefix ], traditional, add ); } } // Return the resulting serialization return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; ); }; jQuery.fn.extend({ serialize: function() { return jQuery.param( this.serializeArray() ); }, serializeArray: function() { return this.map(function() { // Can add propHook for &quot;elements&quot; to filter or add form elements var elements = jQuery.prop( this, &quot;elements&quot; ); return elements ? jQuery.makeArray( elements ) : this; }) .filter(function() { var type = this.type; // Use .is(&quot;:disabled&quot;) so that fieldset[disabled] works return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp; rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp; ( this.checked || !rcheckableType.test( type ) ); }) .map(function( i, elem ) { var val = jQuery( this ).val(); return val == null ? null : jQuery.isArray( val ) ? jQuery.map( val, function( val ) { return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) }; }) : { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) }; }).get(); } }); // Create the request object // (This is still attached to ajaxSettings for backward compatibility) jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? // Support: IE6+ function() { // XHR cannot access local files, always use ActiveX for that case return !this.isLocal &amp;&amp; // Support: IE7-8 // oldIE XHR does not support non-RFC2616 methods (#13240) // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9 // Although this check for six methods instead of eight // since IE also does not support &quot;trace&quot; and &quot;connect&quot; /^(get|post|head|put|delete|options)$/i.test( this.type ) &amp;&amp; createStandardXHR() || createActiveXHR(); } : // For all other browsers, use the standard XMLHttpRequest object createStandardXHR; var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr(); // Support: IE&lt;10 // Open requests must be manually aborted on unload (#5280) // See https://support.microsoft.com/kb/2856746 for more info if ( window.attachEvent ) { window.attachEvent( &quot;onunload&quot;, function() { for ( var key in xhrCallbacks ) { xhrCallbacks[ key ]( undefined, true ); } }); } // Determine support properties support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported ); xhrSupported = support.ajax = !!xhrSupported; // Create transport if the browser can provide an xhr if ( xhrSupported ) { jQuery.ajaxTransport(function( options ) { // Cross domain only allowed if supported through XMLHttpRequest if ( !options.crossDomain || support.cors ) { var callback; return { send: function( headers, complete ) { var i, xhr = options.xhr(), id = ++xhrId; // Open the socket xhr.open( options.type, options.url, options.async, options.username, options.password ); // Apply custom fields if provided if ( options.xhrFields ) { for ( i in options.xhrFields ) { xhr[ i ] = options.xhrFields[ i ]; } } // Override mime type if needed if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) { xhr.overrideMimeType( options.mimeType ); } // X-Requested-With header // For cross-domain requests, seeing as conditions for a preflight are // akin to a jigsaw puzzle, we simply never set it to be sure. // (it can always be set on a per-request basis or even using ajaxSetup) // For same-domain requests, won&apos;t change header if already provided. if ( !options.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) { headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;; headers[&quot;X-Anit-Forge-Token&quot;] = window.X_Anti_Forge_Token || &apos;None&apos;; // 全局Token校验 headers[&quot;X-Anit-Forge-Code&quot;] = window.X_Anti_Forge_Code || &apos;0&apos;; // 全局Code校验 } // Set headers for ( i in headers ) { // Support: IE&lt;9 // IE&apos;s ActiveXObject throws a &apos;Type Mismatch&apos; exception when setting // request header to a null-value. // // To keep consistent with other XHR implementations, cast the value // to string and ignore `undefined`. if ( headers[ i ] !== undefined ) { xhr.setRequestHeader( i, headers[ i ] + &quot;&quot; ); } } // Do send the request // This may raise an exception which is actually // handled in jQuery.ajax (so no try/catch here) xhr.send( ( options.hasContent &amp;&amp; options.data ) || null ); // Listener callback = function( _, isAbort ) { var status, statusText, responses; // Was never called and is aborted or complete if ( callback &amp;&amp; ( isAbort || xhr.readyState === 4 ) ) { // Clean up delete xhrCallbacks[ id ]; callback = undefined; xhr.onreadystatechange = jQuery.noop; // Abort manually if needed if ( isAbort ) { if ( xhr.readyState !== 4 ) { xhr.abort(); } } else { responses = {}; status = xhr.status; // Support: IE&lt;10 // Accessing binary-data responseText throws an exception // (#11426) if ( typeof xhr.responseText === &quot;string&quot; ) { responses.text = xhr.responseText; } // Firefox throws an exception when accessing // statusText for faulty cross-domain requests try { statusText = xhr.statusText; } catch( e ) { // We normalize with Webkit giving an empty statusText statusText = &quot;&quot;; } // Filter status for non standard behaviors // If the request is local and we have data: assume a success // (success with no data won&apos;t get notified, that&apos;s the best we // can do given current implementations) if ( !status &amp;&amp; options.isLocal &amp;&amp; !options.crossDomain ) { status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204 } else if ( status === 1223 ) { status = 204; } } } // Call complete if needed if ( responses ) { complete( status, statusText, responses, xhr.getAllResponseHeaders() ); } }; if ( !options.async ) { // if we&apos;re in sync mode we fire the callback callback(); } else if ( xhr.readyState === 4 ) { // (IE6 &amp; IE7) if it&apos;s in cache and has been // retrieved directly we need to fire the callback setTimeout( callback ); } else { // Add to the list of active xhr callbacks xhr.onreadystatechange = xhrCallbacks[ id ] = callback; } }, abort: function() { if ( callback ) { callback( undefined, true ); } } }; } }); } // Functions to create xhrs function createStandardXHR() { try { return new window.XMLHttpRequest(); } catch( e ) {} } function createActiveXHR() { try { return new window.ActiveXObject( &quot;Microsoft.XMLHTTP&quot; ); } catch( e ) {} } // Install script dataType jQuery.ajaxSetup({ accepts: { script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot; }, contents: { script: /(?:java|ecma)script/ }, converters: { &quot;text script&quot;: function( text ) { jQuery.globalEval( text ); return text; } } }); // Handle cache&apos;s special case and global jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) { if ( s.cache === undefined ) { s.cache = false; } if ( s.crossDomain ) { s.type = &quot;GET&quot;; s.global = false; } }); // Bind script tag hack transport jQuery.ajaxTransport( &quot;script&quot;, function(s) { // This transport only deals with cross domain requests if ( s.crossDomain ) { var script, head = document.head || jQuery(&quot;head&quot;)[0] || document.documentElement; return { send: function( _, callback ) { script = document.createElement(&quot;script&quot;); script.async = true; if ( s.scriptCharset ) { script.charset = s.scriptCharset; } script.src = s.url; // Attach handlers for all browsers script.onload = script.onreadystatechange = function( _, isAbort ) { if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) { // Handle memory leak in IE script.onload = script.onreadystatechange = null; // Remove the script if ( script.parentNode ) { script.parentNode.removeChild( script ); } // Dereference the script script = null; // Callback if not abort if ( !isAbort ) { callback( 200, &quot;success&quot; ); } } }; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending // Use native DOM manipulation to avoid our domManip AJAX trickery head.insertBefore( script, head.firstChild ); }, abort: function() { if ( script ) { script.onload( undefined, true ); } } }; } }); var oldCallbacks = [], rjsonp = /(=)\?(?=&amp;|$)|\?\?/; // Default jsonp settings jQuery.ajaxSetup({ jsonp: &quot;callback&quot;, jsonpCallback: function() { var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) ); this[ callback ] = true; return callback; } }); // Detect, normalize options and install callbacks for jsonp requests jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) { var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ? &quot;url&quot; : typeof s.data === &quot;string&quot; &amp;&amp; !( s.contentType || &quot;&quot; ).indexOf(&quot;application/x-www-form-urlencoded&quot;) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; &quot;data&quot; ); // Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) { // Get callback name, remembering preexisting value associated with it callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data if ( jsonProp ) { s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName ); } else if ( s.jsonp !== false ) { s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName; } // Use data converter to retrieve json after script execution s.converters[&quot;script json&quot;] = function() { if ( !responseContainer ) { jQuery.error( callbackName + &quot; was not called&quot; ); } return responseContainer[ 0 ]; }; // force json dataType s.dataTypes[ 0 ] = &quot;json&quot;; // Install callback overwritten = window[ callbackName ]; window[ callbackName ] = function() { responseContainer = arguments; }; // Clean-up function (fires after converters) jqXHR.always(function() { // Restore preexisting value window[ callbackName ] = overwritten; // Save back as free if ( s[ callbackName ] ) { // make sure that re-using the options doesn&apos;t screw things around s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use oldCallbacks.push( callbackName ); } // Call if it was a function and we have a response if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) { overwritten( responseContainer[ 0 ] ); } responseContainer = overwritten = undefined; }); // Delegate to script return &quot;script&quot;; } }); // data: string of html // context (optional): If specified, the fragment will be created in this context, defaults to document // keepScripts (optional): If true, will include scripts passed in the html string jQuery.parseHTML = function( data, context, keepScripts ) { if ( !data || typeof data !== &quot;string&quot; ) { return null; } if ( typeof context === &quot;boolean&quot; ) { keepScripts = context; context = false; } context = context || document; var parsed = rsingleTag.exec( data ), scripts = !keepScripts &amp;&amp; []; // Single tag if ( parsed ) { return [ context.createElement( parsed[1] ) ]; } parsed = jQuery.buildFragment( [ data ], context, scripts ); if ( scripts &amp;&amp; scripts.length ) { jQuery( scripts ).remove(); } return jQuery.merge( [], parsed.childNodes ); }; // Keep a copy of the old load method var _load = jQuery.fn.load; /** * Load a url into a page */ jQuery.fn.load = function( url, params, callback ) { if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) { return _load.apply( this, arguments ); } var selector, response, type, self = this, off = url.indexOf(&quot; &quot;); if ( off &gt;= 0 ) { selector = jQuery.trim( url.slice( off, url.length ) ); url = url.slice( 0, off ); } // If it&apos;s a function if ( jQuery.isFunction( params ) ) { // We assume that it&apos;s the callback callback = params; params = undefined; // Otherwise, build a param string } else if ( params &amp;&amp; typeof params === &quot;object&quot; ) { type = &quot;POST&quot;; } // If we have elements to modify, make the request if ( self.length &gt; 0 ) { jQuery.ajax({ url: url, // if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used type: type, dataType: &quot;html&quot;, data: params }).done(function( responseText ) { // Save response for use in complete callback response = arguments; self.html( selector ? // If a selector was specified, locate the right elements in a dummy div // Exclude scripts to avoid IE &apos;Permission Denied&apos; errors jQuery(&quot;&lt;div&gt;&quot;).append( jQuery.parseHTML( responseText ) ).find( selector ) : // Otherwise use the full result responseText ); }).complete( callback &amp;&amp; function( jqXHR, status ) { self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] ); }); } return this; }; // Attach a bunch of functions for handling common AJAX events jQuery.each( [ &quot;ajaxStart&quot;, &quot;ajaxStop&quot;, &quot;ajaxComplete&quot;, &quot;ajaxError&quot;, &quot;ajaxSuccess&quot;, &quot;ajaxSend&quot; ], function( i, type ) { jQuery.fn[ type ] = function( fn ) { return this.on( type, fn ); }; }); jQuery.expr.filters.animated = function( elem ) { return jQuery.grep(jQuery.timers, function( fn ) { return elem === fn.elem; }).length; }; var docElem = window.document.documentElement; /** * Gets a window from an element */ function getWindow( elem ) { return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false; } jQuery.offset = { setOffset: function( elem, options, i ) { var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css( elem, &quot;position&quot; ), curElem = jQuery( elem ), props = {}; // set position first, in-case top/left are set even on static elem if ( position === &quot;static&quot; ) { elem.style.position = &quot;relative&quot;; } curOffset = curElem.offset(); curCSSTop = jQuery.css( elem, &quot;top&quot; ); curCSSLeft = jQuery.css( elem, &quot;left&quot; ); calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp; jQuery.inArray(&quot;auto&quot;, [ curCSSTop, curCSSLeft ] ) &gt; -1; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed if ( calculatePosition ) { curPosition = curElem.position(); curTop = curPosition.top; curLeft = curPosition.left; } else { curTop = parseFloat( curCSSTop ) || 0; curLeft = parseFloat( curCSSLeft ) || 0; } if ( jQuery.isFunction( options ) ) { options = options.call( elem, i, curOffset ); } if ( options.top != null ) { props.top = ( options.top - curOffset.top ) + curTop; } if ( options.left != null ) { props.left = ( options.left - curOffset.left ) + curLeft; } if ( &quot;using&quot; in options ) { options.using.call( elem, props ); } else { curElem.css( props ); } } }; jQuery.fn.extend({ offset: function( options ) { if ( arguments.length ) { return options === undefined ? this : this.each(function( i ) { jQuery.offset.setOffset( this, options, i ); }); } var docElem, win, box = { top: 0, left: 0 }, elem = this[ 0 ], doc = elem &amp;&amp; elem.ownerDocument; if ( !doc ) { return; } docElem = doc.documentElement; // Make sure it&apos;s not a disconnected DOM node if ( !jQuery.contains( docElem, elem ) ) { return box; } // If we don&apos;t have gBCR, just use 0,0 rather than error // BlackBerry 5, iOS 3 (original iPhone) if ( typeof elem.getBoundingClientRect !== strundefined ) { box = elem.getBoundingClientRect(); } win = getWindow( doc ); return { top: box.top + ( win.pageYOffset || docElem.scrollTop ) - ( docElem.clientTop || 0 ), left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 ) }; }, position: function() { if ( !this[ 0 ] ) { return; } var offsetParent, offset, parentOffset = { top: 0, left: 0 }, elem = this[ 0 ]; // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) { // we assume that getBoundingClientRect is available when computed position is fixed offset = elem.getBoundingClientRect(); } else { // Get *real* offsetParent offsetParent = this.offsetParent(); // Get correct offsets offset = this.offset(); if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) { parentOffset = offsetParent.offset(); } // Add offsetParent borders parentOffset.top += jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ); parentOffset.left += jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true ); } // Subtract parent offsets and element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 return { top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ), left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true) }; }, offsetParent: function() { return this.map(function() { var offsetParent = this.offsetParent || docElem; while ( offsetParent &amp;&amp; ( !jQuery.nodeName( offsetParent, &quot;html&quot; ) &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) ) { offsetParent = offsetParent.offsetParent; } return offsetParent || docElem; }); } }); // Create scrollLeft and scrollTop methods jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) { var top = /Y/.test( prop ); jQuery.fn[ method ] = function( val ) { return access( this, function( elem, method, val ) { var win = getWindow( elem ); if ( val === undefined ) { return win ? (prop in win) ? win[ prop ] : win.document.documentElement[ method ] : elem[ method ]; } if ( win ) { win.scrollTo( !top ? val : jQuery( win ).scrollLeft(), top ? val : jQuery( win ).scrollTop() ); } else { elem[ method ] = val; } }, method, val, arguments.length, null ); }; }); // Add the top/left cssHooks using jQuery.fn.position // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084 // getComputedStyle returns percent when specified for top/left/bottom/right // rather than make the css module depend on the offset module, we just check for it here jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) { jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition, function( elem, computed ) { if ( computed ) { computed = curCSS( elem, prop ); // if curCSS returns percentage, fallback to offset return rnumnonpx.test( computed ) ? jQuery( elem ).position()[ prop ] + &quot;px&quot; : computed; } } ); }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) { jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name }, function( defaultExtra, funcName ) { // margin is only for outerHeight, outerWidth jQuery.fn[ funcName ] = function( margin, value ) { var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ), extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; ); return access( this, function( elem, type, value ) { var doc; if ( jQuery.isWindow( elem ) ) { // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there // isn&apos;t a whole lot we can do. See pull request at this URL for discussion: // https://github.com/jquery/jquery/pull/764 return elem.document.documentElement[ &quot;client&quot; + name ]; } // Get document width or height if ( elem.nodeType === 9 ) { doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it. return Math.max( elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ], elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ], doc[ &quot;client&quot; + name ] ); } return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat jQuery.css( elem, type, extra ) : // Set width or height on the element jQuery.style( elem, type, value, extra ); }, type, chainable ? margin : undefined, chainable, null ); }; }); }); // The number of elements contained in the matched element set jQuery.fn.size = function() { return this.length; }; jQuery.fn.andSelf = jQuery.fn.addBack; // Register as a named AMD module, since jQuery can be concatenated with other // files that may use define, but not via a proper concatenation script that // understands anonymous AMD modules. A named AMD is safest and most robust // way to register. Lowercase jquery is used because AMD module names are // derived from file names, and jQuery is normally delivered in a lowercase // file name. Do this after creating the global so that if an AMD module wants // to call noConflict to hide this version of jQuery, it will work. // Note that for maximum portability, libraries that are not jQuery should // declare themselves as anonymous modules, and avoid setting a global if an // AMD loader is present. jQuery is a special case. For more information, see // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) { define( &quot;jquery&quot;, [], function() { return jQuery; }); } var // Map over jQuery in case of overwrite _jQuery = window.jQuery, // Map over the $ in case of overwrite _$ = window.$; jQuery.noConflict = function( deep ) { if ( window.$ === jQuery ) { window.$ = _$; } if ( deep &amp;&amp; window.jQuery === jQuery ) { window.jQuery = _jQuery; } return jQuery; }; // Expose jQuery and $ identifiers, even in // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557) // and CommonJS for browser emulators (#13566) if ( typeof noGlobal === strundefined ) { window.jQuery = window.$ = jQuery; } return jQuery; }));]]></content>
      <categories>
        <category>JQ</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ源码解析--从入门到理解]]></title>
    <url>%2F2017%2F11%2F07%2FJQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[接上篇没说完的地方 8、表达式 在 jQuery 中，大量的使用了短路表达式与多重短路表达式。 短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可 以确定是真或假，求值过程便告终止 举个 🌰 function siblingCheck(a, b) { var cur = b &amp;&amp; a, diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp; (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // other code ... } var a = 1, b = 0, c = 3; var foo = a &amp;&amp; b &amp;&amp; c, // 0 ,相当于 a &amp;&amp; (b &amp;&amp; c) bar = a || b || c; // 1 ※※※在 Javascript 的逻辑运算中，0、””、null、false、undefined、NaN 都会判定为 false ，而其他都为 true ； 9、预定义常用方法的入口 (function(window, undefined) { var // 定义了一个对象变量，一个字符串变量，一个数组变量 class2type = {}, core_version = &quot;1.10.2&quot;, core_deletedIds = [], // 保存了对象、字符串、数组的一些常用方法 concat push 等等... core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim; })(window); 这里首先定义了一个对象变量、一个字符串变量、数组变量、常用的核心方法 jQuery.fn = jQuery.prototype = { // ... // 将 jQuery 对象转换成数组类型 toArray: function() { // 调用数组的 slice 方法，使用预先定义好了的 core_slice ，节省查找内存地址时间，提高效率 // 相当于 return Array.prototype.slice.call(this) return core_slice.call(this); } } 10、钩子（适配器原理） 在正常的代码逻辑中使用钩子去适配一些特殊的属性，样式或事件，这样可以让我们少写很多 else if 语句 jQuery 里的表驱动 hook 实现，$.type 方法： function(window, undefined) { var // 用于预存储一张类型表用于 hook class2type = {}; // 原生的 typeof 方法并不能区分出一个变量它是 Array 、RegExp 等 object 类型，jQuery 为了扩展 typeof 的表达力，因此有了 $.type 方法 // 针对一些特殊的对象（例如 null，Array，RegExp）也进行精准的类型判断 // 运用了钩子机制，判断类型前，将常见类型打表，先存于一个 Hash 表 class2type 里边 jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) { class2type[&quot;[object &quot; + name + &quot;]&quot;] = name.toLowerCase(); }); jQuery.extend({ // 确定JavaScript 对象的类型 // 这个方法的关键之处在于 class2type[core_toString.call(obj)] // 可以使得 typeof obj 为 &quot;object&quot; 类型的得到更进一步的精确判断 type: function(obj) { if (obj == null) { return String(obj); } // 利用事先存好的 hash 表 class2type 作精准判断 // 这里因为 hook 的存在，省去了大量的 else if 判断 return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ? class2type[core_toString.call(obj)] || &quot;object&quot; : typeof obj; } }) })(window); 推荐博客: http://www.cnblogs.com/aaronjs/category/511281.html http://www.cnblogs.com/coco1s/category/799728.html]]></content>
      <categories>
        <category>JQ</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ源码解析--从放弃到入门]]></title>
    <url>%2F2017%2F11%2F07%2FJQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BB%8E%E6%94%BE%E5%BC%83%E5%88%B0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[仔细想想 用了那么多年JQ却从来没仔细研究过他的源码😨😨😨😨😨😨😨 知道前两天被小伙伴质疑，突然觉得 真心应该花点时间仔细研究一下!要不都对不起这么多年写过的BUG。。。。 BUT 每次一看源码总是头大。。。。。。 所以 浏览了一些大神的博客 从中找了一些经典的整理总结一下 嘿嘿 So如有雷同 嫑介意哈 🙂 JQ整体架构 -&gt; { 1、变量，常规正则初始化 2、工具方法 3、$.ready() 4、复杂选择器 5、回调对象：$.callback() 6、延迟对象：对异步的统一管理 $.deferred() 7、浏览器功能检测$.support 8、数据存储$.data 9、队列方法：执行顺序的管理 10、对元素属性的操作 11、事件操作的各种方法 12、DOM操作 13、样式操作 14、AJAX() 15、动画 16、位置和尺寸 17、模块化 18、jQuery } JQ的整体结构看上去还是划分的蛮清晰的，BUT以上每个代码模块其实真心难看难懂😢😢😢😢，9000多行代码怎么看，真心想哭 所以 小仙女 就在这以自己觉得 还算是比较容易理解的角度给大家说一说吧 再说之前，推荐个工具 👇 JQ源码查看工具 http://www.css88.com/tool/jQuerySourceViewer 真心好用 可以已选择您想查看的JQ的版本，并筛选里面想要查看的方法源码 首先 JQ有一个规则 就是可能出现在任意模块的公共变量，方法，正则等全部定义在脚本的最上方，然后每个模块自己会用到的公 共变量，方法，正则等会定义到这个模块的上方 MAYBE 看的时候 可能会出现要前后代码来回跳跃，SO 我们最好先不要在意这些细节，因为你现在看见的变量也许在脚本结尾才会 被调用。。。 1、jQuery 闭包结构 // 用一个函数域包起来，就是所谓的沙箱 // 在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局 // 把当前沙箱需要的外部变量通过函数参数引入进来 // 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 (function(window, undefined) { // jQuery 代码 })(window); 将代码包裹在一个闭包中，既不会污染全局，又方便好用，真是机智啊。。。。在最后暴露出$和JQuery这两个变量出来， 大大降低了冲突的可能性。 // 压缩策略 // w -&gt; windwow , u -&gt; undefined (function(w, u) { })(window); 2、拒绝new 使用JQ的时候我们一般都会使用无new构造 // 无 new 构造 $(‘#test’).text(‘Test’); // 当然也可以使用 new var test = new $(&apos;#test&apos;); test.text(&apos;Test&apos;); 其实无NEW构造就相当于new jQuery()，看一下源码是怎么定义的 (function(window, undefined) { var // ... jQuery = function(selector, context) { // The jQuery object is actually just the init constructor &apos;enhanced&apos; // 看这里，实例化方法 jQuery() 实际上是调用了其拓展的原型方法 jQuery.fn.init return new jQuery.fn.init(selector, context, rootjQuery); }, // jQuery.prototype 即是 jQuery 的原型，挂载在上面的方法，即可让所有生成的 jQuery 对象使用 jQuery.fn = jQuery.prototype = { // 实例化化方法，这个方法可以称作 jQuery 对象构造器 init: function(selector, context, rootjQuery) { // ... } } // 这一句很关键，也很绕 // jQuery 没有使用 new 运算符将 jQuery 实例化，而是直接调用其函数 // 要实现这样,那么 jQuery 就要看成一个类，且返回一个正确的实例 // 且实例还要能正确访问 jQuery 类原型上的属性与方法 // jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype // 所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法 jQuery.fn.init.prototype = jQuery.fn; })(window); ① 首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。 ② 将jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。 ③ 也就是实例化方法存在这么一个关系链 👇 jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ; new jQuery.fn.init() 相当于 new jQuery() ; jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。 3、方法的重载 JQ使用了大量的方法重载，绕呀绕呀 就把小可爱们弄蒙啦，小仙女也是看着看着就跑偏了 举个 🌰 // 获取 name 属性的值 $(‘#id’).attr(‘name’); // 设置 name 属性的值 $(‘#id’).attr(‘name’,’jQuery’); // 获取 css 某个属性的值 $(‘#id’).css(‘height’); // 设置 css 某个属性的值 $(‘#id’).css(‘height’,’100px’); 啥是方法重载那？说你白了就是一个方法实现了很多个弄能，虽然读起来不太容易，但还是很好用的。 大多数人使用 jQuery() 构造方法使用的最多的就是直接实例化一个 jQuery 对象，但其实在它的内部实现中，有着 9种不同的方法重载场景：看介里 👇 // 接受一个字符串，其中包含了用于匹配元素集合的 CSS 选择器 jQuery([selector,[context]]) // 传入单个 DOM jQuery(element) // 传入 DOM 数组 jQuery(elementArray) // 传入 JS 对象 jQuery(object) // 传入 jQuery 对象 jQuery(jQuery object) // 传入原始 HTML 的字符串来创建 DOM 元素 jQuery(html,[ownerDocument]) jQuery(html,[attributes]) // 传入空参数 jQuery() // 绑定一个在 DOM 文档载入完成后执行的函数 jQuery(callback) 大家可以一边看那API一边区分各种场景 4、 jQuery.fn.extend 与 jQuery.extend extend()是jq用来扩展静态方法和实例方法的，and一些开发过jq插件的小伙伴肯定对这个方法一点也不陌生 开发插件的时候也会用到它。但是在JQ中实际是有两个extend()的。那我们怎么区分那？ ① jQuery.extend(): 把两个或者更多的对象合并到第一个当中 ② jQuery.fn.extend()：把对象挂载到 jQuery 的 prototype 属性，来扩展一个新的 jQuery 实例方法。 这是比较官方的解释 结论：也就是说，使用 jQuery.extend() 拓展的静态方法，我们可以直接使用 $.xxx 进行调用（xxx是拓展的方法名）， 而使用 jQuery.fn.extend() 拓展的实例方法，需要使用 $().xxx 调用。 ※jQuery.fn.extend(object) 给 jQuery 对象添加实例方法，也就是通过这个 extend 添加的新方法，实例化的 jQuery 对象都能使用，因为它是挂载在 jQuery.fn 上的方法（上文有提到，jQuery.fn = jQuery.prototype ）。 来看一下源码吧 👇 （比较长） // 扩展合并函数 // 合并两个或更多对象的属性到第一个对象中，jQuery 后续的大部分功能都通过该函数扩展 // 虽然实现方式一样，但是要注意区分用法的不一样，那么为什么两个方法指向同一个函数实现，但是却实现不同的功能呢, // 阅读源码就能发现这归功于 this 的强大力量 // 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象 target // 如果只传入一个对象，则将对象的属性添加到 jQuery 对象中，也就是添加静态方法 // 用这种方式，我们可以为 jQuery 命名空间增加新的方法，可以用于编写 jQuery 插件 // 如果不想改变传入的对象，可以传入一个空对象：$.extend({}, object1, object2); // 默认合并操作是不迭代的，即便 target 的某个属性是对象或属性，也会被完全覆盖而不是合并 // 如果第一个参数是 true，则是深拷贝 // 从 object 原型继承的属性会被拷贝，值为 undefined 的属性不会被拷贝 // 因为性能原因，JavaScript jQuery.extend = jQuery.fn.extend = function() { var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation // target 是传入的第一个参数 // 如果第一个参数是布尔类型，则表示是否要深递归， if (typeof target === &quot;boolean&quot;) { deep = target; target = arguments[1] || {}; // skip the boolean and the target // 如果传了类型为 boolean 的第一个参数，i 则从 2 开始 i = 2; } // Handle case when target is a string or something (possible in deep copy) // 如果传入的第一个参数是 字符串或者其他 if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) { target = {}; } // extend jQuery itself if only one argument is passed // 如果参数的长度为 1 ，表示是 jQuery 静态方法 if (length === i) { target = this; --i; } // 可以传入多个复制源 // i 是从 1或2 开始的 for (; i &lt; length; i++) { // Only deal with non-null/undefined values // 将每个源的属性全部复制到 target 上 if ((options = arguments[i]) != null) { // Extend the base object for (name in options) { // src 是源（即本身）的值 // copy 是即将要复制过去的值 src = target[name]; copy = options[name]; // Prevent never-ending loop // 防止有环，例如 extend(true, target, {&apos;target&apos;:target}); if (target === copy) { continue; } // Recurse if we&apos;re merging plain objects or arrays // 这里是递归调用，最终都会到下面的 else if 分支 // jQuery.isPlainObject 用于测试是否为纯粹的对象 // 纯粹的对象指的是 通过 &quot;{}&quot; 或者 &quot;new Object&quot; 创建的 // 如果是深复制 if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) { // 数组 if (copyIsArray) { copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; // 对象 } else { clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}; } // Never move original objects, clone them // 递归 target[name] = jQuery.extend(deep, clone, copy); // Don&apos;t bring in undefined values // 最终都会到这条分支 // 简单的值覆盖 } else if (copy !== undefined) { target[name] = copy; } } } } // Return the modified object // 返回新的 target // 如果 i &lt; length ，是直接返回没经过处理的 target，也就是 arguments[0] // 也就是如果不传需要覆盖的源，调用 $.extend 其实是增加 jQuery 的静态方法 return target; }; ※※※jQuery.extend = jQuery.fn.extend = function() {}也就是 jQuery.extend 的实现和 jQuery.fn.extend 的实现共用了同一个方法，但是却实现不同的功能。 在 jQuery.extend() 中，this 的指向是 jQuery 对象(或者说是 jQuery 类)，所以这里扩展在 jQuery 上 在 jQuery.fn.extend() 中，this 的指向是 fn 对象，前面有提到 jQuery.fn = jQuery.prototype ，也就是这里增加的是原型方法，也就是对象方法。 5、链式调用和回溯 在要实现链式调用的方法的返回结果里，返回 this ，就能够实现链式调用了 除了链式调用，jQuery 甚至还允许回溯 // 通过 end() 方法终止在当前链的最新过滤操作，返回上一个对象集合 $(&apos;div&apos;).eq(0).show().end().eq(1).hide(); prevObject保存了上一步的对象集合 jQuery 完整的链式调用、增栈、回溯通过 return this 、 return this.pushStack() 、return this.prevObject 实现。 上源码啦 👇 jQuery.fn = jQuery.prototype = { // 将一个 DOM 元素集合加入到 jQuery 栈 // 此方法在 jQuery 的 DOM 操作中被频繁的使用, 如在 parent(), find(), filter() 中 // pushStack() 方法通过改变一个 jQuery 对象的 prevObject 属性来跟踪链式调用中前一个方法返回的 DOM 结果集合 // 当我们在链式调用 end() 方法后, 内部就返回当前 jQuery 对象的 prevObject 属性 pushStack: function(elems) { // 构建一个新的jQuery对象，无参的 this.constructor()，只是返回引用this // jQuery.merge 把 elems 节点合并到新的 jQuery 对象 // this.constructor 就是 jQuery 的构造函数 jQuery.fn.init，所以 this.constructor() 返回一个 jQuery 对象 // 由于 jQuery.merge 函数返回的对象是第二个函数附加到第一个上面，所以 ret 也是一个 jQuery 对象，这里可以解释为什么 pushStack 出入的 DOM 对象也可以用 CSS 方法进行操作 var ret = jQuery.merge(this.constructor(), elems); // 给返回的新 jQuery 对象添加属性 prevObject // 所以也就是为什么通过 prevObject 能取到上一个合集的引用了 ret.prevObject = this; ret.context = this.context; // Return the newly-formed element set return ret; }, // 回溯链式调用的上一个对象 end: function() { // 回溯的关键是返回 prevObject 属性 // 而 prevObject 属性保存了上一步操作的 jQuery 对象集合 return this.prevObject || this.constructor(null); }, // 取当前 jQuery 对象的第 i 个 eq: function(i) { // jQuery 对象集合的长度 var len = this.length, j = +i + (i &lt; 0 ? len : 0); // 利用 pushStack 返回 return this.pushStack(j &gt;= 0 &amp;&amp; j &lt; len ? [this[j]] : []); }, } 6、正则 jQuery 当中用了大量的正则表达式，下一章节细说 7、变量冲突处理 通过一开始保存全局变量的 window.jQuery 以及 windw.$ 过程大概是这样的： 当需要处理冲突的时候，调用静态方法 noConflict()，让出变量的控制权，源码如下：👇 (function(window, undefined) { var // Map over jQuery in case of overwrite // 设置别名，通过两个私有变量映射了 window 环境下的 jQuery 和 $ 两个对象，以防止变量被强行覆盖 _jQuery = window.jQuery, _$ = window.$; jQuery.extend({ // noConflict() 方法让出变量 $ 的 jQuery 控制权，这样其他脚本就可以使用它了 // 通过全名替代简写的方式来使用 jQuery // deep -- 布尔值，指示是否允许彻底将 jQuery 变量还原(移交 $ 引用的同时是否移交 jQuery 对象本身) noConflict: function(deep) { // 判断全局 $ 变量是否等于 jQuery 变量 // 如果等于，则重新还原全局变量 $ 为 jQuery 运行之前的变量（存储在内部变量 _$ 中） if (window.$ === jQuery) { // 此时 jQuery 别名 $ 失效 window.$ = _$; } // 当开启深度冲突处理并且全局变量 jQuery 等于内部 jQuery，则把全局 jQuery 还原成之前的状况 if (deep &amp;&amp; window.jQuery === jQuery) { // 如果 deep 为 true，此时 jQuery 失效 window.jQuery = _jQuery; } // 这里返回的是 jQuery 库内部的 jQuery 构造函数（new jQuery.fn.init()） // 像使用 $ 一样尽情使用它吧 return jQuery; } }) }(window) (function($) { // 插件或其他形式的代码，也可以将参数设为 jQuery })(query); // ... 其他用 $ 作为别名的库的代码 📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢📢 由于篇幅比较长，小仙女是写一下点传一点，有兴趣的盆友可以看下一章呦]]></content>
      <categories>
        <category>JQ</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DomDiff算法理解]]></title>
    <url>%2F2017%2F11%2F06%2FDomDiff%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[按照层级 找到两棵任意的树之间最小的修改是一个复杂度为 O(n^3) 的问题. React 用了一种简单但是强大的技巧, 达到了接近 O(n) 的复杂度. React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度, 假设我们有个 component, 一个循环渲染了 5 个 component,随后又在列表中间插入一个新的 component. 默认情况下, React 会将前一个列表第一个 component 和后一个第一个关联起来, 后面也是. 你可以写一个 key 属性帮助 React 来处理它们之间的对应关系. 事件代理 React 部署了种流行技术, 叫做”事件代理”. React 走得更远, 重新实现了一遍符合 W3C 规范的事件系统 事件 listener 被绑定到整个文档的根节点上. 当事件被触发, 浏览器会给出一个触发的目标的 DOM 节点. 为了在 DOM 的层级传播事件, React 不会迭代 virtual DOM 的层级. 而是, 我们依靠每个 React component 各自独立的 id 来编码这个层级 我们能通过简单的字符串操作来获取所有父级 component 的父级内容. 渲染 合并操作：调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 这里的”合并操作”是说, 在一个事件循环当中, DOM 只会被更新一次. 子树渲染：调用 setState 方法时, component 会重新构建包括子节点的 virtual DOM. 如果你在根节点调用 setState, 整个 React 的应用都会被重新渲染. 所有的 component, 即便没有更新, 都会调用他们的 render 方法. React 消耗性能的模型很简单, 很好理解: 每次调用 setState 会重新计算整个子树. 如果你想要提高性能, 尽量少调用 setState, 还有用 shouldComponentUpdate 减少大的子树的重新计算.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part Three 基础篇]]></title>
    <url>%2F2017%2F11%2F06%2F%E9%9D%A2%E8%AF%953%2F</url>
    <content type="text"><![CDATA[咱们书接上回😊 额O__O “…”貌似真的有点久远 20、vue的数据理解 data:是vue绑定数据的数据源 原理:vue会自动将data里面的数据进行递归。抓换成getter和setter computed:计算属性 watch:监听 watch：{ a:function（val，oldval）{} handler:function(){ deep：true } } 21、vue的特点 简洁 轻量 组件化 数据驱动 22、vue的生命周期是什么 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 beforeUpdate: update: beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 23、Vue的自定义指令 vue.directive(‘img’,{ // 当绑定元素插入到 DOM 中。 insert:function(el,binding){ var color = red; el.style.backgroundColor = color var img = new Image(); img.src = binding.value; img.onload = function (){ el.style.backgroundImage = &apos;url()&apos; } } }) bind: 只调用一次，指令第一次绑定到元素时调用， 用这个钩子函数可以定义一个在绑定时执行一次 的初始化动作。 inserted: 被绑定元素插入父节点时调用 （父节点存在即可调用，不必存在于 document 中）。 update: 所在组件的 VNode 更新时调用，但是可 能发生在其孩子的 VNode 更新之前。 指令的值可能发生了改变也可能没有。 但是你可以通过比较更新前后的值来忽略 不必要的模板更新 componentUpdated: 所在组件的 VNode 及其 孩子的 VNode 全部更新时调用 unbind: 只调用一次， 指令与元素解绑时调用。 钩子函数的参数 (包括 el，binding，vnode，oldVnode) el: 指令所绑定的元素，可以用来直接操作 DOM binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 无论值是否改变都可用。 Vue.directive(‘demo’, { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = ‘name: ‘ + s(binding.name) + ‘ ‘ + ‘value: ‘ + s(binding.value) + ‘ ‘ + ‘expression: ‘ + s(binding.expression) + ‘ ‘ + ‘argument: ‘ + s(binding.arg) + ‘ ‘ + ‘modifiers: ‘ + s(binding.modifiers) + ‘ ‘ + ‘vnode keys: ‘ + Object.keys(vnode).join(‘, ‘) } }) new Vue({ el: ‘#hook-arguments-example’, data: { message: ‘hello!’ } }) Vue.directive(‘demo’, function (el, binding) { console.log(binding.value.color) // =&gt; “white” console.log(binding.value.text) // =&gt; “hello!” }) 24、react的生命周期有那些 constructor(props, context) 构造函数，在创建组件的时候调用一次。 void componentWillMount() 在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。 void componentDidMount() 在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。 void componentWillReceiveProps(nextProps) props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。 bool shouldComponentUpdate(nextProps, nextState) 组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 void componentWillUpdate(nextProps, nextState) shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。 void componentDidUpdate() 除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。 ReactElement render() render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。 void componentWillUnmount() 组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。 25、prop和state的区别理解 ① state是react中一个对象，用来存储状态值，一般用setstate(data，callback) ② state存储可能被事件处理器修改的数据 ③ 一般用来传递数据，setprop() 26、post与get的区别 ① get是从服务器上获取数据，post是向服务器传送数据。 ② get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到 post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指 URL地址。用户看不到这个过程 ③ 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 ④ get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制 ⑤ get安全性非常低，post安全性较高。但是执行效率却比Post方法好 27、前端性能优化 （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 28、服务器端怎么获取客户端Ip地址 public String getIpAddr(HttpServletRequest request) { String ip = request.getHeader(“x-forwarded-for”); if(ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) { ip = request.getHeader(“Proxy-Client-IP”); } if(ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) { ip = request.getHeader(“WL-Proxy-Client-IP”); } if(ip == null || ip.length() == 0 || “unknown”.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); } return ip; } 27、原生Js怎么封装一个类 立即执行函数+闭包 28、requreJs做模块化开发有什么问题 requirejs采用lazyload的方式（后加载）加载js脚本，这样的加载方式大大的提高了性能 requirejs采用模块化的加载js的方式，可以让代码松耦合 所以如果用nodejs做webapp，nodejs+requirejs是很不错的组合，requirejs也很适合做游戏开发 但是，和任何框架一样，有优点也必然有一定缺点，requirejs是强迫第三方插件适应其框架，以至于有许多不支持amd和cmd 的插件不能直接被requirejs使用，也就意味着如果使用这些插件，需要将其进行一定的修改，使其符合cmd的规范。这对于一些大量使用第三方插件的网站是很不利的。另外，使用requirejs之后，所有的事件都需要进行绑定。这对于很多前端开发者来说是很不适应的。 所以如果是开发的网站含有大量的js代码，并且大多数是自己编写的js，或者开发webapp，游戏，那么推荐用requirejs； 如果开发的网站含有大量第三方插件，建议放弃requirejs 29、常见的浏览器兼容问题 html部分 ①H5新标签在IE9以下的浏览器识别 ②ul标签内外边距问题ul标签在IE6\IE7中，有个默认的外边距，但是在IE8以上及其他浏览器中有个默认的内边距。解决方法：统一设置ul的内外边距为0 CSS样式的兼容性 ①css的hack问题：主要针对IE的不同版本，不同的浏览器的写法不同 IE的条件注释hack： ②IE6双边距问题：IE6在浮动后，又有横向的margin，此时，该元素的外边距是其值的2倍 解决办法：display:block; ③IE6下图片的下方有空隙 解决方法：给img设置display:block; ④IE6下两个float之间会有个3px的bug 解决办法：给右边的元素也设置float:left; ⑤IE6下没有min-width的概念，其默认的width就是min-width ⑥IE6下在使用margin:0 auto;无法使其居中 解决办法：为其父容器设置text-align:center; ⑦被点击过后的超链接不再具有hover和active属性 解决办法:按lvha的顺序书写css样式， “:link”: a标签还未被访问的状态； “:visited”: a标签已被访问过的状态； “:hover”: 鼠标悬停在a标签上的状态； “:active”: a标签被鼠标按着时的状态； ⑧在使用绝对定位或者相对定位后，IE中设置z-index失效，原因是因为其元素依赖于父元素的z-index，但是父元素默认为0， 子高父低，所以不会改变显示的顺序 ⑨IE6下无法设置1px的行高，原因是由其默认行高引起的 解决办法：为期设置overflow:hidden;或者line-height:1px; JavaScript的兼容性 ①标准的事件绑定方法函数为addEventListener，但IE下是attachEvent； ②事件的捕获方式不一致，标准浏览器是由外至内，而IE是由内到外，但是最后的结果是将IE的标准定为标准 ③window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement ④在低版本的IE中获取的日期处理函数的值不是与1900的差值，但是在高版本的IE中和标准浏览器保持了一致，获取的值也是与1900的差值。 比如：var year= new Date().getYear(); ⑤ajax的实现方式不同，这个我所理解的是获取XMLHttpRequest的不同，IE下是activeXObject 6.IE中不能操作tr的innerHtml7.获得DOM节点的父节点、子节点的方式不同 其他浏览器：parentNode parentNode.childNodes IE：parentElement parentElement.children 30.input和textarea的区别 是一个单行输入框，有value属性（value属性指定初始值），但是它不能自动换行；用来放置字数较少的单行文字内容 是一个多行输入框，没有value属性，但是它能自动换行；一般让用户可以输入多行文字,输入的文字信息量相比较大 31、用一个div模拟textarea的实现 //css div{ width: 400px; min-height: 100px; max-height: 300px; _height: 100px; //IE6 margin-left: auto; margin-right: auto; padding: 3px; outline: 0; border: 1px solid #a0b3d6; font-size: 12px; word-wrap: break-word; overflow-x: hidden; overflow-y: auto; //超过最大高度就出现滚动条 _overflow-y: visible; } //html …..此处省略….. 32、图片懒加载 1、页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片（也就没有请求咯，也就提高性能咯），一旦通过javascript设置了图片路径，浏览器才会送请求。有点按需分配的意思，你不想看，就不给你看，你想看了就给你看~ 2、如何获取正真的路径，这个简单，现在正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置； 33、postMessage原理 postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 postMessage(data,origin)方法接受两个参数 1.data:要传递的数据 2.origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略 Frame Color window.onload=function(){ window.frames[0].postMessage(‘getcolor’,’ http://lslib.com‘); } window.addEventListener(‘message’,function(e){ if(e.source!=window.parent) return; var color=container.style.backgroundColor; window.parent.postMessage(color,’*’); },false); 34、实现拖拽功能 用JavaScript事件方法表示就是： ① onmousedown + onmousemove → startDrag() ② onmouseup → stopDrag() ③ …… window.onload = function() { //获取需要拖拽的div var div1 = document.getElementById("div1"); //添加鼠标按下事件 div1.onmousedown = function(evt) { var oEvent = evt || event; //获取按下鼠标到div left top的距离 var distanceX = oEvent.clientX - div1.offsetLeft; var distanceY = oEvent.clientX - div1.offsetTop; //添加doc滑动时间 document.onmousemove = function(evt) { var oEvent = evt || event; //重新计算div的left top值 var left = oEvent.clientX - distanceX; var top = oEvent.clientY - distanceY; //left 当小于等于零时，设置为零 防止div拖出document之外 if (left = document.documentElement.clientWidth - div1.offsetWidth) { left = document.documentElement.clientWidth - div1.offsetWidth; } if (top = document.documentElement.clientHeight - div1.offsetHeight) { top = document.documentElement.clientHeight - div1.offsetHeight; } //重新给div赋值 div1.style.top = top + "px"; div1.style.left = left + "px"; } //添加鼠标抬起事件 div1.onmouseup = function() { //清空事件 document.onmousemove = null; div1.onmouseup = null; } } } 35、前端安全问题：CSRF和XSS XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求 通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJS的问题一]]></title>
    <url>%2F2017%2F11%2F06%2FNodeJS%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[几个node中需要注意的问题 1、什么是时间循环? Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式） 2、什么是错误优先的回调函数？ 错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。 其余的参数用于传递数据。例如： fs.readFile(filePath, function(err, data) { if (err) { //handle the error } // use the data object }); 3、什么是stub？举个应用场景 Stub是用于模拟一个组件或模块的函数或程序 你可以用Stub去模拟一个方法，从而避免调用真实的方法， 使用Stub你还可以返回虚构的结果 举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时： var fs = require(‘fs’); var readFileStub = sinon.stub(fs, ‘readFile’, function (path, cb) { return cb(null, ‘filecontent’); }); expect(readFileStub).to.be.called; readFileStub.restore(); 4、如何用node监听80端口？ 在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。 目前，如果你一定要让你的应用监听80端口的话，你可以有通过在Node应用的前方再增加一层反向代理 （例如nginx）来实现 5、如何避免回调地狱？ 模块化：将回调函数分割为独立的函数 使用Promises 使用yield 来计算生成器或Promise 6、怎么处理异步? 初级方案：通过递归处理异步回调 var fs = require(‘fs’); // 要处理的文件列表 var files = [‘file1’, ‘file2’, ‘file3’]; function parseFile () { if (files.length == 0) { return; } var file = files.shift(); fs.readFile(file, function (err, data) { // 这里处理文件数据 parseFile(); // 处理完毕后，通过递归调用处理下一个文件 }); } // 开始处理 parseFile(); 华丽点：采用Async、Q、Promise等第三方库处理异步回调 优雅点：拥抱ES6，替代回调函数，解决回调地狱问题.使用Generator特性替代回调函数 var fs = require(‘fs’) , co = require(‘co’) , thunkify = require(‘thunkify’); var readFile = thunkify(fs.readFile); co(function *() { var test1 = yield readFile(‘test1.txt’); var test2 = yield readFile(‘test2.txt’); var test = test1.toString() + test2.toString(); console.log(test); })();]]></content>
      <categories>
        <category>NODEJS</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>NODEJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慢谈继承]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%85%A2%E8%B0%88%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[让我们先看几张图 //约定 function Fun(){ //私有属性 var val = 1;// 私有基本属性 var arr = [1]; // 私有引用属性 function f(){} // 私有函数（引用属性） //实例属性 this.val = 1; // 实例基本属性 this.arr = [1];// 实例引用属性 this.f = function(){} // 实例函数（引用属性） } //原型属性 Fun.prototype.val = 1;// 原型基本属性 Function.prototype.arr = [1]; // 原型引用属性 Fun.prototype.f = function(){}; // 原型函数（引用属性） //简单原型链继承 function A(){ this.val = 1; this.arr = [1]; } function B(){} //拿父类实例来充当子类原型对象 B.prototype = new A();//核心 var b1 = new B(); var b2 = new B(); b1.val = 2; b1.arr.push(2); console.log(b1.arr)//2 console.log(b2.arr)//1 //修改b1.arr后b2.arr也变了，因为来自原型对象的引用属性是所有实例共享的。 //创建子类实例时，无法向父类构造函数传参 console.log(b1.arr)//1,2 console.log(b2.arr)//1,2 ##################################################### //构造函数继承 function A(x){ this.x = x; this.arr = [1]; this.f = function(){} } function B(y){ //借父类的构造函数来增强子类实例，等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型） A.call(this,y) // 核心 } var b1 = new B(1); var b2 = new B(2); b1.arr.push(2); console.log(b1.x);//1 console.log(b2.x);//2 console.log(b1.arr)//1,2 console.log(b2.arr)//1 //无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸。。 console.log(b1.f === b2.f) //false ######################################################## //组合继承 function A(){ this.x = 1; this.arr = [1] } A.prototype.f1 = function(){} A.prototype.f2 = function(){} function B(){ A.call(this); } B.prototype = new A(); //把实例函数都放在原型对象上，以实现函数复用。 //同时还要保留借用构造函数方式的优点，通过Super.call(this); //继承父类的基本属性和引用属性并保留能传参的优点； //通过Sub.prototype = new Super(); //继承父类函数，实现函数复用 var b1 = new B(1); var b2 = new B(2); console.log(b1.f === b2.f)//true //子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次， //生成了两份，而子类实例上的那一份屏蔽了子类原型上的 #################################################### //寄生组合继承 function Bus(obj){ var F = function(){} F.prototype = obj; return new F(); } function A(){ this.x = 1; this.arr = [1]; } A.prototype.f = function(){} function B(){ A.call(this) } //用Bus(A.prototype)切掉了原型对象上多余的那份父类实例属性 var proto = Bus(A.proto); proto.constructor = B; B.prototype = proto; var b1 = new B(); #################################################### //原型继承，Object.create()函数，内部就是原型式继承 function Bus(obj){ var F = function(){}; F.prototype = obj; return new F(); } function A(){ this.x = 1; this.arr = [1]; } var a = new A();; //Bus函数得到得到一个“纯洁”的新对象（“纯洁”是因为没有实例属性），再逐步增强之（填充实例属性） var b = Bus(a); b.z = 2; console.log(b.x)//1; console.log(b.arr)//1; console.log(b.z)//2]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见入门算法]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%B8%B8%E8%A7%81%E5%85%A5%E9%97%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、斐波那契数列 function fibonacci(n){ if(n==1 || n==2) return 1; return fibonacci(n-1)+fibonacci(n-2) } 2、快排 var quickSort = function(arr) { if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).concat([pivot], quickSort(right)); }; 3、数组去重 原始方法 Array.prototype.uniq = function () { var resArr = []; var flag = true; for(var i=0;i&lt;this.length;i++){ if(resArr.indexOf(this[i]) == -1){ if(this[i] != this[i]){ //排除 NaN if(flag){ resArr.push(this[i]); flag = false; } }else{ resArr.push(this[i]); } } } return resArr; } ES6 function Unique(arr){ return Array.from(new Set(arr)) } 4、去掉左右两侧空格 var reg = /^\s |\s$/g; var str = “”; str.replace(reg, “”) 5、千分位分割 千位分隔符格式的规则是数字的整数部分每三位一组，以“，”分节。小数部分不分节 。 示例：19,351,235.235767 方法一：将数字转换为字符数组，再循环整个数组， 每三位添加一个分隔逗号，最后再合并成字符串 function numFormat(num){ num=num.toString().split(“.”); // 分隔小数点 var arr=num[0].split(“”).reverse(); // 转换成字符数组并且倒序排列 var res=[]; for(var i=0,len=arr.length;i&lt;len;i++){ if(i%3===0&amp;&amp;i!==0){ res.push(“,”); // 添加分隔符 } res.push(arr[i]); } res.reverse(); // 再次倒序成为正确的顺序 if(num[1]){ // 如果有小数的话添加小数部分 res=res.join(“”).concat(“.”+num[1]); }else{ res=res.join(“”); } return res; } var a=1234567894532; var b=673439.4542; console.log(numFormat(a)); // “1,234,567,894,532” console.log(numFormat(b)); // “673,439.4542” 方法二：使用JS自带的函数 toLocaleString var a=1234567894532; var b=673439.4542; console.log(a.toLocaleString()); // “1,234,567,894,532” console.log(b.toLocaleString()); // “673,439.454” （小数部分四舍五入了） 方法三：正则和replace function numFormat(num){ var res=num.toString().replace(/\d+/, function(n){ // 先提取整数部分 return n.replace(/(\d)(?=(\d{3})+$)/g,function($1){ return $1+”,”; }); }) return res; } var a=1234567894532; var b=673439.4542; console.log(numFormat(a)); // “1,234,567,894,532” console.log(numFormat(b)); // “673,439.4542 6、原生JS拖动方法 function drag(t,p){ var point = p || null, target = t || null, resultX = 0, resultY = 0; (!point)? point = target : ‘’; //如果没有拖动点，则拖动点默认为整个别拖动元素 function getPos(t){ var offsetLeft = 0, offsetTop = 0, offsetParent = t; while(offsetParent){ offsetLeft+=offsetParent.offsetLeft; offsetTop+=offsetParent.offsetTop; offsetParent = offsetParent.offsetParent; } return {&apos;top&apos;:offsetTop,&apos;left&apos;:offsetLeft}; } function core(){ var width = document.body.clientWidth || document.documentElement.clientWidth, height = document.body.clientHeight || document.documentElement.clientHeight; maxWidth = width - target.offsetWidth, maxHeight = height - target.offsetHeight; (resultX &gt;= maxWidth)? target.style.left = maxWidth+&apos;px&apos; : (resultX &gt; 0)?target.style.left = resultX +&apos;px&apos;: &apos;&apos;; //重置默认位置。 (resultY &gt;= maxHeight)? target.style.top = maxHeight +&apos;px&apos; : (resultY &gt; 0)?target.style.top = resultY +&apos;px&apos;:&apos;&apos;; //重置默认位置。 point.onmousedown=function(e){ var e = e || window.event, coordX = e.clientX, coordY = e.clientY, posX = getPos(target).left, posY = getPos(target).top; point.setCapture &amp;&amp; point.setCapture(); //将Mouse事件锁定到指定元素上。 document.onmousemove=function(e){ var ev = e || window.event, moveX = ev.clientX, moveY = ev.clientY; resultX = moveX - (coordX - posX); //结果值是坐标点减去被拖动元素距离浏览器左侧的边距 resultY = moveY - (coordY - posY); (resultX &gt; 0 )?((resultX &lt; maxWidth)?target.style.left = resultX+&apos;px&apos; : target.style.left = maxWidth+&apos;px&apos;) : target.style.left = &apos;0px&apos;; (resultY &gt; 0 )?((resultY &lt; maxHeight)?target.style.top = resultY+&apos;px&apos; : target.style.top = maxHeight+&apos;px&apos;) : target.style.top = &apos;0px&apos;; ev.stopPropagation &amp;&amp; ev.stopPropagation(); ev.preventDefault; ev.returnValue = false; ev.cancelBubble = true; }; }; document.onmouseup=function(){ // 解决拖动时，当鼠标指向的DOM对象非拖动点元素时，无法触发拖动点的onmousedown的BUG。 document.onmousemove = null; point.releaseCapture &amp;&amp; point.releaseCapture(); // 将Mouse事件从指定元素上移除。 }; point.onmouseup=function(e){ var e = e || window.event; document.onmousemove = null; point.releaseCapture &amp;&amp; point.releaseCapture(); }; } core(); window.onresize = core; } drag(t,p) /* 说明 t 表示被拖动的元素 p 表示拖动点 */ 7、正数组的最大差值： // 使用 Math const getMaxGap = (array) = &gt;Math.max.apply(Math, array) - Math.min.apply(Math, array); // 使用 reduce const getMaxDiff = (array) = &gt;{ if (array.length &lt; 1) return arrary[0]; array = array.reduce(([max, min], el) = &gt;{ max = el &gt; max ? el: max; min = el &lt; min ? el: min; return [max, min]; }, array); return array[0] - array[1]; }; // see 前端面试中的常见的算法问题 function getMaxProfit(arr) { var minPrice = arr[0]; var maxProfit = 0; for (var i = 0; i &lt; arr.length; i++) { var currentPrice = arr[i]; minPrice = Math.min(minPrice, currentPrice); var potentialProfit = currentPrice - minPrice; maxProfit = Math.max(maxProfit, potentialProfit); } return maxProfit; } // ------------------------------------------------- // perf test // 2000000 times: Math ~= 100ms; Reduce ~= 1100ms; Normal ~= 25ms let array = [10, 5, 11, 7, 8, 9]; var t = 2e6; var n = 1000; var i; i = 0; console.time(&apos;Math&apos;); while (i &lt; t) { getMaxGap(array); i++; } console.timeEnd(&apos;Math&apos;); i = 0; console.time(&apos;Reduce&apos;); while (i &lt; t) { getMaxDiff(array); i++; } console.timeEnd(&apos;Reduce&apos;); i = 0; console.time(&apos;Normal&apos;); while (i &lt; t) { getMaxProfit(array); i++; } console.timeEnd(&apos;Normal&apos;); 8、冒泡排序法： function bubbleSort(arr) { for(let i = 0,l=arr.length;i]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和数组中的坑]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一说到数组，都是眼泪😢，原生的JS数组包含了太多种方法！！！更别说JQ例了 可以说，一遇到数组这个小婊砸，真是有的玩了。。。 让我们举几个常见的 🌰 吧 1、合并两个数组 function concat(arr1, arr2) { return arr1.concat(arr2) } 2、数组中某个值出现次数 function count(arr, item) { var count = arr.filter(function(a) { return a === item; }); return count.length; } 3、数组中某元素位置 function indexOf(arr,item){ return arr.indexOf(item) } 4、数组中重复数据并排序 function duplicates(arr) { var a=[]; var b=[]; for(var i=0; i&lt;arr.length;i++){ if(a.indexOf(arr[i]) == -1){ a.push(arr[i]); }else if(b.indexOf(arr[i]) == -1){ b.push(arr[i]); } } return b; } 5、数组开头增加元素 function prepend(arr, item) { var newArr = arr.slice(0) newArr.unshift(item) return newArr } 6、数组末尾增加一个元素 function append(arr, item) { var newArr = arr.slice(0) newArr.push(item) return newArr; } 7、数组某个位置插入某个值 function insert(arr, item, index) { var a = arr.slice(0) a.splice(index,0,item) return a } 8、数组求二次方 function square(arr) { return arr.map(function(x){ return x*x; }) } 9、数组求和 (function() { var sum = 0; function getSum(array){ for (var i = 0; i &lt; array.length; i++){ sum += parseInt(array[i]); } return sum; })() 10、移除数组中与X相等的值 function removeWithoutCopy(arr, item) { var index; for(var i= 0; i&lt;arr.length ; i++){ if(arr[i] == item){ arr.splice(i,1) i--; } } return arr; } 11、移除数组最后一位返回新数组 function truncate(arr) { return arr.slice(0,arr.length-1) } 12、移除数组第一位元素 function curtail(arr) { return arr.slice(1) } 13、移除数组返回新数组 function remove(arr, item) { var newArr = []; for(var i=0;i&lt;arr.length;i++){ if(arr[i]!=item){ newArr.push(arr[i]) } } return newArr; } 14、移除数组返回本数组 function removeWithoutCopy(arr, item) { var i = arr.indexOf(item) if(i &gt; -1){ return arr.splice(index,1) } }]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询响应式页面]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[@media（min-width:768px） @media screen and (max-width: 300px) { body { background-color:lightblue; } } 响应式的页面 width/height：浏览器可视宽度(也叫视口)/浏览器可见高度. device-width/device-height：设备屏幕宽度/设备屏幕高度. color:检测颜色的位数。（例如：min-color:32 就是检测设备是否拥有32位颜色 #000000） color-index:检查设备索引颜色表中的颜色(颜色值不能小于0)。 orientation：判断当前设备是横屏还是竖屏. aspect-ratio:检测浏览器可视宽度和高度的比例。(现在宽高比为16:9是最佳的，比如我做的直播窗口，要求宽高比就是16:9) device-aspect-ratio:检测设备的宽度和高度的比例。 resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格设备的还是位图设备。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个很少用得到）]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栅格化布局]]></title>
    <url>%2F2017%2F11%2F06%2F%E6%A0%85%E6%A0%BC%E5%8C%96%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[假设：Flowline的宽度为W，column的宽度为c，Gutter的宽度为g，Margin的宽度为m，栅格列数为N W = c*N + g*(N-1) + 2m；g的宽度通常为m的两倍，所以： W = (c+g) * N；把c+g记为C，得： W = C * N; Bootstrap的栅格系统 BootStrap中合理的使用栅格布局，必须将列放入row中，而row必须放入container中。container类在布局中主要有两个作用： 在不同的宽度区间内（响应式断点）提供宽度限制。当宽度变化时，采用不同的宽度。 提供一个padding，阻止内部内容触碰到浏览器边界。 Row是column的容器，每个row中的column之和必须为12，不过我们可以通过嵌套的方式扩展。Row的左右margin都为-15px， 用来抵消container中的padding，如下图蓝色部分所示： Colomn是栅格系统的主角，每个column左右padding都为15px，上文中row的负margin抵消了container的padding， 所以为每个column设置padding就是为了防止内容直接触碰边界，同时不同的column之间拥有30px的卡槽（Gutter）]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的几种方式]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[没有对象的 看过来 看过来 1、工厂模式 function createPerson(name,age,job){ var obj = new Object(); obj.name = name; obj.age = age; obj.job = job; obj.sayHello = function(){ alert(‘hello!’) } return obj } var p1 = createPerson(‘nini’,29,’worker’); var p2 = createPerson(‘cc’,33,’doctor’) 2、构造函数方式 function Person(name,age){ this.name = name; this.age = age; this.say = function(){ alert(‘hello’) } } var p1 = new Person(…); var p2 = new Person(…); 3、原型模式 function Person(){} Person.prototype.name = “nini”; Person.prototype.age = 12; Person.prototype.say = function(){} var p1 = new Person(); p1.say(); p1.name; function Person(){ } Person.prototype={ name:”…”, age:29, job:”…”, sayName:function(){ … } }; Object.defineProperty(Person.prototype,”constructor”,{ enumerable:false, value:Person, }); 4、混合模式 function Person(name,age,job){ this.name = name; this.age = age; this.job = job; } Person.prototype = { constructor:Person, say:function(){ alert(this.name) } } var p1 = new Person(…) 5、动态原型 function Person(name,age,job){ this.name = name; this.age = age; this.job = job if(typeof this.sayName != “function”){ Person.prototype.say = function(){ alert(this.name) } } } 6、对象字面量 var person = { name:’aa’, age:19, say:function(){ } } person.say(); //对象字面量是一个表达式，这个表达式的每次运算都将创建并初始化一个新的对象 //每次计算对象字面量的时候，也都会计算它每个属性的值。 //也就是说，如果在一个重复调用的函数中的循环体内使用了对象字面量， //它将创建很多新对象，并且每次创建的新对象的属性值也有可能不同。 7、object实例 var person = new Object(); person.name = “aa”; person.age = 19; person.say = function(){ } person.name() 8、Object.create（）]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链的理解例子和图片]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[原型链 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 每个构造函数都有一个原型对象,每个原型对象都包含一个指向构造函数的指针,而实例则包含一个指向原型对象的指针。 假如让A原型对象等于B构造函数的实例，那么A原型对象就会有一个[[Prototype]]指针指向B原型对象， 同时B原型对象的constructor属性又指向了B构造函数； 假如让B原型对象等于C构造函数的实例，上述关系依然成立； 如此层层递进，从而实现了实例与原型之间的链接；这就是原型链的基本概念。 下面是我画的一张图，方便理解吧 👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 既然如此，Object构造函数是最顶层的构造函数，所有函数的默认原型都是Object的实例， 因此默认原型都会包含一个[[Prototype]]指针，指向Object.prototype； 这也是所有自定义类型都会继承Object类型所拥有的实例和方法的根本原因。 确认原型和实例之间的关系 instanceof操作符；只要是原型链上出现过的构造函数，都会返回true。instanceof操作符的本质在于：左边的操作数的原型链上是否有右边的操作数的prototype属性。 isPrototypeOf()方法，只要是原型链上出现过的原型，都会返回true function A(name){ this.name = name; }; A.prototype.sayName = function(){ alert(this.name); }; function B(age){ this.age = age; }; B.prototype = new A(); B.prototype.sayAge = function(){ alert(this.age); }; var x = new B(); x.name = “CC”; console.log(x.sayName()); //“CC” console.log(x instanceof B); //true console.log(x instanceof A); //true console.log(x instanceof Object); //true console.log(Object.prototype.isPrototypeOf(x)); //true console.log(A.prototype.isPrototypeOf(x)); //true console.log(B.prototype.isPrototypeOf(x)); //true]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象问题]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对象，一直是让小仙女头疼的问题。。。 先说说最基础的属性吧，什么是对象的属性? //数据属性与访问器属性 //数据属性即有值的属性,访问器属性是用来设置getter和setter的,//在属性名前加上”_”（下划线）表示该属性只能通过访问器访问（私有属性) 数据属性具有4个描述其行为的特性： 1、Configurable：能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。 默认为true。 2、Enumerable：表示能否通过for-in循环返回属性。默认为true 除了for-in循环之外，ECMAScript5定义了两个用以枚举属性名称的函数 Object.keys()：返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。 Object.getOwnPropertyNames()：返回对象的所有自有属性的名称，而不仅限于可枚举的属性 3、Writable：能否修改属性的值。默认为true。 4、Value： 包含这个属性的数据值；读取属性值的时候，从这个位置读取；写入属性值的时候，把值保存在这里。 特性默认为undefined。 访问器属性 包含一对getter和setter方法。访问器属性有如下4个特性： 1、Configurable 2、Enumerable 3、Get：在读取属性时调用的函数；默认值为undefined。在读取访问器属性时，会调用gette方法，这个函数负责返回有效的值。 4、Set：在写入属性时调用的函数；默认值为undefined。在写入访问器属性时，会调用setter方法并传入新值，这个函数负责决定如何处理数据。 访问器属性不能直接定义，必须使用Object.defineProperties()方法来定义。 属性的特性规则 1、如果对象是不可扩展的，则可以编辑已有的自有属性，但不能添加新属性； 2、如果属性是不可配置的，则不能修改它的可配置性和可枚举性 3、如果访问器属性是不可配置的，则不能修改其getter和setter方法 🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚🔚 通过描述符一次性定义多个属性； 接收两个对象参数：第一个对象是要添加或修改其属性的对象；第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 var person = {} Object.defineProperties(person,{ name:{ value:”cc” }, age:{ value:23, writable:false } }) //要修改数据属性默认的特性，必须使用ECMAScript5中的Object.defineProperty()方法 //三个参数：属性所在的对象、属性的名字、描述符对象 //数据属性描述符对象的属性必须是：configurable、enumerable、writable、value //访问器属性的描述符对象的属性有configurable、enumerable、get、set。 //设置其中的一个或多个值，可以修改对应的特性值。 var person = {}; Object.defineProperty(person,”name”,{ witable:false, value:”CC” //如果不指定，configurable、enumerable、writable特性的值都是false。 }) console.log(person.name);//CC person.name = “VV”; console.log(person.name)//CC //注意：使用Object.defineProperty()方法，要么修改已有属性，要么新建自有属性，不能修改继承属性。 可以取得给定属性的描述符 接收两个参数：属性所在的对象，要读取其描述符的属性名称。 返回值是一个对象 //Object.getOwnPropertyDescriptor()方法，只能用于实例属性 var person = {}; Object.defineProperties(person, { name: { value: “CC”, writable: true }, age: { value: 23, writable: false } }); var descriptor = Object.getOwnPropertyDescriptor(person, “name”); alert(descriptor.value); //“CC” alert(descriptor.writable); //true 使用arguments function useArguments() { var result = Array.prototype.reduce.call(arguments,function(a,b){return a+b;}); return result; } 遍历对象 function iterate(obj) { return Object.getOwnPropertyNames(obj).map(function(key){ return key+”: “+obj[key]; }); }]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等高布局的五种方式]]></title>
    <url>%2F2017%2F11%2F03%2F%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方法一：伪等高 这种方式，并不是真正的实现了元素等高 上代码喽 &lt;style&gt; *{ margin: 0; } .p{ position: relative; } .left{ position: absolute; top:0; left: 0; width:100px; background: green } .right{ position: absolute; top: 0; right: 0; width:200px; background: pink; } .center{ box-sizing:border-box; background-clip: content-box; padding:0 20px; border-left: 100px solid green; border-right: 200px solid pink; background: red; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;jjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;lllll&lt;/p&gt; &lt;p&gt;jkljlkjl&lt;/p&gt; &lt;p&gt;jlskjldjsas&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;;;;;&lt;/p&gt; &lt;p&gt;jjjjj&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 结果： 方法二：伪等高 &lt;style&gt; *{ margin:0; } .par{ overflow: hidden; } .left{ float: left; width: 20%; padding-bottom: 9999px; margin-bottom: -9999px; background: red; } .center{ margin:0 20px; background: pink; } .right{ float: right; width: 20%; padding-bottom: 9999px; margin-bottom: -9999px; background: red; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;jjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;;;;;&lt;/p&gt; &lt;p&gt;jjjjj&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;p&gt;lllll&lt;/p&gt; &lt;p&gt;jkljlkjl&lt;/p&gt; &lt;p&gt;jlskjldjsas&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 结果： 方法三：真等高 &lt;style&gt; body,p{margin: 0;} .parent{ display: table; width: 100%; table-layout: fixed; } .left,.centerWrap,.right{ display: table-cell; } .center{ margin: 0 20px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;parent&quot; style=&quot;background-color: lightgrey;&quot;&gt; &lt;div class=&quot;left&quot; style=&quot;background-color: lightblue;&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;centerWrap&quot;&gt; &lt;div class=&quot;center&quot; style=&quot;background-color: pink;&quot;&gt; &lt;p&gt;center&lt;/p&gt; &lt;p&gt;center&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot; style=&quot;background-color: lightgreen;&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 结果： 方法四：真等高 //设置子元素的top:0;bottom:0 body,p{ margin: 0; } .parent{ position: relative; height: 40px; } .left,.center,.right{ position: absolute; top: 0; bottom: 0; } .left{ left: 0; width: 100px; } .center{ left: 120px; right: 120px; } .right{ width: 100px; right: 0; } 方法五：flex &lt;!-- flex中的伸缩项目默认都拉伸为父元素的高度，也实现了等高效果 --&gt; body,p{ margin: 0; } .parent{ display: flex; } .left,.center,.right{ flex: 1; } .center{ margin: 0 20px; }]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字分割线问题解决]]></title>
    <url>%2F2017%2F11%2F03%2F%E6%96%87%E5%AD%97%E5%88%86%E5%89%B2%E7%BA%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前两天在一个项目里，小仙女可是被这个分割线问题气死了 😠😠😠😠😠😠😠 不知道小可爱们会不会遇到下面的问题 看下面 👇👇👇👇👇👇👇👇 &lt;style type=&quot;text/css&quot;&gt; div{ padding: 0 20px 0; margin: 20px 0; line-height: 1px; border-left: 200px solid #ddd; border-right: 200px solid #ddd; text-align: center; } &lt;/style&gt; &lt;body&gt; &lt;div&gt;hkjhjhjhkhkj&lt;/div&gt; &lt;/body&gt; 这样 原本看上去 很美好😊😊😊😊😊😊😊😊 but 当你将屏幕横向拉伸的时候 苦逼的事情就粗线了 😨 看这里 👇👇👇👇 AND 看这里 👇👇👇👇👇 真是要疯掉了，人家想要的是无论什么情况下，都是介个样子滴 👇👇👇👇👇 蓝瘦香菇😭 So 基于上线的小仙女 想了一个办法，总算可以解决这个问题，but 不一定是最好的，但是可以参考一下啦！！！！ 🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉 &lt;style&gt; .flex{ list-style:none; display:-webkit-flex; padding:0; margin:0; color:#fff; } .red{ background-color: red; flex:2; } .blue{ background-color:green; flex:3; text-align: center; } .green{ background-color:red; flex:2; } .three-column { width: 100%; height: 500px; display: box; display: -webkit-box; display: flex; } .two { -webkit-box-flex: 1; flex: 1 } .one, .three { width: 200px; } &lt;/style&gt; &lt;body&gt; &lt;ul class=&quot;flex&quot;&gt; &lt;li class=&quot;red&quot;&gt;11&lt;/li&gt; &lt;li class=&quot;blue&quot;&gt;jjjjj&lt;/li&gt; &lt;li class=&quot;green&quot;&gt;33&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于多栏布局以及自适应问题]]></title>
    <url>%2F2017%2F11%2F03%2F%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[今天我们来谈谈多栏布局吧！Let’s Go 🚄🚄🚄🚄🚄 下面是我日常遇见过得双栏布局和三栏布局，当然还有其他布局模式，BUT今天就先说说这两个吧 ①、关于两栏布局： 两栏布局顾名思义就是主内容分为左右两侧各有一栏。实现两栏布局有很多种办法在这里，我将最常见的几种方法列举出来 方法一：最简单粗暴的方式，百分比这里我就不写出来了，相信大家都会 方法二：BFC方式 &lt;style&gt; #header, #footer{ height: 100px; background: red; } #content .right{ height: 200px; background: green; overflow: auto; } #content .left{ height: 200px; width: 100px; background: blue; float: left; } &lt;/style&gt; right right right right right right 原理：将左侧区域浮动，再讲右侧区域设置auto，形成BFC独立区域，块级上下文 方法三：负边距大法 &lt;style type=&quot;text/css&quot;&gt; html,body{ padding: 0; margin: 0; } #header, #footer{ height: 100px; background: red; overflow: hidden; } #main{ overflow: auto; } #main .center{ height: 200px; width: 100%; float: left; } .center .content{ height: 200px; background: green; margin-right: 100px; } #main .aside{ height: 200px; width: 100px; background: blue; float: left; margin-left: -100px; } &lt;/style&gt; header 我是主区块 我是主区块 main main main footer 当需要自适应的时候 #left { float: left; background-color: red; } #right { overflow: hidden; background-color: blue; } 或者 .left{ position:absolute; // margin-left: -200px; height:400px; width:200px; background-color:blue; } .right{ padding-left:200px; background-color:red; } 再或者 .left-3{ position:relative; padding-right: 200px;//留出右侧内边距 height:300px; background-color:yellow; } .right-3{ position:absolute;//绝对定位到右边 right:0; height:400px; background-color:#808080; } ②、关于三栏布局 三栏布局是在两栏布局的基础上进行的扩展 方法一：绝对定位法 &lt;style type=&quot;text/css&quot;&gt; html，body{ margin:0; height: 100%; } #left，#right{ position: absolute; top: 0; width: 200px; height: 100px; } #left{ left: 0; } #right{ right: 0; } #main{ margin: 0 210px; height: 100%; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt; &lt;/body&gt; ※如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况 方法二：负margin法 &lt;style type=&quot;text/css&quot;&gt; html，body{ margin:0; height: 100%; } #left，#right{ width: 200px; height: 100px; float:left; } #left{ margin-left: -100%; } #right{ margin-right: -200px; } #main,#body{ margin: 0 210px; height:100%; } #main{ width:100%; height: 100%; float:left; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;&lt;/div&gt; &lt;/body&gt; 方法三：浮动 &lt;style type=&quot;text/css&quot;&gt; .left{ float:left; width:100px; height: 30px; background: red; } .right{ float: right; width:150px; height: 30px; background: green; } .center{ background: pink; height: 50px; margin-left: 100px; margin-right: 150px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;left&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;222&lt;/div&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见问题]]></title>
    <url>%2F2017%2F11%2F03%2FCSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、清除浮动的几种方式 1、额外标签法 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix{ clear: both; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 2、使用:after 伪元素 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix:after{ /*最简方式*/ content: &apos;&apos;; display: block; clear: both; } /* 新浪使用方式 .clearfix:after{ content: &apos;&apos;; display: block; clear: both; height: 0; visibility: hidden; } */ .clearfix{ /*兼容 IE*/ zoom: 1; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer clearfix&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 3、给父元素定高 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } .clearfix{ clear: both; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 4、利用overflow:hidden;属性 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; overflow: hidden; zoom: 1;/*兼容 IE*/ } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 5、父元素浮动 6、父元素处于绝对定位 &lt;style&gt; .outer{ border: 1px solid black; width: 300px; position: absolute; } .inner{ width: 50px; height: 50px; background-color: #ff4400; margin-right: 20px; float: left; } .footer{ background-color: #005FC3; width: 200px; height: 100px; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; &lt;/body&gt; 二、小箭头问题 &lt;div id=&quot;demo12&quot;&gt;&lt;/div&gt; &lt;style&gt; #demo12 { border: 10px solid #000; border-left-color: #f00; width: 0; height: 0; } &lt;/style&gt; 即通过调整“边框”厚度可以配置出任意角度 &lt;/div&gt; &lt;style&gt; #demo14 { border: 10px solid transparent; border-left: 20px solid #f00; width: 0; height: 0px; } &lt;/style&gt; 三、rem和em的区别 em是相对于父元素的属性而计算的 Rem是相对于根元素’ ‘ 四、viewport都有什么 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求 五、常见的布局方式有哪些？ 1、零布局 零布局的意思就是几乎完全按照正常文档流的方式来布局，不采用比如float，position，display等css属性。 2、display布局 3、float布局 4、position布局 5、table布局 六、0.5边框问题 1、缩放 .border { position: relative; } .border:after { content: &quot; &quot;; display: block; position: absolute; box-sizing: border-box; left: 0px; top:0px; height: 200%; width: 200%; transform-origin: 0 0; border: 1px solid red; transform: scale(.5); } 2、图片 七、垂直居中 1、table-cell &lt;div class=&quot;box box1&quot;&gt; &lt;span&gt;垂直居中&lt;/span&gt; &lt;/div&gt; .box1{ display: table-cell; vertical-align: middle; text-align: center; } 2、display:flex .box2{ display: flex; justify-content:center; align-items:Center; } 3、绝对定位和负边距 .box3{position:relative;} .box3 span{ position: absolute; width:100px; height: 50px; top:50%; left:50%; margin-left:-50px; margin-top:-25px; text-align: center; } 4、绝对定位和0 .box4 span{ width: 50%; height: 50%; background: #000; overflow: auto; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; } 5、translate .box6 span{ position: absolute; top:50%; left:50%; width:100%; transform:translate(-50%,-50%); text-align: center; } 6、display:inline-block .box7{ text-align:center; font-size:0; } .box7 span{ vertical-align:middle; display:inline-block; font-size:16px; } .box7:after{ content:’’; width:0; height:100%; display:inline-block; vertical-align:middle; } after来占位 7、display:flex和margin:auto .box8{ display: flex; text-align: center; } .box8 span{margin: auto;} 8、display:-webkit-box &lt;div class=&quot;floater&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; Content here &lt;/div&gt; .floater { float:left; height:50%; margin-bottom:-120px; } .content { clear:both; height:240px; position:relative; }]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML常见问题]]></title>
    <url>%2F2017%2F11%2F03%2FHTML%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、行内元素和块级元素的实质上去别 1、行内元素会在一条直线上排列，都是同一行的，水平方向排列 块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。 2、块级元素可以包含行内元素和块级元素。行内元素只能容纳文本或者其他行内元素，除ins和del外，不能包含块状元素。 3、行内元素设置width无效宽度只与内容有关，height无效(可以设置line-height)，margin上下无效，padding上下无效 特别： 1、有几个特殊块级元素只能包含内联元素，不能包含块级元素。这几个特殊标签是 h1~h6、p、dt 2、块级元素与块级元素并列、内联元素与内联元素并列 3、行内替换元素！img、input、textarea、select、object都是替换元素。这些元素往往没有实际的内容，即是一个空元素]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part Two 基础篇]]></title>
    <url>%2F2017%2F11%2F02%2FJS2%2F</url>
    <content type="text"><![CDATA[来来来 看过来。。。。继续挖坑。。。。 16、事件监听 直接上干货 &lt;body&gt; &lt;div id=&quot;clickme&quot;&gt;点我&lt;/div&gt; &lt;div id=&quot;kk&quot; onclick=&quot;handler()&quot;&gt;注册时间&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function handler(){ alert(&apos;aaaa&apos;) } window.onload = function(){ var btn = document.getElementById(&apos;clickme&apos;); btn.addEventListener(&apos;click&apos;,function(){ alert(&quot;dddd&quot;) },false) btn.addEventListener(&apos;click&apos;,function(){ alert(&quot;cccc&quot;) },false) //错误写法，传入的function其实并不是同一个function btn.removeEventListener(&apos;click&apos;,function(){ alert(&apos;nnnn&apos;) }) //改写 function AAA(){ alert(&apos;lllll&apos;) } btn.addEventListener(&apos;click&apos;,AAA,false); btn.removeEventListener(&apos;click&apos;,AAA,false) } &lt;/script&gt; 17、最常见的邮箱正则是什么？ function isAvailableEmail(sEmail) { var reg = /^(\w)+(\.\w+)*@(\w)+((\.\w+))+$/; return reg.test(sEmail); } 18、实现字符串驼峰 function cssStyle2DomStyle(sName) { return sName.replace(/(?!^)\-(\w)(\w+)/g, function(a, b, c){ return b.toUpperCase() + c.toLowerCase(); }).replace(/^\-/, &apos;&apos;); } 19、检查字符串重复数字 function containsRepeatingLetter(str) { return /([a-zA-Z])\1/.test(str); } 20、 当然还有很多很多题目。。。BUT 有些是作为大前端必备的基础 SO 本宝宝会单独列出专题 FOR EXAMPLE 像是继承啦。。。一些基础算法啦。。对象啦等等一系列必备技能 想看的宝宝 阔以去看看专题呦😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘😘]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试那些事 -- Part One 基础篇]]></title>
    <url>%2F2017%2F11%2F02%2FJS1%2F</url>
    <content type="text"><![CDATA[啦啦啦啦啦啦。。。。。这可是本仙女呕心沥血总结出的，关于JS面试会问到的一些面试题。。。。。 都是血和泪啊 😢😢😢😢😢😢😢😢😢😢😢😢😢 小伙伴们别在踩坑了 😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭 本章先说一说比较常见的、基础问题问题 🐩 1、什么是事件机制？ 先说说什么是事件流。 事件流：指从页面中接收事件的顺序，有冒泡流和捕获流。 冒泡和捕获 我们点击一个div, 实际上是先点击document，然后点击事件传递到div,而且并不会在这个div就停下， div有子元素就还会向下传递，最后又会冒泡传递回document 为了兼容更多的浏览器，非特殊情况一般我们都是把事件添加到在事件冒泡阶段。 因为冒泡机制，比如既然点击子元素，也会触发父元素的点击事件， 那我们完全可以将子元素的事件要做的事写到父元素的事件里， 也就是将子元素的事件处理程序写到父元素的事件处理程序中，这就是事件委托； 利用事件委托，只指定一个事件处理程序，就可以管理某一个类型的所有事件 为什么要有事件委托那？ 利用冒泡的原理，把事件加到父级上，触发执行效果。 优点 1、提高性能。举个例子，如果我们要给li增加地阿基时间，如果说我们可能有很多个li用for循环的话就比较影响性能 2、新添加的元素还会有之前的事件.举个例子，我们要做动态的添加li 2、伪数组转数组 缺点 1、事件委托基于冒泡，对于不冒泡的事件不支持 2、层级过多，冒泡过程中，可能会被某层阻止掉 3、理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，比如在table上代理td，而不是在document上代理td。 4、把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。 方法一、 声明一个空数组，通过遍历伪数组把它们重新添加到新的数组中，大家都会，这不是面试官要的 var aLi = document.querySelectorAll(‘li’); var arr = []; for (var i = 0; i &lt; aLi.length; i++) { arr[arr.length] = aLi[i] } 方法二、使用数组的slice()方法 它返回的是数组，使用call或者apply指向伪数组 var arr = Array.prototype.slice.call(aLi); 方法3、 ES6中数组的新方法 from() // ES5的写法 var arr1 = [].slice.call(arrayLike) // ES6的写法 let arr2 = Array.from(arrayLike) 3、基本数据类型和引用数据类型区别 基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象 Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的， 因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据：对象类型Object type();Object 、Array 、Function 、Data javascript的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 var obj1 = new Object(); var obj2 = obj1; obj2.name = “我有名字了”; console.log(obj1.name); // 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 Es5的基本数据类型：undefined，null,Object,function,Number,string es6新增的一个数据类型：Symbol 4、实现回文字符串 //判断回文 function isPalindrome(line) { line += “”; return line === line.split(“”).reverse().join(“”); } 这种方法很方便，但效率不高，字符串分割，倒转，聚合都需要很多额外的操作。 function isPalindrome(line) { line += “”; for(var i=0,j=line.length-1;i&lt;j;i++,j–){ if(line.charAt(i) !== line.charAt(j)){ return false; } } return true; } 5、call，apply，bind之间的区别有哪些？ 在说区别之前还是先总结一下三者的相似之处： ① 都是用来改变函数的this对象的指向的。 ② 第一个参数都是this要指向的对象。 ③ 都可以利用后续参数传参。 区别: ① bind不会立即调用，其他两个会立即调用 ② apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）； ③ bind（)也是改变函数体内this的指向; 6、js的节流和去抖 节流：多次反复调用提议行为时 利用settimeout ，在一定时间内 不允许重复执行 消抖：多次反复调用提议行为时 利用settimeout，若在一时间内再次出发相同行为，则将之前行为的定时器去掉 7、settimeout和setInterval javascript都是以单线程的方式运行于浏览器的javascript引擎中的, setTimeout和setInterval的作用只是把你要执行的代码在你设定的一个 时间点插入js引擎维护的一个代码队列中, 插入代码队列并不意味着你的代码就会立马执行的 ① setTimeout function click() { // code block1… setTimeout(function() { // process … }, 200); // code block2 } 假设我们给一个button的onclick事件绑定了此方法, 当我们按下按钮后, 肯定先执行block1的内容, 然后运行到setTimeout的地方, setTimeout会告诉浏览器说, “200ms后我会插一段要执行的代码给你的队列中”, 浏览器当然答应了(注意插入代码并不意味着立马执行), setTimeout代码运行后, 紧跟其后的block2代码开始执行, 这里就开始说明问题了, 如果block2的代码执行时间超过200ms, 那结果会是如何? 或许按照你之前的理解, 会理所当然的认为200ms一到, 你的process代码会立马执行…事实是, 在block2执行过程中(执行了200ms后)process代码被插入代码队列, 但一直要等click方法执行结束, 才会执行process代码段, 从代码队列上看process代码是在click后面的, 再加上js以单线程方式执行, 所以应该不难理解. 如果是另一种情况, block2代码执行的时间&lt;200ms, setTimeout在200ms后将process代码插入到代码队列, 而那时执行线程可能已经处于空闲状态了(idle), 那结果就是200ms后, process代码插入队列就立马执行了, 就让你感觉200ms后, 就执行了. ② setInterval 时间间隔或许会跳过 时间间隔可能&lt;定时调用的代码的执行时间 function click() { // code block1… setInterval(function() { // process … }, 200); // code block2 } 比如onclick要300ms执行完, block1代码执行完, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, click代码顺利结束, process代码开始执行(相当于图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点, 下面问题来, 可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是, 由于代码队列中已经有了一份未执行的process代码, 所以605ms这个插入时间点将会被”无情”的跳过, 因为js引擎只允许有一份未执行的process代码, 说到这里不知道您是不是会豁然开朗呢… 8、解析url中的参数 function getUrlParam(sUrl,sKey){ var result = {}; sUrl.replace(/\??(\w+)=(\w+)&amp;?/g,function(a,k,v){ if(result[k] !== void 0){ var t = result[k]; result[k] = [].concat(t,v); }else{ result[k] = v; } }); if(sKey === void 0){ return result; }else{ return result[sKey] || ‘’; } } 9、JS的组成部分有那些 JavaScript的三大组成部分是: ① ECMAScript：JavaScript的核心，描述了语言的基本语法(var、for、if、array等)和 数据类型(数字、字符串、布尔、函数、对象(obj、[]、{}、null)、未定义)， ECMAScript是一套标准，定义了一种语言（比如JS）是什么样子 ② 文档对象模型（DOM）：DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API），DOM 将把 整个页面规划成由节点层级构成的文档 ③ 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作。 弹出新的浏览器窗口，移动、改变和关闭浏览器窗口， 提供详细的网络浏览器信息（navigator object），详细的页面信 息（location object），详细的用户屏幕分辨率的信息（screen object）， 对cookies的支持等等 10、函数声明方式 //函数声明 function x(){} //函数表达式）： var a = function(){} //构造函数发 var x = new Function(); 函数声明在代码执行以前被加载到作用域中， 函数表达式则是在代码执行到那一行的时候才会有定义 11、Date类型 Date.parse(‘1900-01-19’); // -2207433600000\ // // 创建一个日期对象, var now = new Date(), 新对象自动获得当前时间和对象。 如果想根据指定日期和时间的话，就必须传入该日期的毫秒数(从UTC时间1970年1月1日起)。 Date.parse(‘May 25, 2004’), 转成毫秒数。 (UTC时间) Date.UTC(2005, 4, 5, 17, 55, 55), 转成毫秒数。2005-05-05-17-55-55。(GMT时间) new Date()会模仿上面2种方法，也就是说可以直接向Date()构造函数传入上面两种参数的一种。 但是有一点儿区别，new Date()模仿的时候，都是根据UTC(世界协调时间)时间创建的，而非GMT(格林尼治标准时间)创建。 12、常见状态码的含义 2开头 （请求成功）表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 13、http和https ① HTTPS是以安全为目标的HTTP通道，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL ② https具有安全性的ssl加密传输协议需要到ca申请证书，http是超文本传输协议，明文传输 ③ http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443 SSL的位置介于应用层和TCP层之间，应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头 TLS/SSL中使用了非对称加密，对称加密以及HASH算法 14、常见的DOM操作 djsklajldks llllllll //创建节点 var container = document.getElementById("container") var para = document.createElement("p") var text = document.createTextNode("只是创建的节点") var c2 = document.getElementById('child2') para.appendChild(text); container.appendChild(para) //删除 container.removeChild(document.getElementById('child1')) //替换 container.replaceChild(para, c2) //插入 // container.insertBefore(para,c2) //克隆 var x = container.cloneNode() console.log(x) 15、闭包问题 简单来说，就是能访问一个函数内部的函数 上张图片 👇👇👇👇👇 举个🌰 function makeClosures(arr, fn) { var result = []; arr.forEach(function(e){ result.push(function(){ return fn(e) }) }) return result } 再举个🌰 function a() { var arg = []; for(var i = 0;i &lt; 10;i++) { arg[i] = function() { return i; }; } return arg; } a() 1; // 10 啦啦啦啦啦 最近有工作要忙 先到这 BUT 后面还有大批大批的僵尸会袭来呦😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨😨 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/JS2/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆 觉得小仙女叨叨的还不错的宝宝 可以戳下边打赏哦！☟☟☟☟☟☟☟☟☟☟☟ 么么哒😘]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>前端面试题</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第三弹]]></title>
    <url>%2F2017%2F11%2F02%2FES6%E7%AC%AC3%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[OK，CONTINUE… 二十一、尾调用 尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function factorial(n, acc = 1) { if (n &lt;= 1) return acc; return factorial(n - 1, n * acc); } console.log(factorial(10)) console.log(factorial(100)) console.log(factorial(1000)) console.log(factorial(10000)) console.log(factorial(100000)) console.log(factorial(1000000)) factorial(10) -&gt; 3628800 factorial(100) -&gt; 9.332621544394418e+157 factorial(1000) -&gt; Infinity factorial(10000) -&gt; Infinity factorial(100000) -&gt; RangeError: Maximum call stack size exceeded factorial(1000000) -&gt; RangeError: Maximum call stack size exceeded 二十二、扩展 ➕ 对象字面量 let {x,y,…z} = {x:1,y:2,a:3,b:4} console.log(x);//1 console.log(y);//2 console.log(z);//{ a: 3, b: 4 } let n = {x,y,…z}; console.log(n)//{ x: 1, y: 2, a: 3, b: 4 } console.log(obj） 二十三、故障弱化解构 var [a] = [] var [b = 1] = [] var c = [] console.log(a) console.log(b) console.log(c) a -&gt; undefined b -&gt; 1 c -&gt; [] function f(x,y=12){ return x + y } console.log(f(3)) console.log(f(3,2)) f(3) -&gt; 15 f(3,2) -&gt; 5 function f(x,y,z){ return x + y + z; } // 传递数组的每个元素作为参数 console.log(f(…[1,2,3])) f(…[1,2,3]) -&gt; 6 function f([x,y,z]){ return x + y + z; } // 传递数组的每个元素作为参数 console.log(f([1,2,3])) f([1,2,3]) -&gt; 6 var parts = [“shoulders”,”knees”]; var lyric = [“head”,…parts,”and”,”toes”]; console.log(lyric) lyrics -&gt; [“head”,”shoulders”,”knees”,”and”,”toes”] 二十四、代理 代理可以用来改变对象的行为。 它们允许我们定义 trap var obj = function ProfanityGenerator(){ return { word:”111111112222” } }() var handler = function CensoringHandler(){ return { get:function(target,key){ return target[key].replace(“11111111”,”3333”) } } }() var proxy = new Proxy(obj, handler); console.log(proxy.words); proxy.words -&gt; 33332222 var handler = { get:…, set:…, has:…, deleteProperty:…, apply:…, construct:…, getOwnPropertyDescriptor:…, defineProperty:…, getPrototypeOf:…, setPrototypeOf:…, enumerate:…, ownKeys:…, preventExtensions:…, isExtensible:… } 二十五、反射 新类型的元编程与新的API现有的还有一些新的方法。 var z = {w: “Super Hello”} var y = {x: “hello”, proto: z}; console.log(Reflect.getOwnPropertyDescriptor(y, “x”)); console.log(Reflect.has(y, “w”)); console.log(Reflect.ownKeys(y, “w”)); console.log(Reflect.has(y, “x”)); console.log(Reflect.deleteProperty(y,”x”)) console.log(Reflect.has(y, “x”)); Reflect.getOwnPropertyDescriptor(y, “x”) -&gt; {“value”:”hello”,”writable”:true,”enumerable”:true,”configurable”:true} Reflect.has(y, “w”) -&gt; true Reflect.ownKeys(y, “w”) -&gt; [“x”] Reflect.has(y, “x”) -&gt; true Reflect.deleteProperty(y,”x”) -&gt; true Reflect.has(y, “x”) -&gt; false 二十六、可继承内置函数 我们现在可以继承原生类。 class CustomArray extends Array{ } var a = new CustomArray(); a[0] = 2 console.log(a[0]) a[0] -&gt; 2 //不能使用数组的代理(Proxy)来覆盖getter函数。 二十七、新类库 console.log(Number.EPSILON) console.log(Number.isInteger(Infinity)) console.log(Number.isNaN(“NaN”)) console.log(Math.acosh(3)) console.log(Math.hypot(3, 4)) console.log(Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2)) console.log(“abcde”.includes(“cd”) ) console.log(“abc”.repeat(3) ) console.log(Array.of(1, 2, 3) ) console.log([0, 0, 0].fill(7, 1) ) console.log([1, 2, 3].find(x =&gt; x == 3) ) console.log([1, 2, 3].findIndex(x =&gt; x == 2)) console.log([1, 2, 3, 4, 5].copyWithin(3, 0)) console.log([“a”, “b”, “c”].entries() ) console.log([“a”, “b”, “c”].keys() ) console.log([“a”, “b”, “c”].values() ) console.log(Object.assign({}, { origin: new Point(0,0) })) Number.EPSILON -&gt; 2.220446049250313e-16 Number.isInteger(Infinity) -&gt; false Number.isNaN(“NaN”) -&gt; false Math.acosh(3) -&gt; 1.7627471740390859 Math.hypot(3, 4) -&gt; 5 Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) -&gt; 2 “abcde”.includes(“cd”) -&gt; true “abc”.repeat(3) -&gt; abcabcabc Array.of(1, 2, 3) -&gt; [1,2,3] [0, 0, 0].fill(7, 1) -&gt; [0,7,7] [1, 2, 3].find(x =&gt; x == 3) -&gt; 3 [1, 2, 3].findIndex(x =&gt; x == 2) -&gt; 1 [1, 2, 3, 4, 5].copyWithin(3, 0) -&gt; [1,2,3,1,2] [“a”, “b”, “c”].entries() -&gt; {} [“a”, “b”, “c”].keys() -&gt; {} [“a”, “b”, “c”].values() -&gt; TypeError: [“a”,”b”,”c”].values is not a function Object.assign({}, { origin: new Point(0,0) }) -&gt; ReferenceError: Point is not define 二十八、Reflect Reflect对象的设计目的有这样几个。 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上 修改某些Object方法的返回结果，让其变得更合理 让Object操作都变成函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法 Reflect对象一共有13个静态方法。 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的 Reflect.get(target, name, receiver) Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, } Reflect.get(myObject, ‘foo’) // 1 Reflect.get(myObject, ‘bar’) // 2 Reflect.get(myObject, ‘baz’) // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, }; var myReceiverObject = { foo: 4, bar: 4, }; Reflect.get(myObject, ‘baz’, myReceiverObject) // 8 如果第一个参数不是对象，Reflect.get方法会报错 Reflect.get(1, ‘foo’) // 报错 Reflect.get(false, ‘foo’) // 报错 Reflect.set(target, name, value, receiver) Reflect.set方法设置target对象的name属性等于value。 var myObject = { foo: 1, set bar(value) { return this.foo = value; }, } myObject.foo // 1 Reflect.set(myObject, ‘foo’, 2); myObject.foo // 2 Reflect.set(myObject, ‘bar’, 3) myObject.foo // 3]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第二弹]]></title>
    <url>%2F2017%2F11%2F02%2FES6%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[吼吼，来吧，小宝贝，废话不多说，咱们书接上回。。。。 十一、Prosmises 异步编程 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 Promise对象有以下两个特点: （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 （2）Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） var promise = new Promise(function(resolve, reject) { // … some code if (/ 异步操作成功 /){ resolve(value); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved） } else { reject(error); reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected } }); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用 第二个回调函数是Promise对象的状态变为rejected时调用。 来个 🌰 吼吼 👇 var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;resolve(“1”),101) }) var p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(“2”), 100) }) Promise.race([p1, p2]).then((res) =&gt; { console.log(res) }) Promise.all([p1, p2]).then((res) =&gt; { console.log(res) }) res -&gt; 2 res -&gt; [“1”,”2”] var p1 = Promise.resolve(“1”) var p2 = Promise.reject(“2”) Promise.race([p1, p2]).then((res) =&gt; { console.log(res) }) ※※※※ ➡️ 如果一个 promise 失败，all和race也将 reject(拒绝)。 让我们举个 🌰 ，come on 👇 var p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; resolve(“1”), 1001) }) var p2 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; reject(“2”), 1) }) Promise.race([p1, p2]).then((res) =&gt; { console.log(“success” + res) }, res =&gt; { console.log(“error “ + res) }) Promise.all([p1, p2]).then((res) =&gt; { console.log(“success” + res) }, res =&gt; { console.log(“error “ + res) }) “error “ + res -&gt; error 2 “error “ + res -&gt; error 2 Promise也有一些缺点。首先，无法取消Promise， Promise 新建后就会立即执行 使用Promise解决多个异步依赖调用 Promise提供了一个方法Promise.all([p1,p2,p3]) ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象。 此时Promise.all的状态取决于它的参数。 分两种情况： p1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve； 只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject； 所以我们可以用Promise.all()来解决多个异步依赖调用。 ###################################################### 十二、Symbol 话不多说，直接上干货 var typeSymbol = Symbol(“type”); var typeSymbol = Symbol(“type”); class Pet{ constructor(type){ this[typeSymbol] = type } getType(){ return this[typeSymbol] } } var a = new Pet(“dog”); console.log(a.getType()); console.log(Object.getOwnPropertyNames(a)) console.log(Symbol(“a”) === Symbol(“a”)) a.getType() -&gt; dog Object.getOwnPropertyNames(a) -&gt; [] Symbol(“a”) === Symbol(“a”) -&gt; false ###################################################### 十三、Unicode var regex = new RegExp(‘\u{61}’,’u’) console.log(regex.unicode) console.log(“\uD842\uDFD7”) console.log(“\uD842\uDFD7”.codePointAt()) ###################################################### 十四、箭头函数 var evens = [2, 4, 6, 8, 10, 12, 14]; var odds = evens.map(v =&gt; v + 1) var nums = events.map((v,i) =&gt; v + i) var pairs = events.map(v =&gt; ({even: v,odd:v + 1})) 0:{even: 2, odd: 3} 1:{even: 4, odd: 5} 2:{even: 6, odd: 7} 3:{even: 8, odd: 9} 4:{even: 10, odd: 11} 5:{even: 12, odd: 13} 6:{even: 14, odd: 15} nums.forEach(v =&gt; { if(v%5 === 0) fives.push(v) }) 啰嗦一句，请注意箭头函数中的this！！！！！！！！神坑啊 嵌套的箭头函数怎么办，箭头函数内部，还可以再使用箭头函数 let insertn = (v) = &gt; ({intro:(arr)=&gt;({obj:(o)=&gt; { arr.splice(array.indexOf(o)+1,0,v); return arr; } })}) //部署管道机制，即前一个函数的输出是后一个函数的输入。 const pip = (…fn) =&gt; val =&gt;fn.reduce((a,b)=&gt;b(a),val); const p1 = a =&gt;a+1 const p2 = a =&gt;a*2 const add = pip(p1,p2) add(5); ###################################################### 十五、解构 var [a,,b] = [1,2,3]; console.log(a); console.log(b); a -&gt; 1 b -&gt; 3 nodes = () =&gt;{ return {op:’a’,lhs:’b’,rhs:’c’} } var { op:a,lhs:b,rhs:c } = nodes() conosle.log(a); console.log(b); console.log(c); a -&gt; a b -&gt; b c -&gt; c nodes = () =&gt; { return {lhs: “a”, op: “b”, rhs: “c”}} // binds op, lhs and rhs in scope var {op, lhs, rhs} = nodes() console.log(op) console.log(lhs) console.log(rhs) op -&gt; b lhs -&gt; a rhs -&gt; c unction g({name:x}){ return x; } function m({name}){ return name } console.log(g({name:5})) console.log(m({name:5})) g({name: 5}) -&gt; 5 m({name: 5}) -&gt; 5 ###################################################### 十六、模块和模块加载器 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 eg: import { stat, exists, readFile } from ‘fs’; 上面代码的实质是从fs模块加载3个方法，其他方法不加载 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 重要的事情说三遍！！！！！！ 严格模式主要有以下限制: 1、变量必须声明后再使用 2、函数的参数不能有同名属性，否则报错 3、不能使用with语句 4、不能对只读属性赋值，否则报错 5、不能使用前缀0表示八进制数，否则报错 6、不能删除不可删除的属性，否则报错 7、不能删除变量delete prop，会报错，只能删除属性delete global[prop] 8、eval不会在它的外层作用域引入变量 9、eval和arguments不能被重新赋值 10、arguments不会自动反映函数参数的变化 11、不能使用arguments.callee 12、不能使用arguments.caller 13、禁止this指向全局对象 14、不能使用fn.caller和fn.arguments获取函数调用的堆栈 15、增加了保留字（比如protected、static和interface） 上个 🌰 import {firstName, lastName, year} from ‘./profile’; //import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略 function setName(element) { element.textContent = firstName + ‘ ‘ + lastName; } 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surname } from ‘./profile’; 警报警报 一大波 僵尸袭来 ~~ import defaultMember from “module-name”; import as name from “module-name”; import { member } from “module-name”; import { member as alias } from “module-name”; import { member1 , member2 } from “module-name”; import { member1 , member2 as alias2 , […] } from “module-name”; import defaultMember, { member [ , […] ] } from “module-name”; import defaultMember, as name from “module-name”; import “module-name”; 再来说说export这个小妖精 export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能 export var firstName = ‘Michael’; export var lastName = ‘Jackson’; export var year = 1958; // profile.js var firstName = ‘Michael’; var lastName = ‘Jackson’; var year = 1958; export {firstName, lastName, year}; 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名 function v1() { … } function v2() { … } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; 重命名后，v2可以用不同的名字输出两次 哇呕 ~~~~有一大波僵尸正在狂奔而来！！！！！ export { name1, name2, …, nameN }; export { variable1 as name1, variable2 as name2, …, nameN }; export let name1, name2, …, nameN; // also var export let name1 = …, name2 = …, …, nameN; // also var, const export expression; export default expression; export default function (…) { … } // also class, function export default function name1(…) { … } // also class, function export { name1 as default, … }; export * from …; export { name1, name2, …, nameN } from …; export { import1 as name1, import2 as name} ###################################################### 十七、生成器 生成器创建迭代器，并且比迭代器更具动态性 先来一堆代码 var initinity = { [Symbol.iterator]:function*(){ var c = 1; for(;;){ yield c++; } } } console.log(“start”) for(var n of infinity){ if(n&gt;10) break; console.log(n) } “start” -&gt; start n -&gt; 1 n -&gt; 2 n -&gt; 3 n -&gt; 4 n -&gt; 5 n -&gt; 6 n -&gt; 7 n -&gt; 8 n -&gt; 9 n -&gt; 10 interface Generator extends Iterator { next(value?: any): IteratorResult; throw(exception: any); } function* anotherGenerator(i) { yield i + 1; yield i + 2; yield i + 3; } function generator(i) { yield i; yield anotherGenerator(i); yield i + 10; } var gen = generator(10); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value); gen.next().value -&gt; 10 gen.next().value -&gt; 11 gen.next().value -&gt; 12 gen.next().value -&gt; 13 gen.next().value -&gt; 20 function* list(value) { for (var item of value) { yield item; } } for (var value of list([1, 2, 3])) { console.log(value); } var iterator = list([1, 2, 3]); console.log(typeof iterator.next); // function console.log(typeof iterator[Symbol.iterator]); // function console.log(iterator.next().value); // 1 for (var value of iterator) { console.log(value); // 2, 3 } table[Symbol.iterator] = function* () { var keys = Object.keys(this).sort(); for (var item of keys) { yield item; } } 执行 Generator 函数会返回一个遍历器对象，也就是说， Generator 函数除了状态机，还是一个遍历器对象生成函数 返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态 形式上，Generator 函数是一个普通函数，但是有两个特征 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式，定义不同的内部状态 function* helloWorldGenerator() { yield ‘hello’; yield ‘world’; return ‘ending’; } 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。 不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果， 而是一个指向内部状态的指针对象 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态 也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行， 直到遇到下一个yield表达式（或return语句）为止 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记， 而next方法可以恢复执行 hw.next() // { value: ‘hello’, done: false } hw.next() // { value: ‘world’, done: false } hw.next() // { value: ‘ending’, done: true } hw.next() // { value: undefined, done: true } yield 表达式 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态， 所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 ###################################################### 十八、迭代器 迭代器是一个比数组更动态的类型 允许我们在语言层面上定义一个（有限或无限的）序列。 对于for-in循环，它有许多的问题。但是最大的问题，便是它不保证迭代的顺序。 但是当我们使用ES6迭代器时，这个问题就迎刃而解了。 let infinite = { Symbol.iterator{ let c = 0; return { next(){ c++; return { done:false,value:c } } } } } console.log(“start”) for(var n of infinite){ if(n &gt; 10) break; console.log(n); } “start” -&gt; start n -&gt; 1 n -&gt; 2 n -&gt; 3 n -&gt; 4 n -&gt; 5 n -&gt; 6 n -&gt; 7 n -&gt; 8 n -&gt; 9 n -&gt; 10 //使用Typescript，我们可以看到它接口的样子 interface IteratorResult { done:boolean; value:any; } interface Iterator{ next():IteratorResult; } interface Iterable{ Symbol.iterator:Iterator } 使用for-of，我们得到的是一个可以保证顺序的迭代。 为了让一个对象可以被迭代器所迭代，对象需要实现一个“迭代协议”，即拥有一个Symbol.iterator属性。 这个属性会被for-of所使用，在我们的例子中，它就是table[Symbol.iterator]。 Symbol.iterator只需认为它是对象的一个特殊属性，并且永远不会和其他普通属性产生冲突 table[Symbol.iterator]的值，必须是一个符合“迭代协议”的函数， 即它需要返回一个类似于{ next: function () {} }的对象。 table[Symbol.iterator] = function () { return { next: function () {} } } 然后，在for-of循环每次调用next()函数时， 它需要返回一个类似于{value: …, done: [true/false]}的对象。 所以，一个迭代器的完整实现类似于如下的例子： table[Symbol.iterator] = function () { var keys = Object.keys(this).sort(); var index = 0; return { next: function () { return { value: keys[index], done: index++ &gt;= keys.length }; } } } 惰性执行 迭代器允许我们在第一次调用next()函数之后，再执行相应的逻辑。 在上面的例子里，当我们调用迭代器的瞬间，我们就立刻执行了排序和取值的工作。 但是，如果next()函数永远不被调用的话，我们就浪费了性能。所以让我们来优化它： table[Symbol.iterator] = function () { var _this = this; var keys = null; var index = 0; return { next: function () { if (keys === null) { keys = Object.keys(_this).sort(); } return { value: keys[index], done: index++ &gt;= keys.length }; } } } String，Array，TypedArray，Map和Set都是内置迭代器，因为它们的原型中都有一个Symbol.iterator方法 只要永远不返回done: true，就实现了一个无限迭代器。当然，需要极力避免出现这种情况。 var ids = { *[Symbol.iterator]: function () { var index = 0; return { next: function () { return { value: &apos;id-&apos; + index++, done: false }; } }; } }; var counter = 0; for (var value of ids) { console.log(value); if (counter++ &gt; 1000) { // let’s make sure we get out! break; } } ###################################################### 十九、增强对象字面量 var theProtoObj = { toString:function(){ return “the ProtoObject to string” } } var handler = () =&gt; “handler” var obj = { proto:theProtoObj, handler, toString(){ return “d “+super.toString(); }, [&quot;prop_&quot; + (() =&gt; 42)()]:42 } console.log(obj.handler) console.log(obj.handler()) console.log(obj.toString()) console.log(obj.prop_42) ###################################################### 二十、字符串插值 var name = “Bob”,time = “today”; var multiLine = `This Line Spans Multiple Line` console.log( Hello ${name},how are you ${time}?); console.log(multiLine) Hello ${name},how are you ${time}? -&gt; Hello Bob,how are you today? multiLine -&gt; This Line Spans Multiple Lines 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/ES6%E7%AC%AC3%E5%BC%B9/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6所有特点应用 -- 第一弹]]></title>
    <url>%2F2017%2F11%2F01%2FES6%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ps：这是本宝宝搜罗N多个人的博客、资料最后的大汇总，如有雷同也是正常现象 pps：各位大大们请不要在意这些细节喽，宽容点噻。 ppps：由于本仙女实在是太懒了，so，嘿嘿!就只挑重点记录喽，please 不要喷我。。。 一、Let { var globalVar = “from demo1” } { let globalLet = “from demo2” } console.log(globalVar) console.log(globalLet) globalVar -&gt; from demo1 globalLet -&gt; ReferenceError: globalLet is not defined 它不会向window分配任何内容： let me = “go” var i = “able” console.log(window.me) console.log(window.i) window.me -&gt; undefined window.i -&gt; able 不能使用let重新声明一个变量： let me = “foo”; let me = “bar”; console.log(me); SyntaxError: Identifier ‘me’ has already been declared ######################################################## 二、Const 一个不能被更改的值 const a = “b” a = “a” TypeError: Assignment to constant variable. 应该注意，const 对象仍然可以被改变的。 const a = { a: “a” } a.a = “b” console.log(a) a -&gt; {“a”:”b”} ######################################################## 三、Class类 class ColorPoint extends Point { } // 等同于 class ColorPoint extends Point { constructor(…args) { super(…args); } } 举个🌰 吧 class Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 } } let cp = new ColorPoint(25, 8, ‘green’); //上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例 cp instanceof ColorPoint // true cp instanceof Point // true 再举个🌰 class A { static hello() { console.log(‘hello world’); } } class B extends A { } B.hello() // hello world //hello()是A类的静态方法，B继承A，也继承了A的静态方法 还想再来个🌰 class A { constructor() { console.log(new.target.name); //new.target指向当前正在执行的函数 } } class B extends A { constructor() { super(); } } new A() // A new B() // B 小可爱们看过来吖，看过来👀 class Student { // 构造函数 // 只能声明一个，否则会报以下错误(Safari 10.0)： // SyntaxError: Cannot declare multiple constructors in a single class. constructor(name, age) { // 类成员变量不用事先声明 this.name = name; this.age = age; if (age === undefined) { log(&apos;没有传age参数&apos;); } } // 方法 sayHello(message) { // this不能省略 log(&quot;Hello &quot; + this.name + &quot;: &quot; + message); } sayHelloEx(message) { log(&quot;Hello &quot; + this.name + &apos;[&apos; + this.age + &apos;]: &apos; + message); } } class SkinnedMesh extends THREES.Mesh { constructor(geometry,materials){ super(geometry,materials);// 调用父类的constructor //子类必须在constructor方法中调用super方法，否则新建实例时会报错 //这是因为子类没有自己的this对象，而是继承父类的this对象 this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.bonesMatrices = [] //在子类的构造函数中，只有调用super之后，才可以使用this关键字 } //constructor方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 update(camera){ super.update() } get boneCount(){ return this.bones.length } set MatrixType(matrixType){ this.idMatrix = SkinnedMesh matrixType; } static defaultMatrix(){ return new THREES.Matrix4(); } } ######################################################## 四、For…of 迭代器的新类型，可以替代for..in。 它返回的是值而不是keys let list = [4, 5, 6]; console.log(list) for (let i of list) { console.log(i); } list -&gt; [4,5,6] i -&gt; 4 i -&gt; 5 i -&gt; 6 没有对比就没有伤害，看这里👇 for(let i in list){ console.log(i) } list -&gt; [4,5,6] i -&gt; 0 i -&gt; 1 i -&gt; 2 ######################################################## 五、Set Set 为数学对应，其中所有项目都是唯一的 var set = new Set(); set.add(“Potato”).add(“Tomato”).add(“Tomato”) console.log(set.size) console.log(set.has(“Tomato”)) for(var item of set) { console.log(item) } set.size -&gt; 2 set.has(“Tomato”) -&gt; true item -&gt; Potato item -&gt; Tomato ######################################################## 六、Rest 我们可以使用 rest 操作符来允许无限参数 rest … function demo(part1,…part2){ return {part1,part2} } console.log(demo(1,2,3,4,6)) demo(1,2,3,4,5,6) -&gt; {“part1”:1,”part2”:[2,3,4,5,6]} ######################################################## 七、Map var map = new Map(); map.set(“Potato”,12) map.set(“Tomato”,34) console.log(map.get(“Potato”)) for(let item of map){ console.log(item) } map.get(“Potato”) -&gt; 12 item -&gt; [“Potato”,12] item -&gt; [“Tomato”,34] for(let item in map){ console.log(item) } //undefined 可以使用除字符串之外的其他类型。 var map = new Map(); var key = {a: “a”} map.set(key, 12); console.log(map.get(key)) console.log(map.get({a: “a”})) map.get(key) -&gt; 12 map.get({a: “a”}) -&gt; undefined ######################################################## 八、WeakMap 使用键的对象，并且只保留对键的弱引用。 var wm = new WeakMap(); var o1 = {} var o2 = {} var o3 = {} wm.set(o1,1) wm.set(o2,2) wm.set(o3,{a:”a”}) wm.set({},4) console.log(wm.get(o2)) console.log(wm.has({})) delete o2; console.log(wm.get(o3)) for(let item in wm) { console.log(item) } for(let item of wm) { console.log(item) } 接下来让我们来看一下输出的结果吧 wm.get(o2) -&gt; 2 wm.has({}) -&gt; false wm.get(o3) -&gt; {“a”:”a”} 没有size属性,没有办法遍历它的成员 TypeError: wm[Symbol.iterator] is not a function surprise！！！🎉 有没有很惊喜吖 是不是和想的不一样捏 吼吼 稳住 我们能赢 让我们趁热打铁，来迎接下一个暴击 ######################################################## 九、WeakSet 也是不重复的值的集合 WeakSet 的成员只能是对象 WeakSet对象允许您在集合中存储弱持有的对象,没有引用的对象将被垃圾回收 var item = {a:”Potato”} var set new WeakSet(); set.add({a:”Potato”}).add(item).add({a:”Tomato”}).add({a:”Tomato”}) console.log(set.size) console.log(set.has({a:”Tomato”})) console.log(set.has(item)) for(let item of set) { console.log(item) } ※※※ ➡ WeakSet没有size属性,没有办法遍历它的成员 接下来让我们再来看一下输出的结果吧！！！！ set.size -&gt; undefined set.has({a:”Tomato”}) -&gt; false set.has(item) -&gt; true TypeError: set[Symbol.iterator] is not a function 号外号外 📢 const a = [[1, 2], [3, 4]]; const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]} 注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象 ######################################################## 十、关于This var object = { name:”Name”, arrowGetName:() =&gt; this.name, regularGetName:function(){ return this.name }, arrowGetThis:() =&gt; this, regularGetThis:function(){ return this } } console.log(object.arrowGetName()) console.log((object.arrowGetThis()) console.log(this) console.log(object.regularGetName()) console.log(object.regularGetThis()) object.arrowGetName() -&gt; object.arrowGetThis() -&gt; [object Window] this -&gt; [object Window] object.regularGetName() -&gt; Name object.regularGetThis() -&gt; {“name”:”Name”} 小葵花妈妈课堂开课了，小仙女感冒老不好，多半是废了。。。。。。。。 各位道友们，咱们下一章见。。。咳咳。。。小仙女要去吃药了 想继续的宝宝 戳一戳 去下一弹👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 http://icey-monopolize.com/2017/11/02/ES6%E7%AC%AC%E4%BA%8C%E5%BC%B9/ 🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆🎆]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This Is the Beginning of the Story]]></title>
    <url>%2F2017%2F11%2F01%2FWebsite%2F</url>
    <content type="text"><![CDATA[忘了是什么时间，忘了在什么地点，只记得有人写过这样的话。。。 我走过山的时候，山不说话 我路过海的时候，海不说话 我坐着的毛驴一步一步滴滴答答 我带着的倚天喑哑 大家说我因为爱着杨过大侠 找不到 所以在峨眉安家 其实我只是喜欢峨眉的雾 像十六岁那年绽放的烟花 我路过海的时候，海不说话 我走过山的时候也听不到回答 我骑的毛驴 步步滴滴答答 悠悠飘向远处可从不想要回家 正当喜乐无忧年 韶华如花 远游风尘之色却不似十九风华 –程灵素]]></content>
      <categories>
        <category>ALL</category>
      </categories>
      <tags>
        <tag>ALL</tag>
        <tag>绘图类</tag>
        <tag>CSS</tag>
        <tag>前端面试题</tag>
        <tag>算法</tag>
        <tag>ES6</tag>
        <tag>HTML</tag>
        <tag>JS</tag>
        <tag>JQ</tag>
        <tag>NODEJS</tag>
        <tag>VUE</tag>
        <tag>VUEX</tag>
        <tag>WEBPACK</tag>
        <tag>FRAME</tag>
        <tag>ARTICAL</tag>
        <tag>LIFE</tag>
        <tag>SENTIMENTS</tag>
        <tag>H5</tag>
        <tag>浏览器</tag>
        <tag>BOOTSTRAAP</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Photoes]]></title>
    <url>%2Fphotoes%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
